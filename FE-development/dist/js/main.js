/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/resources";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/@google/markerclusterer/src/markerclusterer.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@google/markerclusterer/src/markerclusterer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3_3.js
// ==/ClosureCompiler==

/**
 * @name MarkerClusterer for Google Maps v3
 * @version version 1.0.3
 * @author Luke Mahe
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of
 * markers.
 */

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A Marker Clusterer that clusters markers.
 *
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>=} opt_markers Optional markers to add to
 *   the cluster.
 * @param {Object=} opt_options support the following options:
 *     'gridSize': (number) The grid size of a cluster in pixels.
 *     'maxZoom': (number) The maximum zoom level that a marker can be part of a
 *                cluster.
 *     'zoomOnClick': (boolean) Whether the default behaviour of clicking on a
 *                    cluster is to zoom into it.
 *     'imagePath': (string) The base URL where the images representing
 *                  clusters will be found. The full URL will be:
 *                  {imagePath}[1-5].{imageExtension}
 *                  Default: '../images/m'.
 *     'imageExtension': (string) The suffix for images URL representing
 *                       clusters will be found. See _imagePath_ for details.
 *                       Default: 'png'.
 *     'averageCenter': (boolean) Whether the center of each cluster should be
 *                      the average of all markers in the cluster.
 *     'minimumClusterSize': (number) The minimum number of markers to be in a
 *                           cluster before the markers are hidden and a count
 *                           is shown.
 *     'styles': (object) An object that has style properties:
 *       'url': (string) The image url.
 *       'height': (number) The image height.
 *       'width': (number) The image width.
 *       'anchor': (Array) The anchor position of the label text.
 *       'textColor': (string) The text color.
 *       'textSize': (number) The text size.
 *       'backgroundPosition': (string) The position of the backgound x, y.
 * @constructor
 * @extends google.maps.OverlayView
 */
function MarkerClusterer(map, opt_markers, opt_options) {
  // MarkerClusterer implements google.maps.OverlayView interface. We use the
  // extend function to extend MarkerClusterer with google.maps.OverlayView
  // because it might not always be available when the code is defined so we
  // look for it at the last possible moment. If it doesn't exist now then
  // there is no point going ahead :)
  this.extend(MarkerClusterer, google.maps.OverlayView);
  this.map_ = map;

  /**
   * @type {Array.<google.maps.Marker>}
   * @private
   */
  this.markers_ = [];

  /**
   *  @type {Array.<Cluster>}
   */
  this.clusters_ = [];

  this.sizes = [53, 56, 66, 78, 90];

  /**
   * @private
   */
  this.styles_ = [];

  /**
   * @type {boolean}
   * @private
   */
  this.ready_ = false;

  var options = opt_options || {};

  /**
   * @type {number}
   * @private
   */
  this.gridSize_ = options['gridSize'] || 60;

  /**
   * @private
   */
  this.minClusterSize_ = options['minimumClusterSize'] || 2;


  /**
   * @type {?number}
   * @private
   */
  this.maxZoom_ = options['maxZoom'] || null;

  this.styles_ = options['styles'] || [];

  /**
   * @type {string}
   * @private
   */
  this.imagePath_ = options['imagePath'] ||
      this.MARKER_CLUSTER_IMAGE_PATH_;

  /**
   * @type {string}
   * @private
   */
  this.imageExtension_ = options['imageExtension'] ||
      this.MARKER_CLUSTER_IMAGE_EXTENSION_;

  /**
   * @type {boolean}
   * @private
   */
  this.zoomOnClick_ = true;

  if (options['zoomOnClick'] != undefined) {
    this.zoomOnClick_ = options['zoomOnClick'];
  }

  /**
   * @type {boolean}
   * @private
   */
  this.averageCenter_ = false;

  if (options['averageCenter'] != undefined) {
    this.averageCenter_ = options['averageCenter'];
  }

  this.setupStyles_();

  this.setMap(map);

  /**
   * @type {number}
   * @private
   */
  this.prevZoom_ = this.map_.getZoom();

  // Add the map event listeners
  var that = this;
  google.maps.event.addListener(this.map_, 'zoom_changed', function() {
    // Determines map type and prevent illegal zoom levels
    var zoom = that.map_.getZoom();
    var minZoom = that.map_.minZoom || 0;
    var maxZoom = Math.min(that.map_.maxZoom || 100,
                         that.map_.mapTypes[that.map_.getMapTypeId()].maxZoom);
    zoom = Math.min(Math.max(zoom,minZoom),maxZoom);

    if (that.prevZoom_ != zoom) {
      that.prevZoom_ = zoom;
      that.resetViewport();
    }
  });

  google.maps.event.addListener(this.map_, 'idle', function() {
    that.redraw();
  });

  // Finally, add the markers
  if (opt_markers && (opt_markers.length || Object.keys(opt_markers).length)) {
    this.addMarkers(opt_markers, false);
  }
}


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = '../images/m';


/**
 * The marker cluster image path.
 *
 * @type {string}
 * @private
 */
MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = 'png';


/**
 * Extends a objects prototype by anothers.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
MarkerClusterer.prototype.extend = function(obj1, obj2) {
  return (function(object) {
    for (var property in object.prototype) {
      this.prototype[property] = object.prototype[property];
    }
    return this;
  }).apply(obj1, [obj2]);
};


/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.onAdd = function() {
  this.setReady_(true);
};

/**
 * Implementaion of the interface method.
 * @ignore
 */
MarkerClusterer.prototype.draw = function() {};

/**
 * Sets up the styles object.
 *
 * @private
 */
MarkerClusterer.prototype.setupStyles_ = function() {
  if (this.styles_.length) {
    return;
  }

  for (var i = 0, size; size = this.sizes[i]; i++) {
    this.styles_.push({
      url: this.imagePath_ + (i + 1) + '.' + this.imageExtension_,
      height: size,
      width: size
    });
  }
};

/**
 *  Fit the map to the bounds of the markers in the clusterer.
 */
MarkerClusterer.prototype.fitMapToMarkers = function() {
  var markers = this.getMarkers();
  var bounds = new google.maps.LatLngBounds();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }

  this.map_.fitBounds(bounds);
};


/**
 *  Sets the styles.
 *
 *  @param {Object} styles The style to set.
 */
MarkerClusterer.prototype.setStyles = function(styles) {
  this.styles_ = styles;
};


/**
 *  Gets the styles.
 *
 *  @return {Object} The styles object.
 */
MarkerClusterer.prototype.getStyles = function() {
  return this.styles_;
};


/**
 * Whether zoom on click is set.
 *
 * @return {boolean} True if zoomOnClick_ is set.
 */
MarkerClusterer.prototype.isZoomOnClick = function() {
  return this.zoomOnClick_;
};

/**
 * Whether average center is set.
 *
 * @return {boolean} True if averageCenter_ is set.
 */
MarkerClusterer.prototype.isAverageCenter = function() {
  return this.averageCenter_;
};


/**
 *  Returns the array of markers in the clusterer.
 *
 *  @return {Array.<google.maps.Marker>} The markers.
 */
MarkerClusterer.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 *  Returns the number of markers in the clusterer
 *
 *  @return {Number} The number of markers.
 */
MarkerClusterer.prototype.getTotalMarkers = function() {
  return this.markers_.length;
};


/**
 *  Sets the max zoom for the clusterer.
 *
 *  @param {number} maxZoom The max zoom level.
 */
MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
  this.maxZoom_ = maxZoom;
};


/**
 *  Gets the max zoom for the clusterer.
 *
 *  @return {number} The max zoom level.
 */
MarkerClusterer.prototype.getMaxZoom = function() {
  return this.maxZoom_;
};


/**
 *  The function for calculating the cluster icon image.
 *
 *  @param {Array.<google.maps.Marker>} markers The markers in the clusterer.
 *  @param {number} numStyles The number of styles available.
 *  @return {Object} A object properties: 'text' (string) and 'index' (number).
 *  @private
 */
MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
  var index = 0;
  var count = markers.length;
  var dv = count;
  while (dv !== 0) {
    dv = parseInt(dv / 10, 10);
    index++;
  }

  index = Math.min(index, numStyles);
  return {
    text: count,
    index: index
  };
};


/**
 * Set the calculator function.
 *
 * @param {function(Array, number)} calculator The function to set as the
 *     calculator. The function should return a object properties:
 *     'text' (string) and 'index' (number).
 *
 */
MarkerClusterer.prototype.setCalculator = function(calculator) {
  this.calculator_ = calculator;
};


/**
 * Get the calculator function.
 *
 * @return {function(Array, number)} the calculator function.
 */
MarkerClusterer.prototype.getCalculator = function() {
  return this.calculator_;
};


/**
 * Add an array of markers to the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
  if (markers.length) {
    for (var i = 0, marker; marker = markers[i]; i++) {
      this.pushMarkerTo_(marker);
    }
  } else if (Object.keys(markers).length) {
    for (var marker in markers) {
      this.pushMarkerTo_(markers[marker]);
    }
  }
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
  marker.isAdded = false;
  if (marker['draggable']) {
    // If the marker is draggable add a listener so we update the clusters on
    // the drag end.
    var that = this;
    google.maps.event.addListener(marker, 'dragend', function() {
      marker.isAdded = false;
      that.repaint();
    });
  }
  this.markers_.push(marker);
};


/**
 * Adds a marker to the clusterer and redraws if needed.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean=} opt_nodraw Whether to redraw the clusters.
 */
MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
  this.pushMarkerTo_(marker);
  if (!opt_nodraw) {
    this.redraw();
  }
};


/**
 * Removes a marker and returns true if removed, false if not
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 * @private
 */
MarkerClusterer.prototype.removeMarker_ = function(marker) {
  var index = -1;
  if (this.markers_.indexOf) {
    index = this.markers_.indexOf(marker);
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        index = i;
        break;
      }
    }
  }

  if (index == -1) {
    // Marker is not in our list of markers.
    return false;
  }

  marker.setMap(null);

  this.markers_.splice(index, 1);

  return true;
};


/**
 * Remove a marker from the cluster.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 * @return {boolean} True if the marker was removed.
 */
MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
  var removed = this.removeMarker_(marker);

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  } else {
   return false;
  }
};


/**
 * Removes an array of markers from the cluster.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean=} opt_nodraw Optional boolean to force no redraw.
 */
MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
  // create a local copy of markers if required
  // (removeMarker_ modifies the getMarkers() array in place)
  var markersCopy = markers === this.getMarkers() ? markers.slice() : markers;
  var removed = false;

  for (var i = 0, marker; marker = markersCopy[i]; i++) {
    var r = this.removeMarker_(marker);
    removed = removed || r;
  }

  if (!opt_nodraw && removed) {
    this.resetViewport();
    this.redraw();
    return true;
  }
};


/**
 * Sets the clusterer's ready state.
 *
 * @param {boolean} ready The state.
 * @private
 */
MarkerClusterer.prototype.setReady_ = function(ready) {
  if (!this.ready_) {
    this.ready_ = ready;
    this.createClusters_();
  }
};


/**
 * Returns the number of clusters in the clusterer.
 *
 * @return {number} The number of clusters.
 */
MarkerClusterer.prototype.getTotalClusters = function() {
  return this.clusters_.length;
};


/**
 * Returns the google map that the clusterer is associated with.
 *
 * @return {google.maps.Map} The map.
 */
MarkerClusterer.prototype.getMap = function() {
  return this.map_;
};


/**
 * Sets the google map that the clusterer is associated with.
 *
 * @param {google.maps.Map} map The map.
 */
MarkerClusterer.prototype.setMap = function(map) {
  this.map_ = map;
};


/**
 * Returns the size of the grid.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getGridSize = function() {
  return this.gridSize_;
};


/**
 * Sets the size of the grid.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setGridSize = function(size) {
  this.gridSize_ = size;
};


/**
 * Returns the min cluster size.
 *
 * @return {number} The grid size.
 */
MarkerClusterer.prototype.getMinClusterSize = function() {
  return this.minClusterSize_;
};

/**
 * Sets the min cluster size.
 *
 * @param {number} size The grid size.
 */
MarkerClusterer.prototype.setMinClusterSize = function(size) {
  this.minClusterSize_ = size;
};


/**
 * Extends a bounds object by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 */
MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
  var projection = this.getProjection();

  // Turn the bounds into latlng.
  var tr = new google.maps.LatLng(bounds.getNorthEast().lat(),
      bounds.getNorthEast().lng());
  var bl = new google.maps.LatLng(bounds.getSouthWest().lat(),
      bounds.getSouthWest().lng());

  // Convert the points to pixels and the extend out by the grid size.
  var trPix = projection.fromLatLngToDivPixel(tr);
  trPix.x += this.gridSize_;
  trPix.y -= this.gridSize_;

  var blPix = projection.fromLatLngToDivPixel(bl);
  blPix.x -= this.gridSize_;
  blPix.y += this.gridSize_;

  // Convert the pixel points back to LatLng
  var ne = projection.fromDivPixelToLatLng(trPix);
  var sw = projection.fromDivPixelToLatLng(blPix);

  // Extend the bounds to contain the new bounds.
  bounds.extend(ne);
  bounds.extend(sw);

  return bounds;
};


/**
 * Determins if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 * @private
 */
MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
  return bounds.contains(marker.getPosition());
};


/**
 * Clears all clusters and markers from the clusterer.
 */
MarkerClusterer.prototype.clearMarkers = function() {
  this.resetViewport(true);

  // Set the markers a empty array.
  this.markers_ = [];
};


/**
 * Clears all existing clusters and recreates them.
 * @param {boolean} opt_hide To also hide the marker.
 */
MarkerClusterer.prototype.resetViewport = function(opt_hide) {
  // Remove all the clusters
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    cluster.remove();
  }

  // Reset the markers to not be added and to be invisible.
  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    marker.isAdded = false;
    if (opt_hide) {
      marker.setMap(null);
    }
  }

  this.clusters_ = [];
};

/**
 *
 */
MarkerClusterer.prototype.repaint = function() {
  var oldClusters = this.clusters_.slice();
  this.clusters_.length = 0;
  this.resetViewport();
  this.redraw();

  // Remove the old clusters.
  // Do it in a timeout so the other clusters have been drawn first.
  window.setTimeout(function() {
    for (var i = 0, cluster; cluster = oldClusters[i]; i++) {
      cluster.remove();
    }
  }, 0);
};


/**
 * Redraws the clusters.
 */
MarkerClusterer.prototype.redraw = function() {
  this.createClusters_();
};


/**
 * Calculates the distance between two latlng locations in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @private
*/
MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
  if (!p1 || !p2) {
    return 0;
  }

  var R = 6371; // Radius of the Earth in km
  var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;
  var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;
  var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
};


/**
 * Add a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @private
 */
MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
  var distance = 40000; // Some large number
  var clusterToAddTo = null;
  var pos = marker.getPosition();
  for (var i = 0, cluster; cluster = this.clusters_[i]; i++) {
    var center = cluster.getCenter();
    if (center) {
      var d = this.distanceBetweenPoints_(center, marker.getPosition());
      if (d < distance) {
        distance = d;
        clusterToAddTo = cluster;
      }
    }
  }

  if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
    clusterToAddTo.addMarker(marker);
  } else {
    var cluster = new Cluster(this);
    cluster.addMarker(marker);
    this.clusters_.push(cluster);
  }
};


/**
 * Creates the clusters.
 *
 * @private
 */
MarkerClusterer.prototype.createClusters_ = function() {
  if (!this.ready_) {
    return;
  }

  // Get our current map view bounds.
  // Create a new bounds object so we don't affect the map.
  var mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),
      this.map_.getBounds().getNorthEast());
  var bounds = this.getExtendedBounds(mapBounds);

  for (var i = 0, marker; marker = this.markers_[i]; i++) {
    if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
      this.addToClosestCluster_(marker);
    }
  }
};


/**
 * A cluster that contains markers.
 *
 * @param {MarkerClusterer} markerClusterer The markerclusterer that this
 *     cluster is associated with.
 * @constructor
 * @ignore
 */
function Cluster(markerClusterer) {
  this.markerClusterer_ = markerClusterer;
  this.map_ = markerClusterer.getMap();
  this.gridSize_ = markerClusterer.getGridSize();
  this.minClusterSize_ = markerClusterer.getMinClusterSize();
  this.averageCenter_ = markerClusterer.isAverageCenter();
  this.center_ = null;
  this.markers_ = [];
  this.bounds_ = null;
  this.clusterIcon_ = new ClusterIcon(this, markerClusterer.getStyles(),
      markerClusterer.getGridSize());
}

/**
 * Determins if a marker is already added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker is already added.
 */
Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
  if (this.markers_.indexOf) {
    return this.markers_.indexOf(marker) != -1;
  } else {
    for (var i = 0, m; m = this.markers_[i]; i++) {
      if (m == marker) {
        return true;
      }
    }
  }
  return false;
};


/**
 * Add a marker the cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @return {boolean} True if the marker was added.
 */
Cluster.prototype.addMarker = function(marker) {
  if (this.isMarkerAlreadyAdded(marker)) {
    return false;
  }

  if (!this.center_) {
    this.center_ = marker.getPosition();
    this.calculateBounds_();
  } else {
    if (this.averageCenter_) {
      var l = this.markers_.length + 1;
      var lat = (this.center_.lat() * (l-1) + marker.getPosition().lat()) / l;
      var lng = (this.center_.lng() * (l-1) + marker.getPosition().lng()) / l;
      this.center_ = new google.maps.LatLng(lat, lng);
      this.calculateBounds_();
    }
  }

  marker.isAdded = true;
  this.markers_.push(marker);

  var len = this.markers_.length;
  if (len < this.minClusterSize_ && marker.getMap() != this.map_) {
    // Min cluster size not reached so show the marker.
    marker.setMap(this.map_);
  }

  if (len == this.minClusterSize_) {
    // Hide the markers that were showing.
    for (var i = 0; i < len; i++) {
      this.markers_[i].setMap(null);
    }
  }

  if (len >= this.minClusterSize_) {
    marker.setMap(null);
  }

  this.updateIcon();
  return true;
};


/**
 * Returns the marker clusterer that the cluster is associated with.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 */
Cluster.prototype.getMarkerClusterer = function() {
  return this.markerClusterer_;
};


/**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 */
Cluster.prototype.getBounds = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  var markers = this.getMarkers();
  for (var i = 0, marker; marker = markers[i]; i++) {
    bounds.extend(marker.getPosition());
  }
  return bounds;
};


/**
 * Removes the cluster
 */
Cluster.prototype.remove = function() {
  this.clusterIcon_.remove();
  this.markers_.length = 0;
  delete this.markers_;
};


/**
 * Returns the number of markers in the cluster.
 *
 * @return {number} The number of markers in the cluster.
 */
Cluster.prototype.getSize = function() {
  return this.markers_.length;
};


/**
 * Returns a list of the markers in the cluster.
 *
 * @return {Array.<google.maps.Marker>} The markers in the cluster.
 */
Cluster.prototype.getMarkers = function() {
  return this.markers_;
};


/**
 * Returns the center of the cluster.
 *
 * @return {google.maps.LatLng} The cluster center.
 */
Cluster.prototype.getCenter = function() {
  return this.center_;
};


/**
 * Calculated the extended bounds of the cluster with the grid.
 *
 * @private
 */
Cluster.prototype.calculateBounds_ = function() {
  var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
  this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
};


/**
 * Determines if a marker lies in the clusters bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 */
Cluster.prototype.isMarkerInClusterBounds = function(marker) {
  return this.bounds_.contains(marker.getPosition());
};


/**
 * Returns the map that the cluster is associated with.
 *
 * @return {google.maps.Map} The map.
 */
Cluster.prototype.getMap = function() {
  return this.map_;
};


/**
 * Updates the cluster icon
 */
Cluster.prototype.updateIcon = function() {
  var zoom = this.map_.getZoom();
  var mz = this.markerClusterer_.getMaxZoom();

  if (mz && zoom > mz) {
    // The zoom is greater than our max zoom so show all the markers in cluster.
    for (var i = 0, marker; marker = this.markers_[i]; i++) {
      marker.setMap(this.map_);
    }
    return;
  }

  if (this.markers_.length < this.minClusterSize_) {
    // Min cluster size not yet reached.
    this.clusterIcon_.hide();
    return;
  }

  var numStyles = this.markerClusterer_.getStyles().length;
  var sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
  this.clusterIcon_.setCenter(this.center_);
  this.clusterIcon_.setSums(sums);
  this.clusterIcon_.show();
};


/**
 * A cluster icon
 *
 * @param {Cluster} cluster The cluster to be associated with.
 * @param {Object} styles An object that has style properties:
 *     'url': (string) The image url.
 *     'height': (number) The image height.
 *     'width': (number) The image width.
 *     'anchor': (Array) The anchor position of the label text.
 *     'textColor': (string) The text color.
 *     'textSize': (number) The text size.
 *     'backgroundPosition: (string) The background postition x, y.
 * @param {number=} opt_padding Optional padding to apply to the cluster icon.
 * @constructor
 * @extends google.maps.OverlayView
 * @ignore
 */
function ClusterIcon(cluster, styles, opt_padding) {
  cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);

  this.styles_ = styles;
  this.padding_ = opt_padding || 0;
  this.cluster_ = cluster;
  this.center_ = null;
  this.map_ = cluster.getMap();
  this.div_ = null;
  this.sums_ = null;
  this.visible_ = false;

  this.setMap(this.map_);
}


/**
 * Triggers the clusterclick event and zoom's if the option is set.
 */
ClusterIcon.prototype.triggerClusterClick = function() {
  var markerClusterer = this.cluster_.getMarkerClusterer();

  // Trigger the clusterclick event.
  google.maps.event.trigger(markerClusterer.map_, 'clusterclick', this.cluster_);

  if (markerClusterer.isZoomOnClick()) {
    // Zoom into the cluster.
    this.map_.fitBounds(this.cluster_.getBounds());
  }
};


/**
 * Adding the cluster icon to the dom.
 * @ignore
 */
ClusterIcon.prototype.onAdd = function() {
  this.div_ = document.createElement('DIV');
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.innerHTML = this.sums_.text;
  }

  var panes = this.getPanes();
  panes.overlayMouseTarget.appendChild(this.div_);

  var that = this;
  google.maps.event.addDomListener(this.div_, 'click', function() {
    that.triggerClusterClick();
  });
};


/**
 * Returns the position to place the div dending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 * @private
 */
ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
  var pos = this.getProjection().fromLatLngToDivPixel(latlng);
  pos.x -= parseInt(this.width_ / 2, 10);
  pos.y -= parseInt(this.height_ / 2, 10);
  return pos;
};


/**
 * Draw the icon.
 * @ignore
 */
ClusterIcon.prototype.draw = function() {
  if (this.visible_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.top = pos.y + 'px';
    this.div_.style.left = pos.x + 'px';
    this.div_.style.zIndex = google.maps.Marker.MAX_ZINDEX + 1;
  }
};


/**
 * Hide the icon.
 */
ClusterIcon.prototype.hide = function() {
  if (this.div_) {
    this.div_.style.display = 'none';
  }
  this.visible_ = false;
};


/**
 * Position and show the icon.
 */
ClusterIcon.prototype.show = function() {
  if (this.div_) {
    var pos = this.getPosFromLatLng_(this.center_);
    this.div_.style.cssText = this.createCss(pos);
    this.div_.style.display = '';
  }
  this.visible_ = true;
};


/**
 * Remove the icon from the map
 */
ClusterIcon.prototype.remove = function() {
  this.setMap(null);
};


/**
 * Implementation of the onRemove interface.
 * @ignore
 */
ClusterIcon.prototype.onRemove = function() {
  if (this.div_ && this.div_.parentNode) {
    this.hide();
    this.div_.parentNode.removeChild(this.div_);
    this.div_ = null;
  }
};


/**
 * Set the sums of the icon.
 *
 * @param {Object} sums The sums containing:
 *   'text': (string) The text to display in the icon.
 *   'index': (number) The style index of the icon.
 */
ClusterIcon.prototype.setSums = function(sums) {
  this.sums_ = sums;
  this.text_ = sums.text;
  this.index_ = sums.index;
  if (this.div_) {
    this.div_.innerHTML = sums.text;
  }

  this.useStyle();
};


/**
 * Sets the icon to the the styles.
 */
ClusterIcon.prototype.useStyle = function() {
  var index = Math.max(0, this.sums_.index - 1);
  index = Math.min(this.styles_.length - 1, index);
  var style = this.styles_[index];
  this.url_ = style['url'];
  this.height_ = style['height'];
  this.width_ = style['width'];
  this.textColor_ = style['textColor'];
  this.anchor_ = style['anchor'];
  this.textSize_ = style['textSize'];
  this.backgroundPosition_ = style['backgroundPosition'];
};


/**
 * Sets the center of the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
ClusterIcon.prototype.setCenter = function(center) {
  this.center_ = center;
};


/**
 * Create the css text based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position.
 * @return {string} The css style text.
 */
ClusterIcon.prototype.createCss = function(pos) {
  var style = [];
  style.push('background-image:url(' + this.url_ + ');');
  var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : '0 0';
  style.push('background-position:' + backgroundPosition + ';');

  if (typeof this.anchor_ === 'object') {
    if (typeof this.anchor_[0] === 'number' && this.anchor_[0] > 0 &&
        this.anchor_[0] < this.height_) {
      style.push('height:' + (this.height_ - this.anchor_[0]) +
          'px; padding-top:' + this.anchor_[0] + 'px;');
    } else {
      style.push('height:' + this.height_ + 'px; line-height:' + this.height_ +
          'px;');
    }
    if (typeof this.anchor_[1] === 'number' && this.anchor_[1] > 0 &&
        this.anchor_[1] < this.width_) {
      style.push('width:' + (this.width_ - this.anchor_[1]) +
          'px; padding-left:' + this.anchor_[1] + 'px;');
    } else {
      style.push('width:' + this.width_ + 'px; text-align:center;');
    }
  } else {
    style.push('height:' + this.height_ + 'px; line-height:' +
        this.height_ + 'px; width:' + this.width_ + 'px; text-align:center;');
  }

  var txtColor = this.textColor_ ? this.textColor_ : 'black';
  var txtSize = this.textSize_ ? this.textSize_ : 11;

  style.push('cursor:pointer; top:' + pos.y + 'px; left:' +
      pos.x + 'px; color:' + txtColor + '; position:absolute; font-size:' +
      txtSize + 'px; font-family:Arial,sans-serif; font-weight:bold');
  return style.join('');
};


// Export Symbols for Closure
// If you are not going to compile with closure then you can remove the
// code below.
var window = window || {};
window['MarkerClusterer'] = MarkerClusterer;
MarkerClusterer.prototype['addMarker'] = MarkerClusterer.prototype.addMarker;
MarkerClusterer.prototype['addMarkers'] = MarkerClusterer.prototype.addMarkers;
MarkerClusterer.prototype['clearMarkers'] =
    MarkerClusterer.prototype.clearMarkers;
MarkerClusterer.prototype['fitMapToMarkers'] =
    MarkerClusterer.prototype.fitMapToMarkers;
MarkerClusterer.prototype['getCalculator'] =
    MarkerClusterer.prototype.getCalculator;
MarkerClusterer.prototype['getGridSize'] =
    MarkerClusterer.prototype.getGridSize;
MarkerClusterer.prototype['getExtendedBounds'] =
    MarkerClusterer.prototype.getExtendedBounds;
MarkerClusterer.prototype['getMap'] = MarkerClusterer.prototype.getMap;
MarkerClusterer.prototype['getMarkers'] = MarkerClusterer.prototype.getMarkers;
MarkerClusterer.prototype['getMaxZoom'] = MarkerClusterer.prototype.getMaxZoom;
MarkerClusterer.prototype['getStyles'] = MarkerClusterer.prototype.getStyles;
MarkerClusterer.prototype['getTotalClusters'] =
    MarkerClusterer.prototype.getTotalClusters;
MarkerClusterer.prototype['getTotalMarkers'] =
    MarkerClusterer.prototype.getTotalMarkers;
MarkerClusterer.prototype['redraw'] = MarkerClusterer.prototype.redraw;
MarkerClusterer.prototype['removeMarker'] =
    MarkerClusterer.prototype.removeMarker;
MarkerClusterer.prototype['removeMarkers'] =
    MarkerClusterer.prototype.removeMarkers;
MarkerClusterer.prototype['resetViewport'] =
    MarkerClusterer.prototype.resetViewport;
MarkerClusterer.prototype['repaint'] =
    MarkerClusterer.prototype.repaint;
MarkerClusterer.prototype['setCalculator'] =
    MarkerClusterer.prototype.setCalculator;
MarkerClusterer.prototype['setGridSize'] =
    MarkerClusterer.prototype.setGridSize;
MarkerClusterer.prototype['setMaxZoom'] =
    MarkerClusterer.prototype.setMaxZoom;
MarkerClusterer.prototype['onAdd'] = MarkerClusterer.prototype.onAdd;
MarkerClusterer.prototype['draw'] = MarkerClusterer.prototype.draw;

Cluster.prototype['getCenter'] = Cluster.prototype.getCenter;
Cluster.prototype['getSize'] = Cluster.prototype.getSize;
Cluster.prototype['getMarkers'] = Cluster.prototype.getMarkers;

ClusterIcon.prototype['onAdd'] = ClusterIcon.prototype.onAdd;
ClusterIcon.prototype['draw'] = ClusterIcon.prototype.draw;
ClusterIcon.prototype['onRemove'] = ClusterIcon.prototype.onRemove;

Object.keys = Object.keys || function(o) {
    var result = [];
    for(var name in o) {
        if (o.hasOwnProperty(name))
          result.push(name);
    }
    return result;
};

if (true) {
  module.exports = MarkerClusterer;
}


/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stylesInDom = {};

var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

function listToStyles(list, options) {
  var styles = [];
  var newStyles = {};

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      css: css,
      media: media,
      sourceMap: sourceMap
    };

    if (!newStyles[id]) {
      styles.push(newStyles[id] = {
        id: id,
        parts: [part]
      });
    } else {
      newStyles[id].parts.push(part);
    }
  }

  return styles;
}

function addStylesToDom(styles, options) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i];
    var domStyle = stylesInDom[item.id];
    var j = 0;

    if (domStyle) {
      domStyle.refs++;

      for (; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j]);
      }

      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j], options));
      }
    } else {
      var parts = [];

      for (; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j], options));
      }

      stylesInDom[item.id] = {
        id: item.id,
        refs: 1,
        parts: parts
      };
    }
  }
}

function insertStyleElement(options) {
  var style = document.createElement('style');

  if (typeof options.attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      options.attributes.nonce = nonce;
    }
  }

  Object.keys(options.attributes).forEach(function (key) {
    style.setAttribute(key, options.attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {};
  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  var styles = listToStyles(list, options);
  addStylesToDom(styles, options);
  return function update(newList) {
    var mayRemove = [];

    for (var i = 0; i < styles.length; i++) {
      var item = styles[i];
      var domStyle = stylesInDom[item.id];

      if (domStyle) {
        domStyle.refs--;
        mayRemove.push(domStyle);
      }
    }

    if (newList) {
      var newStyles = listToStyles(newList, options);
      addStylesToDom(newStyles, options);
    }

    for (var _i = 0; _i < mayRemove.length; _i++) {
      var _domStyle = mayRemove[_i];

      if (_domStyle.refs === 0) {
        for (var j = 0; j < _domStyle.parts.length; j++) {
          _domStyle.parts[j]();
        }

        delete stylesInDom[_domStyle.id];
      }
    }
  };
};

/***/ }),

/***/ "./dist/css/main.css":
/*!***************************!*\
  !*** ./dist/css/main.css ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../node_modules/css-loader!./main.css */ "./node_modules/css-loader/index.js!./dist/css/main.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "./node_modules/css-loader/index.js!./dist/css/main.css":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader!./dist/css/main.css ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".dynaTree{\n  border:1px solid red;\n}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css":
/*!********************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(/*! ../../../css-loader/lib/url/escape.js */ "./node_modules/css-loader/lib/url/escape.js");
exports = module.exports = __webpack_require__(/*! ../../../css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*!\n * Fancytree \"awesome\" skin.\n *\n * DON'T EDIT THE CSS FILE DIRECTLY, since it is automatically generated from\n * the LESS templates.\n */.fancytree-helper-hidden{display:none}.fancytree-helper-indeterminate-cb{color:#777}.fancytree-helper-disabled{color:silver}.fancytree-helper-spin{-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}ul.fancytree-container{font-family:tahoma,arial,helvetica;font-size:10pt;white-space:nowrap;padding:3px;margin:0;background-color:#fff;border:1px dotted gray;min-height:0;position:relative}ul.fancytree-container ul{padding:0 0 0 10pt;margin:0}ul.fancytree-container ul>li:before{content:none}ul.fancytree-container li{list-style-image:none;list-style-position:outside;list-style-type:none;-moz-background-clip:border;-moz-background-inline-policy:continuous;-moz-background-origin:padding;background-attachment:scroll;background-color:transparent;background-position:0 0;background-repeat:repeat-y;background-image:none;margin:0}ul.fancytree-container li.fancytree-lastsib{background-image:none}.ui-fancytree-disabled ul.fancytree-container{opacity:.5;background-color:silver}ul.fancytree-connectors.fancytree-container li{background-image:url(" + escape(__webpack_require__(/*! ../skin-awesome/vline.gif */ "./node_modules/jquery.fancytree/dist/skin-awesome/vline.gif")) + ");background-position:0 0}ul.fancytree-container li.fancytree-lastsib,ul.fancytree-no-connector>li{background-image:none}li.fancytree-animating{position:relative}#fancytree-drop-marker,span.fancytree-checkbox,span.fancytree-drag-helper-img,span.fancytree-empty,span.fancytree-expander,span.fancytree-icon,span.fancytree-vline{width:10pt;height:10pt;display:inline-block;vertical-align:top;background-repeat:no-repeat;background-position:0 0}span.fancytree-checkbox,span.fancytree-custom-icon,span.fancytree-expander,span.fancytree-icon{margin-top:0}span.fancytree-custom-icon{width:10pt;height:10pt;display:inline-block;margin-left:3px;background-position:0 0}img.fancytree-icon{width:10pt;height:10pt;margin-left:3px;margin-top:0;vertical-align:top;border-style:none}span.fancytree-expander{cursor:pointer}.fancytree-exp-n span.fancytree-expander,.fancytree-exp-nl span.fancytree-expander{background-image:none;cursor:default}.fancytree-connectors .fancytree-exp-n span.fancytree-expander,.fancytree-connectors .fancytree-exp-nl span.fancytree-expander{margin-top:0}.fancytree-fade-expander span.fancytree-expander{transition:opacity 1.5s;opacity:0}.fancytree-fade-expander .fancytree-treefocus span.fancytree-expander,.fancytree-fade-expander [class*=fancytree-statusnode-] span.fancytree-expander,.fancytree-fade-expander.fancytree-treefocus span.fancytree-expander,.fancytree-fade-expander:hover span.fancytree-expander{transition:opacity .6s;opacity:1}span.fancytree-checkbox{margin-left:3px}.fancytree-unselectable span.fancytree-checkbox{opacity:.4}.fancytree-container.fancytree-checkbox-auto-hide span.fancytree-checkbox{visibility:hidden}.fancytree-container.fancytree-checkbox-auto-hide .fancytree-node.fancytree-selected span.fancytree-checkbox,.fancytree-container.fancytree-checkbox-auto-hide .fancytree-node:hover span.fancytree-checkbox,.fancytree-container.fancytree-checkbox-auto-hide tr.fancytree-selected td span.fancytree-checkbox,.fancytree-container.fancytree-checkbox-auto-hide tr:hover td span.fancytree-checkbox{visibility:unset}.fancytree-container.fancytree-checkbox-auto-hide.fancytree-treefocus .fancytree-node.fancytree-active span.fancytree-checkbox,.fancytree-container.fancytree-checkbox-auto-hide.fancytree-treefocus tr.fancytree-active td span.fancytree-checkbox{visibility:unset}span.fancytree-icon{margin-left:3px}.fancytree-loading span.fancytree-expander,.fancytree-loading span.fancytree-expander:hover,.fancytree-statusnode-loading span.fancytree-icon,.fancytree-statusnode-loading span.fancytree-icon:hover,span.fancytree-icon.fancytree-icon-loading{background-image:none}span.fancytree-node{display:inherit;width:100%;margin-top:1px;min-height:10pt}span.fancytree-title{color:#000;cursor:pointer;display:inline-block;vertical-align:top;min-height:10pt;padding:0 3px 0 3px;margin:0 0 0 3px;border:1px solid transparent;-webkit-border-radius:0;-moz-border-radius:0;-ms-border-radius:0;-o-border-radius:0;border-radius:0}span.fancytree-node.fancytree-error span.fancytree-title{color:red}span.fancytree-childcounter{color:#fff;background:#337ab7;border:1px solid gray;border-radius:10px;padding:2px;text-align:center}div.fancytree-drag-helper span.fancytree-childcounter,div.fancytree-drag-helper span.fancytree-dnd-modifier{display:inline-block;color:#fff;background:#337ab7;border:1px solid gray;min-width:10px;height:10px;line-height:1;vertical-align:baseline;border-radius:10px;padding:2px;text-align:center;font-size:9px}div.fancytree-drag-helper span.fancytree-childcounter{position:absolute;top:-6px;right:-6px}div.fancytree-drag-helper span.fancytree-dnd-modifier{background:#5cb85c;border:none;font-weight:bolder}#fancytree-drop-marker{width:20pt;position:absolute;margin:0}#fancytree-drop-marker.fancytree-drop-after,#fancytree-drop-marker.fancytree-drop-before{width:40pt}span.fancytree-drag-source.fancytree-drag-remove{opacity:.15}.fancytree-container.fancytree-rtl .fancytree-exp-n span.fancytree-expander,.fancytree-container.fancytree-rtl .fancytree-exp-nl span.fancytree-expander{background-image:none}ul.fancytree-container.fancytree-rtl ul{padding:0 16px 0 0}ul.fancytree-container.fancytree-rtl.fancytree-connectors li{background-position:right 0;background-image:url(" + escape(__webpack_require__(/*! ../skin-awesome/vline-rtl.gif */ "./node_modules/jquery.fancytree/dist/skin-awesome/vline-rtl.gif")) + ")}ul.fancytree-container.fancytree-rtl li.fancytree-lastsib,ul.fancytree-container.fancytree-rtl.fancytree-no-connector>li{background-image:none}table.fancytree-ext-table{font-family:tahoma,arial,helvetica;font-size:10pt;border-collapse:collapse}table.fancytree-ext-table span.fancytree-node{display:inline-block;box-sizing:border-box}table.fancytree-ext-table td.fancytree-status-merged{text-align:center;font-style:italic;color:silver}table.fancytree-ext-table tr.fancytree-statusnode-error td.fancytree-status-merged{color:red}table.fancytree-ext-table.fancytree-ext-ariagrid.fancytree-cell-mode>tbody>tr.fancytree-active>td{background-color:#eee}table.fancytree-ext-table.fancytree-ext-ariagrid.fancytree-cell-mode>tbody>tr>td.fancytree-active-cell{background-color:#cbe8f6}table.fancytree-ext-table.fancytree-ext-ariagrid.fancytree-cell-mode.fancytree-cell-nav-mode>tbody>tr>td.fancytree-active-cell{background-color:#3875d7}table.fancytree-ext-columnview tbody tr td{position:relative;border:1px solid gray;vertical-align:top;overflow:auto}table.fancytree-ext-columnview tbody tr td>ul{padding:0}table.fancytree-ext-columnview tbody tr td>ul li{list-style-image:none;list-style-position:outside;list-style-type:none;-moz-background-clip:border;-moz-background-inline-policy:continuous;-moz-background-origin:padding;background-attachment:scroll;background-color:transparent;background-position:0 0;background-repeat:repeat-y;background-image:none;margin:0}table.fancytree-ext-columnview span.fancytree-node{position:relative;display:inline-block}table.fancytree-ext-columnview span.fancytree-node.fancytree-expanded{background-color:#e0e0e0}table.fancytree-ext-columnview span.fancytree-node.fancytree-active{background-color:#cbe8f6}table.fancytree-ext-columnview .fancytree-has-children span.fancytree-cv-right{position:absolute;right:3px}.fancytree-ext-filter-dimm span.fancytree-node span.fancytree-title{color:silver;font-weight:lighter}.fancytree-ext-filter-dimm span.fancytree-node.fancytree-submatch span.fancytree-title,.fancytree-ext-filter-dimm tr.fancytree-submatch span.fancytree-title{color:#000;font-weight:400}.fancytree-ext-filter-dimm span.fancytree-node.fancytree-match span.fancytree-title,.fancytree-ext-filter-dimm tr.fancytree-match span.fancytree-title{color:#000;font-weight:700}.fancytree-ext-filter-hide span.fancytree-node.fancytree-hide,.fancytree-ext-filter-hide tr.fancytree-hide{display:none}.fancytree-ext-filter-hide span.fancytree-node.fancytree-submatch span.fancytree-title,.fancytree-ext-filter-hide tr.fancytree-submatch span.fancytree-title{color:silver;font-weight:lighter}.fancytree-ext-filter-hide span.fancytree-node.fancytree-match span.fancytree-title,.fancytree-ext-filter-hide tr.fancytree-match span.fancytree-title{color:#000;font-weight:400}.fancytree-ext-filter-hide-expanders span.fancytree-node.fancytree-match span.fancytree-expander,.fancytree-ext-filter-hide-expanders tr.fancytree-match span.fancytree-expander{visibility:hidden}.fancytree-ext-filter-hide-expanders span.fancytree-node.fancytree-submatch span.fancytree-expander,.fancytree-ext-filter-hide-expanders tr.fancytree-submatch span.fancytree-expander{visibility:visible}.fancytree-ext-childcounter span.fancytree-custom-icon,.fancytree-ext-childcounter span.fancytree-icon,.fancytree-ext-filter span.fancytree-custom-icon,.fancytree-ext-filter span.fancytree-icon{position:relative}.fancytree-ext-childcounter span.fancytree-childcounter,.fancytree-ext-filter span.fancytree-childcounter{color:#fff;background:#777;border:1px solid gray;position:absolute;top:-6px;right:-6px;min-width:10px;height:10px;line-height:1;vertical-align:baseline;border-radius:10px;padding:2px;text-align:center;font-size:9px}ul.fancytree-ext-wide{position:relative;min-width:100%;z-index:2;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}ul.fancytree-ext-wide span.fancytree-node>span{position:relative;z-index:2}ul.fancytree-ext-wide span.fancytree-node span.fancytree-title{position:absolute;z-index:1;left:0;min-width:100%;margin-left:0;margin-right:0;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.fancytree-ext-fixed-wrapper .fancytree-ext-fixed-hidden{display:none}.fancytree-ext-fixed-wrapper div.fancytree-ext-fixed-scroll-border-bottom{border-bottom:3px solid rgba(0,0,0,.75)}.fancytree-ext-fixed-wrapper div.fancytree-ext-fixed-scroll-border-right{border-right:3px solid rgba(0,0,0,.75)}.fancytree-ext-fixed-wrapper div.fancytree-ext-fixed-wrapper-tl{position:absolute;overflow:hidden;z-index:3;top:0;left:0}.fancytree-ext-fixed-wrapper div.fancytree-ext-fixed-wrapper-tr{position:absolute;overflow:hidden;z-index:2;top:0}.fancytree-ext-fixed-wrapper div.fancytree-ext-fixed-wrapper-bl{position:absolute;overflow:hidden;z-index:2;left:0}.fancytree-ext-fixed-wrapper div.fancytree-ext-fixed-wrapper-br{position:absolute;overflow:scroll;z-index:1}ul.fancytree-container ul{padding:.3em 0 0 1em;margin:0}span.fancytree-title{border:1px solid transparent;border-radius:0}span.fancytree-focused span.fancytree-title{outline:1px dotted #000}span.fancytree-active span.fancytree-title{background-color:#d4d4d4}.fancytree-treefocus span.fancytree-active span.fancytree-title{color:#fff;background-color:#3875d7}table.fancytree-ext-table{border-collapse:collapse}table.fancytree-ext-table tbody tr.fancytree-focused{background-color:#99defd}table.fancytree-ext-table tbody tr.fancytree-active{background-color:#4169e1}table.fancytree-ext-columnview tbody tr td{border:1px solid gray}table.fancytree-ext-columnview span.fancytree-node.fancytree-expanded{background-color:#ccc}table.fancytree-ext-columnview span.fancytree-node.fancytree-active{background-color:#4169e1}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/css-loader/lib/url/escape.js":
/*!***************************************************!*\
  !*** ./node_modules/css-loader/lib/url/escape.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function escape(url) {
    if (typeof url !== 'string') {
        return url
    }
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'
    }

    return url
}


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.edit.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.edit.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jquery.fancytree.edit.js
 *
 * Make node titles editable.
 * (Extension module for jquery.fancytree.js: https://github.com/mar10/fancytree/)
 *
 * Copyright (c) 2008-2019, Martin Wendt (https://wwWendt.de)
 *
 * Released under the MIT license
 * https://github.com/mar10/fancytree/wiki/LicenseInfo
 *
 * @version 2.33.0
 * @date 2019-10-29T08:00:07Z
 */

(function(factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./jquery.fancytree */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(function($) {
	"use strict";

	/*******************************************************************************
	 * Private functions and variables
	 */

	var isMac = /Mac/.test(navigator.platform),
		escapeHtml = $.ui.fancytree.escapeHtml,
		unescapeHtml = $.ui.fancytree.unescapeHtml;

	/**
	 * [ext-edit] Start inline editing of current node title.
	 *
	 * @alias FancytreeNode#editStart
	 * @requires Fancytree
	 */
	$.ui.fancytree._FancytreeNodeClass.prototype.editStart = function() {
		var $input,
			node = this,
			tree = this.tree,
			local = tree.ext.edit,
			instOpts = tree.options.edit,
			$title = $(".fancytree-title", node.span),
			eventData = {
				node: node,
				tree: tree,
				options: tree.options,
				isNew: $(node[tree.statusClassPropName]).hasClass(
					"fancytree-edit-new"
				),
				orgTitle: node.title,
				input: null,
				dirty: false,
			};

		// beforeEdit may want to modify the title before editing
		if (
			instOpts.beforeEdit.call(
				node,
				{ type: "beforeEdit" },
				eventData
			) === false
		) {
			return false;
		}
		$.ui.fancytree.assert(!local.currentNode, "recursive edit");
		local.currentNode = this;
		local.eventData = eventData;

		// Disable standard Fancytree mouse- and key handling
		tree.widget._unbind();

		local.lastDraggableAttrValue = node.span.draggable;
		if (local.lastDraggableAttrValue) {
			node.span.draggable = false;
		}

		// #116: ext-dnd prevents the blur event, so we have to catch outer clicks
		$(document).on("mousedown.fancytree-edit", function(event) {
			if (!$(event.target).hasClass("fancytree-edit-input")) {
				node.editEnd(true, event);
			}
		});

		// Replace node with <input>
		$input = $("<input />", {
			class: "fancytree-edit-input",
			type: "text",
			value: tree.options.escapeTitles
				? eventData.orgTitle
				: unescapeHtml(eventData.orgTitle),
		});
		local.eventData.input = $input;
		if (instOpts.adjustWidthOfs != null) {
			$input.width($title.width() + instOpts.adjustWidthOfs);
		}
		if (instOpts.inputCss != null) {
			$input.css(instOpts.inputCss);
		}

		$title.html($input);

		// Focus <input> and bind keyboard handler
		$input
			.focus()
			.change(function(event) {
				$input.addClass("fancytree-edit-dirty");
			})
			.on("keydown", function(event) {
				switch (event.which) {
					case $.ui.keyCode.ESCAPE:
						node.editEnd(false, event);
						break;
					case $.ui.keyCode.ENTER:
						node.editEnd(true, event);
						return false; // so we don't start editmode on Mac
				}
				event.stopPropagation();
			})
			.blur(function(event) {
				return node.editEnd(true, event);
			});

		instOpts.edit.call(node, { type: "edit" }, eventData);
	};

	/**
	 * [ext-edit] Stop inline editing.
	 * @param {Boolean} [applyChanges=false] false: cancel edit, true: save (if modified)
	 * @alias FancytreeNode#editEnd
	 * @requires jquery.fancytree.edit.js
	 */
	$.ui.fancytree._FancytreeNodeClass.prototype.editEnd = function(
		applyChanges,
		_event
	) {
		var newVal,
			node = this,
			tree = this.tree,
			local = tree.ext.edit,
			eventData = local.eventData,
			instOpts = tree.options.edit,
			$title = $(".fancytree-title", node.span),
			$input = $title.find("input.fancytree-edit-input");

		if (instOpts.trim) {
			$input.val($.trim($input.val()));
		}
		newVal = $input.val();

		eventData.dirty = newVal !== node.title;
		eventData.originalEvent = _event;

		// Find out, if saving is required
		if (applyChanges === false) {
			// If true/false was passed, honor this (except in rename mode, if unchanged)
			eventData.save = false;
		} else if (eventData.isNew) {
			// In create mode, we save everything, except for empty text
			eventData.save = newVal !== "";
		} else {
			// In rename mode, we save everyting, except for empty or unchanged text
			eventData.save = eventData.dirty && newVal !== "";
		}
		// Allow to break (keep editor open), modify input, or re-define data.save
		if (
			instOpts.beforeClose.call(
				node,
				{ type: "beforeClose" },
				eventData
			) === false
		) {
			return false;
		}
		if (
			eventData.save &&
			instOpts.save.call(node, { type: "save" }, eventData) === false
		) {
			return false;
		}
		$input.removeClass("fancytree-edit-dirty").off();
		// Unbind outer-click handler
		$(document).off(".fancytree-edit");

		if (eventData.save) {
			// # 171: escape user input (not required if global escaping is on)
			node.setTitle(
				tree.options.escapeTitles ? newVal : escapeHtml(newVal)
			);
			node.setFocus();
		} else {
			if (eventData.isNew) {
				node.remove();
				node = eventData.node = null;
				local.relatedNode.setFocus();
			} else {
				node.renderTitle();
				node.setFocus();
			}
		}
		local.eventData = null;
		local.currentNode = null;
		local.relatedNode = null;
		// Re-enable mouse and keyboard handling
		tree.widget._bind();

		if (local.lastDraggableAttrValue) {
			node.span.draggable = true;
		}

		// Set keyboard focus, even if setFocus() claims 'nothing to do'
		$(tree.$container).focus();
		eventData.input = null;
		instOpts.close.call(node, { type: "close" }, eventData);
		return true;
	};

	/**
	 * [ext-edit] Create a new child or sibling node and start edit mode.
	 *
	 * @param {String} [mode='child'] 'before', 'after', or 'child'
	 * @param {Object} [init] NodeData (or simple title string)
	 * @alias FancytreeNode#editCreateNode
	 * @requires jquery.fancytree.edit.js
	 * @since 2.4
	 */
	$.ui.fancytree._FancytreeNodeClass.prototype.editCreateNode = function(
		mode,
		init
	) {
		var newNode,
			tree = this.tree,
			self = this;

		mode = mode || "child";
		if (init == null) {
			init = { title: "" };
		} else if (typeof init === "string") {
			init = { title: init };
		} else {
			$.ui.fancytree.assert($.isPlainObject(init));
		}
		// Make sure node is expanded (and loaded) in 'child' mode
		if (
			mode === "child" &&
			!this.isExpanded() &&
			this.hasChildren() !== false
		) {
			this.setExpanded().done(function() {
				self.editCreateNode(mode, init);
			});
			return;
		}
		newNode = this.addNode(init, mode);

		// #644: Don't filter new nodes.
		newNode.match = true;
		$(newNode[tree.statusClassPropName])
			.removeClass("fancytree-hide")
			.addClass("fancytree-match");

		newNode.makeVisible(/*{noAnimation: true}*/).done(function() {
			$(newNode[tree.statusClassPropName]).addClass("fancytree-edit-new");
			self.tree.ext.edit.relatedNode = self;
			newNode.editStart();
		});
	};

	/**
	 * [ext-edit] Check if any node in this tree  in edit mode.
	 *
	 * @returns {FancytreeNode | null}
	 * @alias Fancytree#isEditing
	 * @requires jquery.fancytree.edit.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.isEditing = function() {
		return this.ext.edit ? this.ext.edit.currentNode : null;
	};

	/**
	 * [ext-edit] Check if this node is in edit mode.
	 * @returns {Boolean} true if node is currently beeing edited
	 * @alias FancytreeNode#isEditing
	 * @requires jquery.fancytree.edit.js
	 */
	$.ui.fancytree._FancytreeNodeClass.prototype.isEditing = function() {
		return this.tree.ext.edit
			? this.tree.ext.edit.currentNode === this
			: false;
	};

	/*******************************************************************************
	 * Extension code
	 */
	$.ui.fancytree.registerExtension({
		name: "edit",
		version: "2.33.0",
		// Default options for this extension.
		options: {
			adjustWidthOfs: 4, // null: don't adjust input size to content
			allowEmpty: false, // Prevent empty input
			inputCss: { minWidth: "3em" },
			// triggerCancel: ["esc", "tab", "click"],
			triggerStart: ["f2", "mac+enter", "shift+click"],
			trim: true, // Trim whitespace before save
			// Events:
			beforeClose: $.noop, // Return false to prevent cancel/save (data.input is available)
			beforeEdit: $.noop, // Return false to prevent edit mode
			close: $.noop, // Editor was removed
			edit: $.noop, // Editor was opened (available as data.input)
			//		keypress: $.noop,    // Not yet implemented
			save: $.noop, // Save data.input.val() or return false to keep editor open
		},
		// Local attributes
		currentNode: null,

		treeInit: function(ctx) {
			var tree = ctx.tree;

			this._superApply(arguments);

			this.$container
				.addClass("fancytree-ext-edit")
				.on("fancytreebeforeupdateviewport", function(event, data) {
					var editNode = tree.isEditing();
					// When scrolling, the TR may be re-used by another node, so the
					// active cell marker an
					if (editNode) {
						editNode.info("Cancel edit due to scroll event.");
						editNode.editEnd(false, event);
					}
				});
		},
		nodeClick: function(ctx) {
			var eventStr = $.ui.fancytree.eventToString(ctx.originalEvent),
				triggerStart = ctx.options.edit.triggerStart;

			if (
				eventStr === "shift+click" &&
				$.inArray("shift+click", triggerStart) >= 0
			) {
				if (ctx.originalEvent.shiftKey) {
					ctx.node.editStart();
					return false;
				}
			}
			if (
				eventStr === "click" &&
				$.inArray("clickActive", triggerStart) >= 0
			) {
				// Only when click was inside title text (not aynwhere else in the row)
				if (
					ctx.node.isActive() &&
					!ctx.node.isEditing() &&
					$(ctx.originalEvent.target).hasClass("fancytree-title")
				) {
					ctx.node.editStart();
					return false;
				}
			}
			return this._superApply(arguments);
		},
		nodeDblclick: function(ctx) {
			if ($.inArray("dblclick", ctx.options.edit.triggerStart) >= 0) {
				ctx.node.editStart();
				return false;
			}
			return this._superApply(arguments);
		},
		nodeKeydown: function(ctx) {
			switch (ctx.originalEvent.which) {
				case 113: // [F2]
					if ($.inArray("f2", ctx.options.edit.triggerStart) >= 0) {
						ctx.node.editStart();
						return false;
					}
					break;
				case $.ui.keyCode.ENTER:
					if (
						$.inArray("mac+enter", ctx.options.edit.triggerStart) >=
							0 &&
						isMac
					) {
						ctx.node.editStart();
						return false;
					}
					break;
			}
			return this._superApply(arguments);
		},
	});
	// Value returned by `require('jquery.fancytree..')`
	return $.ui.fancytree;
}); // End of closure


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.filter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.filter.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jquery.fancytree.filter.js
 *
 * Remove or highlight tree nodes, based on a filter.
 * (Extension module for jquery.fancytree.js: https://github.com/mar10/fancytree/)
 *
 * Copyright (c) 2008-2019, Martin Wendt (https://wwWendt.de)
 *
 * Released under the MIT license
 * https://github.com/mar10/fancytree/wiki/LicenseInfo
 *
 * @version 2.33.0
 * @date 2019-10-29T08:00:07Z
 */

(function(factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./jquery.fancytree */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(function($) {
	"use strict";

	/*******************************************************************************
	 * Private functions and variables
	 */

	var KeyNoData = "__not_found__",
		escapeHtml = $.ui.fancytree.escapeHtml;

	function _escapeRegex(str) {
		return (str + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
	}

	function extractHtmlText(s) {
		if (s.indexOf(">") >= 0) {
			return $("<div/>")
				.html(s)
				.text();
		}
		return s;
	}

	$.ui.fancytree._FancytreeClass.prototype._applyFilterImpl = function(
		filter,
		branchMode,
		_opts
	) {
		var match,
			statusNode,
			re,
			reHighlight,
			temp,
			prevEnableUpdate,
			count = 0,
			treeOpts = this.options,
			escapeTitles = treeOpts.escapeTitles,
			prevAutoCollapse = treeOpts.autoCollapse,
			opts = $.extend({}, treeOpts.filter, _opts),
			hideMode = opts.mode === "hide",
			leavesOnly = !!opts.leavesOnly && !branchMode;

		// Default to 'match title substring (not case sensitive)'
		if (typeof filter === "string") {
			if (filter === "") {
				this.warn(
					"Fancytree passing an empty string as a filter is handled as clearFilter()."
				);
				this.clearFilter();
				return;
			}
			if (opts.fuzzy) {
				// See https://codereview.stackexchange.com/questions/23899/faster-javascript-fuzzy-string-matching-function/23905#23905
				// and http://www.quora.com/How-is-the-fuzzy-search-algorithm-in-Sublime-Text-designed
				// and http://www.dustindiaz.com/autocomplete-fuzzy-matching
				match = filter.split("").reduce(function(a, b) {
					return a + "[^" + b + "]*" + b;
				});
			} else {
				match = _escapeRegex(filter); // make sure a '.' is treated literally
			}
			re = new RegExp(".*" + match + ".*", "i");
			reHighlight = new RegExp(_escapeRegex(filter), "gi");
			filter = function(node) {
				if (!node.title) {
					return false;
				}
				var text = escapeTitles
						? node.title
						: extractHtmlText(node.title),
					res = !!re.test(text);

				if (res && opts.highlight) {
					if (escapeTitles) {
						// #740: we must not apply the marks to escaped entity names, e.g. `&quot;`
						// Use some exotic characters to mark matches:
						temp = text.replace(reHighlight, function(s) {
							return "\uFFF7" + s + "\uFFF8";
						});
						// now we can escape the title...
						node.titleWithHighlight = escapeHtml(temp)
							// ... and finally insert the desired `<mark>` tags
							.replace(/\uFFF7/g, "<mark>")
							.replace(/\uFFF8/g, "</mark>");
					} else {
						node.titleWithHighlight = text.replace(
							reHighlight,
							function(s) {
								return "<mark>" + s + "</mark>";
							}
						);
					}
					// node.debug("filter", escapeTitles, text, node.titleWithHighlight);
				}
				return res;
			};
		}

		this.enableFilter = true;
		this.lastFilterArgs = arguments;

		prevEnableUpdate = this.enableUpdate(false);

		this.$div.addClass("fancytree-ext-filter");
		if (hideMode) {
			this.$div.addClass("fancytree-ext-filter-hide");
		} else {
			this.$div.addClass("fancytree-ext-filter-dimm");
		}
		this.$div.toggleClass(
			"fancytree-ext-filter-hide-expanders",
			!!opts.hideExpanders
		);
		// Reset current filter
		this.rootNode.subMatchCount = 0;
		this.visit(function(node) {
			delete node.match;
			delete node.titleWithHighlight;
			node.subMatchCount = 0;
		});
		statusNode = this.getRootNode()._findDirectChild(KeyNoData);
		if (statusNode) {
			statusNode.remove();
		}

		// Adjust node.hide, .match, and .subMatchCount properties
		treeOpts.autoCollapse = false; // #528

		this.visit(function(node) {
			if (leavesOnly && node.children != null) {
				return;
			}
			var res = filter(node),
				matchedByBranch = false;

			if (res === "skip") {
				node.visit(function(c) {
					c.match = false;
				}, true);
				return "skip";
			}
			if (!res && (branchMode || res === "branch") && node.parent.match) {
				res = true;
				matchedByBranch = true;
			}
			if (res) {
				count++;
				node.match = true;
				node.visitParents(function(p) {
					if (p !== node) {
						p.subMatchCount += 1;
					}
					// Expand match (unless this is no real match, but only a node in a matched branch)
					if (opts.autoExpand && !matchedByBranch && !p.expanded) {
						p.setExpanded(true, {
							noAnimation: true,
							noEvents: true,
							scrollIntoView: false,
						});
						p._filterAutoExpanded = true;
					}
				}, true);
			}
		});
		treeOpts.autoCollapse = prevAutoCollapse;

		if (count === 0 && opts.nodata && hideMode) {
			statusNode = opts.nodata;
			if ($.isFunction(statusNode)) {
				statusNode = statusNode();
			}
			if (statusNode === true) {
				statusNode = {};
			} else if (typeof statusNode === "string") {
				statusNode = { title: statusNode };
			}
			statusNode = $.extend(
				{
					statusNodeType: "nodata",
					key: KeyNoData,
					title: this.options.strings.noData,
				},
				statusNode
			);

			this.getRootNode().addNode(statusNode).match = true;
		}
		// Redraw whole tree
		this._callHook("treeStructureChanged", this, "applyFilter");
		// this.render();
		this.enableUpdate(prevEnableUpdate);
		return count;
	};

	/**
	 * [ext-filter] Dimm or hide nodes.
	 *
	 * @param {function | string} filter
	 * @param {boolean} [opts={autoExpand: false, leavesOnly: false}]
	 * @returns {integer} count
	 * @alias Fancytree#filterNodes
	 * @requires jquery.fancytree.filter.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.filterNodes = function(
		filter,
		opts
	) {
		if (typeof opts === "boolean") {
			opts = { leavesOnly: opts };
			this.warn(
				"Fancytree.filterNodes() leavesOnly option is deprecated since 2.9.0 / 2015-04-19. Use opts.leavesOnly instead."
			);
		}
		return this._applyFilterImpl(filter, false, opts);
	};

	/**
	 * [ext-filter] Dimm or hide whole branches.
	 *
	 * @param {function | string} filter
	 * @param {boolean} [opts={autoExpand: false}]
	 * @returns {integer} count
	 * @alias Fancytree#filterBranches
	 * @requires jquery.fancytree.filter.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.filterBranches = function(
		filter,
		opts
	) {
		return this._applyFilterImpl(filter, true, opts);
	};

	/**
	 * [ext-filter] Reset the filter.
	 *
	 * @alias Fancytree#clearFilter
	 * @requires jquery.fancytree.filter.js
	 */
	$.ui.fancytree._FancytreeClass.prototype.clearFilter = function() {
		var $title,
			statusNode = this.getRootNode()._findDirectChild(KeyNoData),
			escapeTitles = this.options.escapeTitles,
			enhanceTitle = this.options.enhanceTitle,
			prevEnableUpdate = this.enableUpdate(false);

		if (statusNode) {
			statusNode.remove();
		}
		// we also counted root node's subMatchCount
		delete this.rootNode.match;
		delete this.rootNode.subMatchCount;

		this.visit(function(node) {
			if (node.match && node.span) {
				// #491, #601
				$title = $(node.span).find(">span.fancytree-title");
				if (escapeTitles) {
					$title.text(node.title);
				} else {
					$title.html(node.title);
				}
				if (enhanceTitle) {
					enhanceTitle(
						{ type: "enhanceTitle" },
						{ node: node, $title: $title }
					);
				}
			}
			delete node.match;
			delete node.subMatchCount;
			delete node.titleWithHighlight;
			if (node.$subMatchBadge) {
				node.$subMatchBadge.remove();
				delete node.$subMatchBadge;
			}
			if (node._filterAutoExpanded && node.expanded) {
				node.setExpanded(false, {
					noAnimation: true,
					noEvents: true,
					scrollIntoView: false,
				});
			}
			delete node._filterAutoExpanded;
		});
		this.enableFilter = false;
		this.lastFilterArgs = null;
		this.$div.removeClass(
			"fancytree-ext-filter fancytree-ext-filter-dimm fancytree-ext-filter-hide"
		);
		this._callHook("treeStructureChanged", this, "clearFilter");
		// this.render();
		this.enableUpdate(prevEnableUpdate);
	};

	/**
	 * [ext-filter] Return true if a filter is currently applied.
	 *
	 * @returns {Boolean}
	 * @alias Fancytree#isFilterActive
	 * @requires jquery.fancytree.filter.js
	 * @since 2.13
	 */
	$.ui.fancytree._FancytreeClass.prototype.isFilterActive = function() {
		return !!this.enableFilter;
	};

	/**
	 * [ext-filter] Return true if this node is matched by current filter (or no filter is active).
	 *
	 * @returns {Boolean}
	 * @alias FancytreeNode#isMatched
	 * @requires jquery.fancytree.filter.js
	 * @since 2.13
	 */
	$.ui.fancytree._FancytreeNodeClass.prototype.isMatched = function() {
		return !(this.tree.enableFilter && !this.match);
	};

	/*******************************************************************************
	 * Extension code
	 */
	$.ui.fancytree.registerExtension({
		name: "filter",
		version: "2.33.0",
		// Default options for this extension.
		options: {
			autoApply: true, // Re-apply last filter if lazy data is loaded
			autoExpand: false, // Expand all branches that contain matches while filtered
			counter: true, // Show a badge with number of matching child nodes near parent icons
			fuzzy: false, // Match single characters in order, e.g. 'fb' will match 'FooBar'
			hideExpandedCounter: true, // Hide counter badge if parent is expanded
			hideExpanders: false, // Hide expanders if all child nodes are hidden by filter
			highlight: true, // Highlight matches by wrapping inside <mark> tags
			leavesOnly: false, // Match end nodes only
			nodata: true, // Display a 'no data' status node if result is empty
			mode: "dimm", // Grayout unmatched nodes (pass "hide" to remove unmatched node instead)
		},
		nodeLoadChildren: function(ctx, source) {
			var tree = ctx.tree;

			return this._superApply(arguments).done(function() {
				if (
					tree.enableFilter &&
					tree.lastFilterArgs &&
					ctx.options.filter.autoApply
				) {
					tree._applyFilterImpl.apply(tree, tree.lastFilterArgs);
				}
			});
		},
		nodeSetExpanded: function(ctx, flag, callOpts) {
			var node = ctx.node;

			delete node._filterAutoExpanded;
			// Make sure counter badge is displayed again, when node is beeing collapsed
			if (
				!flag &&
				ctx.options.filter.hideExpandedCounter &&
				node.$subMatchBadge
			) {
				node.$subMatchBadge.show();
			}
			return this._superApply(arguments);
		},
		nodeRenderStatus: function(ctx) {
			// Set classes for current status
			var res,
				node = ctx.node,
				tree = ctx.tree,
				opts = ctx.options.filter,
				$title = $(node.span).find("span.fancytree-title"),
				$span = $(node[tree.statusClassPropName]),
				enhanceTitle = ctx.options.enhanceTitle,
				escapeTitles = ctx.options.escapeTitles;

			res = this._super(ctx);
			// nothing to do, if node was not yet rendered
			if (!$span.length || !tree.enableFilter) {
				return res;
			}
			$span
				.toggleClass("fancytree-match", !!node.match)
				.toggleClass("fancytree-submatch", !!node.subMatchCount)
				.toggleClass(
					"fancytree-hide",
					!(node.match || node.subMatchCount)
				);
			// Add/update counter badge
			if (
				opts.counter &&
				node.subMatchCount &&
				(!node.isExpanded() || !opts.hideExpandedCounter)
			) {
				if (!node.$subMatchBadge) {
					node.$subMatchBadge = $(
						"<span class='fancytree-childcounter'/>"
					);
					$(
						"span.fancytree-icon, span.fancytree-custom-icon",
						node.span
					).append(node.$subMatchBadge);
				}
				node.$subMatchBadge.show().text(node.subMatchCount);
			} else if (node.$subMatchBadge) {
				node.$subMatchBadge.hide();
			}
			// node.debug("nodeRenderStatus", node.titleWithHighlight, node.title)
			// #601: also check for $title.length, because we don't need to render
			// if node.span is null (i.e. not rendered)
			if (node.span && (!node.isEditing || !node.isEditing.call(node))) {
				if (node.titleWithHighlight) {
					$title.html(node.titleWithHighlight);
				} else if (escapeTitles) {
					$title.text(node.title);
				} else {
					$title.html(node.title);
				}
				if (enhanceTitle) {
					enhanceTitle(
						{ type: "enhanceTitle" },
						{ node: node, $title: $title }
					);
				}
			}
			return res;
		},
	});
	// Value returned by `require('jquery.fancytree..')`
	return $.ui.fancytree;
}); // End of closure


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.glyph.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.glyph.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jquery.fancytree.glyph.js
 *
 * Use glyph-fonts, ligature-fonts, or SVG icons instead of icon sprites.
 * (Extension module for jquery.fancytree.js: https://github.com/mar10/fancytree/)
 *
 * Copyright (c) 2008-2019, Martin Wendt (https://wwWendt.de)
 *
 * Released under the MIT license
 * https://github.com/mar10/fancytree/wiki/LicenseInfo
 *
 * @version 2.33.0
 * @date 2019-10-29T08:00:07Z
 */

(function(factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./jquery.fancytree */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(function($) {
	"use strict";

	/******************************************************************************
	 * Private functions and variables
	 */

	var FT = $.ui.fancytree,
		PRESETS = {
			awesome3: {
				// Outdated!
				_addClass: "",
				checkbox: "icon-check-empty",
				checkboxSelected: "icon-check",
				checkboxUnknown: "icon-check icon-muted",
				dragHelper: "icon-caret-right",
				dropMarker: "icon-caret-right",
				error: "icon-exclamation-sign",
				expanderClosed: "icon-caret-right",
				expanderLazy: "icon-angle-right",
				expanderOpen: "icon-caret-down",
				loading: "icon-refresh icon-spin",
				nodata: "icon-meh",
				noExpander: "",
				radio: "icon-circle-blank",
				radioSelected: "icon-circle",
				// radioUnknown: "icon-circle icon-muted",
				// Default node icons.
				// (Use tree.options.icon callback to define custom icons based on node data)
				doc: "icon-file-alt",
				docOpen: "icon-file-alt",
				folder: "icon-folder-close-alt",
				folderOpen: "icon-folder-open-alt",
			},
			awesome4: {
				_addClass: "fa",
				checkbox: "fa-square-o",
				checkboxSelected: "fa-check-square-o",
				checkboxUnknown: "fa-square fancytree-helper-indeterminate-cb",
				dragHelper: "fa-arrow-right",
				dropMarker: "fa-long-arrow-right",
				error: "fa-warning",
				expanderClosed: "fa-caret-right",
				expanderLazy: "fa-angle-right",
				expanderOpen: "fa-caret-down",
				// We may prevent wobbling rotations on FF by creating a separate sub element:
				loading: { html: "<span class='fa fa-spinner fa-pulse' />" },
				nodata: "fa-meh-o",
				noExpander: "",
				radio: "fa-circle-thin", // "fa-circle-o"
				radioSelected: "fa-circle",
				// radioUnknown: "fa-dot-circle-o",
				// Default node icons.
				// (Use tree.options.icon callback to define custom icons based on node data)
				doc: "fa-file-o",
				docOpen: "fa-file-o",
				folder: "fa-folder-o",
				folderOpen: "fa-folder-open-o",
			},
			awesome5: {
				// fontawesome 5 have several different base classes
				// "far, fas, fal and fab" The rendered svg puts that prefix
				// in a different location so we have to keep them separate here
				_addClass: "",
				checkbox: "far fa-square",
				checkboxSelected: "far fa-check-square",
				// checkboxUnknown: "far fa-window-close",
				checkboxUnknown:
					"fas fa-square fancytree-helper-indeterminate-cb",
				radio: "far fa-circle",
				radioSelected: "fas fa-circle",
				radioUnknown: "far fa-dot-circle",
				dragHelper: "fas fa-arrow-right",
				dropMarker: "fas fa-long-arrow-alt-right",
				error: "fas fa-exclamation-triangle",
				expanderClosed: "fas fa-caret-right",
				expanderLazy: "fas fa-angle-right",
				expanderOpen: "fas fa-caret-down",
				loading: "fas fa-spinner fa-pulse",
				nodata: "far fa-meh",
				noExpander: "",
				// Default node icons.
				// (Use tree.options.icon callback to define custom icons based on node data)
				doc: "far fa-file",
				docOpen: "far fa-file",
				folder: "far fa-folder",
				folderOpen: "far fa-folder-open",
			},
			bootstrap3: {
				_addClass: "glyphicon",
				checkbox: "glyphicon-unchecked",
				checkboxSelected: "glyphicon-check",
				checkboxUnknown:
					"glyphicon-expand fancytree-helper-indeterminate-cb", // "glyphicon-share",
				dragHelper: "glyphicon-play",
				dropMarker: "glyphicon-arrow-right",
				error: "glyphicon-warning-sign",
				expanderClosed: "glyphicon-menu-right", // glyphicon-plus-sign
				expanderLazy: "glyphicon-menu-right", // glyphicon-plus-sign
				expanderOpen: "glyphicon-menu-down", // glyphicon-minus-sign
				loading: "glyphicon-refresh fancytree-helper-spin",
				nodata: "glyphicon-info-sign",
				noExpander: "",
				radio: "glyphicon-remove-circle", // "glyphicon-unchecked",
				radioSelected: "glyphicon-ok-circle", // "glyphicon-check",
				// radioUnknown: "glyphicon-ban-circle",
				// Default node icons.
				// (Use tree.options.icon callback to define custom icons based on node data)
				doc: "glyphicon-file",
				docOpen: "glyphicon-file",
				folder: "glyphicon-folder-close",
				folderOpen: "glyphicon-folder-open",
			},
			material: {
				_addClass: "material-icons",
				checkbox: { text: "check_box_outline_blank" },
				checkboxSelected: { text: "check_box" },
				checkboxUnknown: { text: "indeterminate_check_box" },
				dragHelper: { text: "play_arrow" },
				dropMarker: { text: "arrow-forward" },
				error: { text: "warning" },
				expanderClosed: { text: "chevron_right" },
				expanderLazy: { text: "last_page" },
				expanderOpen: { text: "expand_more" },
				loading: {
					text: "autorenew",
					addClass: "fancytree-helper-spin",
				},
				nodata: { text: "info" },
				noExpander: { text: "" },
				radio: { text: "radio_button_unchecked" },
				radioSelected: { text: "radio_button_checked" },
				// Default node icons.
				// (Use tree.options.icon callback to define custom icons based on node data)
				doc: { text: "insert_drive_file" },
				docOpen: { text: "insert_drive_file" },
				folder: { text: "folder" },
				folderOpen: { text: "folder_open" },
			},
		};

	function setIcon(span, baseClass, opts, type) {
		var map = opts.map,
			icon = map[type],
			$span = $(span),
			$counter = $span.find(".fancytree-childcounter"),
			setClass = baseClass + " " + (map._addClass || "");

		if (typeof icon === "string") {
			// #883: remove inner html that may be added by prev. mode
			span.innerHTML = "";
			$span.attr("class", setClass + " " + icon).append($counter);
		} else if (icon) {
			if (icon.text) {
				span.textContent = "" + icon.text;
			} else if (icon.html) {
				span.innerHTML = icon.html;
			} else {
				span.innerHTML = "";
			}
			$span
				.attr("class", setClass + " " + (icon.addClass || ""))
				.append($counter);
		}
	}

	$.ui.fancytree.registerExtension({
		name: "glyph",
		version: "2.33.0",
		// Default options for this extension.
		options: {
			preset: null, // 'awesome3', 'awesome4', 'bootstrap3', 'material'
			map: {},
		},

		treeInit: function(ctx) {
			var tree = ctx.tree,
				opts = ctx.options.glyph;

			if (opts.preset) {
				FT.assert(
					!!PRESETS[opts.preset],
					"Invalid value for `options.glyph.preset`: " + opts.preset
				);
				opts.map = $.extend({}, PRESETS[opts.preset], opts.map);
			} else {
				tree.warn("ext-glyph: missing `preset` option.");
			}
			this._superApply(arguments);
			tree.$container.addClass("fancytree-ext-glyph");
		},
		nodeRenderStatus: function(ctx) {
			var checkbox,
				icon,
				res,
				span,
				node = ctx.node,
				$span = $(node.span),
				opts = ctx.options.glyph;

			res = this._super(ctx);

			if (node.isRoot()) {
				return res;
			}
			span = $span.children("span.fancytree-expander").get(0);
			if (span) {
				// if( node.isLoading() ){
				// icon = "loading";
				if (node.expanded && node.hasChildren()) {
					icon = "expanderOpen";
				} else if (node.isUndefined()) {
					icon = "expanderLazy";
				} else if (node.hasChildren()) {
					icon = "expanderClosed";
				} else {
					icon = "noExpander";
				}
				// span.className = "fancytree-expander " + map[icon];
				setIcon(span, "fancytree-expander", opts, icon);
			}

			if (node.tr) {
				span = $("td", node.tr)
					.find("span.fancytree-checkbox")
					.get(0);
			} else {
				span = $span.children("span.fancytree-checkbox").get(0);
			}
			if (span) {
				checkbox = FT.evalOption("checkbox", node, node, opts, false);
				if (
					(node.parent && node.parent.radiogroup) ||
					checkbox === "radio"
				) {
					icon = node.selected ? "radioSelected" : "radio";
					setIcon(
						span,
						"fancytree-checkbox fancytree-radio",
						opts,
						icon
					);
				} else {
					// eslint-disable-next-line no-nested-ternary
					icon = node.selected
						? "checkboxSelected"
						: node.partsel
						? "checkboxUnknown"
						: "checkbox";
					// span.className = "fancytree-checkbox " + map[icon];
					setIcon(span, "fancytree-checkbox", opts, icon);
				}
			}

			// Standard icon (note that this does not match .fancytree-custom-icon,
			// that might be set by opts.icon callbacks)
			span = $span.children("span.fancytree-icon").get(0);
			if (span) {
				if (node.statusNodeType) {
					icon = node.statusNodeType; // loading, error
				} else if (node.folder) {
					icon =
						node.expanded && node.hasChildren()
							? "folderOpen"
							: "folder";
				} else {
					icon = node.expanded ? "docOpen" : "doc";
				}
				setIcon(span, "fancytree-icon", opts, icon);
			}
			return res;
		},
		nodeSetStatus: function(ctx, status, message, details) {
			var res,
				span,
				opts = ctx.options.glyph,
				node = ctx.node;

			res = this._superApply(arguments);

			if (
				status === "error" ||
				status === "loading" ||
				status === "nodata"
			) {
				if (node.parent) {
					span = $("span.fancytree-expander", node.span).get(0);
					if (span) {
						setIcon(span, "fancytree-expander", opts, status);
					}
				} else {
					//
					span = $(
						".fancytree-statusnode-" + status,
						node[this.nodeContainerAttrName]
					)
						.find("span.fancytree-icon")
						.get(0);
					if (span) {
						setIcon(span, "fancytree-icon", opts, status);
					}
				}
			}
			return res;
		},
	});
	// Value returned by `require('jquery.fancytree..')`
	return $.ui.fancytree;
}); // End of closure


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.js":
/*!************************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jquery.fancytree.js
 * Tree view control with support for lazy loading and much more.
 * https://github.com/mar10/fancytree/
 *
 * Copyright (c) 2008-2019, Martin Wendt (https://wwWendt.de)
 * Released under the MIT license
 * https://github.com/mar10/fancytree/wiki/LicenseInfo
 *
 * @version 2.33.0
 * @date 2019-10-29T08:00:07Z
 */

/** Core Fancytree module.
 */

// UMD wrapper for the Fancytree core module
(function(factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./jquery.fancytree.ui-deps */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.ui-deps.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(function($) {
	"use strict";

	// prevent duplicate loading
	if ($.ui && $.ui.fancytree) {
		$.ui.fancytree.warn("Fancytree: ignored duplicate include");
		return;
	}

	/******************************************************************************
	 * Private functions and variables
	 */

	var i,
		attr,
		FT = null, // initialized below
		TEST_IMG = new RegExp(/\.|\//), // strings are considered image urls if they contain '.' or '/'
		REX_HTML = /[&<>"'/]/g, // Escape those characters
		REX_TOOLTIP = /[<>"'/]/g, // Don't escape `&` in tooltips
		RECURSIVE_REQUEST_ERROR = "$recursive_request",
		// CLIPBOARD = null,
		ENTITY_MAP = {
			"&": "&amp;",
			"<": "&lt;",
			">": "&gt;",
			'"': "&quot;",
			"'": "&#39;",
			"/": "&#x2F;",
		},
		IGNORE_KEYCODES = { 16: true, 17: true, 18: true },
		SPECIAL_KEYCODES = {
			8: "backspace",
			9: "tab",
			10: "return",
			13: "return",
			// 16: null, 17: null, 18: null,  // ignore shift, ctrl, alt
			19: "pause",
			20: "capslock",
			27: "esc",
			32: "space",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			45: "insert",
			46: "del",
			59: ";",
			61: "=",
			// 91: null, 93: null,  // ignore left and right meta
			96: "0",
			97: "1",
			98: "2",
			99: "3",
			100: "4",
			101: "5",
			102: "6",
			103: "7",
			104: "8",
			105: "9",
			106: "*",
			107: "+",
			109: "-",
			110: ".",
			111: "/",
			112: "f1",
			113: "f2",
			114: "f3",
			115: "f4",
			116: "f5",
			117: "f6",
			118: "f7",
			119: "f8",
			120: "f9",
			121: "f10",
			122: "f11",
			123: "f12",
			144: "numlock",
			145: "scroll",
			173: "-",
			186: ";",
			187: "=",
			188: ",",
			189: "-",
			190: ".",
			191: "/",
			192: "`",
			219: "[",
			220: "\\",
			221: "]",
			222: "'",
		},
		MODIFIERS = {
			16: "shift",
			17: "ctrl",
			18: "alt",
			91: "meta",
			93: "meta",
		},
		MOUSE_BUTTONS = { 0: "", 1: "left", 2: "middle", 3: "right" },
		// Boolean attributes that can be set with equivalent class names in the LI tags
		// Note: v2.23: checkbox and hideCheckbox are *not* in this list
		CLASS_ATTRS = "active expanded focus folder lazy radiogroup selected unselectable unselectableIgnore".split(
			" "
		),
		CLASS_ATTR_MAP = {},
		// Top-level Fancytree attributes, that can be set by dict
		TREE_ATTRS = "columns types".split(" "),
		// TREE_ATTR_MAP = {},
		// Top-level FancytreeNode attributes, that can be set by dict
		NODE_ATTRS = "checkbox expanded extraClasses folder icon iconTooltip key lazy partsel radiogroup refKey selected statusNodeType title tooltip type unselectable unselectableIgnore unselectableStatus".split(
			" "
		),
		NODE_ATTR_MAP = {},
		// Mapping of lowercase -> real name (because HTML5 data-... attribute only supports lowercase)
		NODE_ATTR_LOWERCASE_MAP = {},
		// Attribute names that should NOT be added to node.data
		NONE_NODE_DATA_MAP = {
			active: true,
			children: true,
			data: true,
			focus: true,
		};

	for (i = 0; i < CLASS_ATTRS.length; i++) {
		CLASS_ATTR_MAP[CLASS_ATTRS[i]] = true;
	}
	for (i = 0; i < NODE_ATTRS.length; i++) {
		attr = NODE_ATTRS[i];
		NODE_ATTR_MAP[attr] = true;
		if (attr !== attr.toLowerCase()) {
			NODE_ATTR_LOWERCASE_MAP[attr.toLowerCase()] = attr;
		}
	}
	// for(i=0; i<TREE_ATTRS.length; i++) {
	// 	TREE_ATTR_MAP[TREE_ATTRS[i]] = true;
	// }

	function _assert(cond, msg) {
		// TODO: see qunit.js extractStacktrace()
		if (!cond) {
			msg = msg ? ": " + msg : "";
			// consoleApply("assert", [!!cond, msg]);
			$.error("Fancytree assertion failed" + msg);
		}
	}

	_assert($.ui, "Fancytree requires jQuery UI (http://jqueryui.com)");

	function consoleApply(method, args) {
		var i,
			s,
			fn = window.console ? window.console[method] : null;

		if (fn) {
			try {
				fn.apply(window.console, args);
			} catch (e) {
				// IE 8?
				s = "";
				for (i = 0; i < args.length; i++) {
					s += args[i];
				}
				fn(s);
			}
		}
	}

	/* support: IE8 Polyfil for Date.now() */
	if (!Date.now) {
		Date.now = function now() {
			return new Date().getTime();
		};
	}

	/*Return true if x is a FancytreeNode.*/
	function _isNode(x) {
		return !!(x.tree && x.statusNodeType !== undefined);
	}

	/** Return true if dotted version string is equal or higher than requested version.
	 *
	 * See http://jsfiddle.net/mar10/FjSAN/
	 */
	function isVersionAtLeast(dottedVersion, major, minor, patch) {
		var i,
			v,
			t,
			verParts = $.map($.trim(dottedVersion).split("."), function(e) {
				return parseInt(e, 10);
			}),
			testParts = $.map(
				Array.prototype.slice.call(arguments, 1),
				function(e) {
					return parseInt(e, 10);
				}
			);

		for (i = 0; i < testParts.length; i++) {
			v = verParts[i] || 0;
			t = testParts[i] || 0;
			if (v !== t) {
				return v > t;
			}
		}
		return true;
	}

	/**
	 * Deep-merge a list of objects (but replace array-type options).
	 *
	 * jQuery's $.extend(true, ...) method does a deep merge, that also merges Arrays.
	 * This variant is used to merge extension defaults with user options, and should
	 * merge objects, but override arrays (for example the `triggerStart: [...]` option
	 * of ext-edit). Also `null` values are copied over and not skipped.
	 *
	 * See issue #876
	 *
	 * Example:
	 * _simpleDeepMerge({}, o1, o2);
	 */
	function _simpleDeepMerge() {
		var options,
			name,
			src,
			copy,
			clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length;

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !$.isFunction(target)) {
			target = {};
		}
		if (i === length) {
			throw Error("need at least two args");
		}
		for (; i < length; i++) {
			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {
				// Extend the base object
				for (name in options) {
					if (options.hasOwnProperty(name)) {
						src = target[name];
						copy = options[name];
						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}
						// Recurse if we're merging plain objects
						// (NOTE: unlike $.extend, we don't merge arrays, but replace them)
						if (copy && $.isPlainObject(copy)) {
							clone = src && $.isPlainObject(src) ? src : {};
							// Never move original objects, clone them
							target[name] = _simpleDeepMerge(clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
		}
		// Return the modified object
		return target;
	}

	/** Return a wrapper that calls sub.methodName() and exposes
	 *  this             : tree
	 *  this._local      : tree.ext.EXTNAME
	 *  this._super      : base.methodName.call()
	 *  this._superApply : base.methodName.apply()
	 */
	function _makeVirtualFunction(methodName, tree, base, extension, extName) {
		// $.ui.fancytree.debug("_makeVirtualFunction", methodName, tree, base, extension, extName);
		// if(rexTestSuper && !rexTestSuper.test(func)){
		//     // extension.methodName() doesn't call _super(), so no wrapper required
		//     return func;
		// }
		// Use an immediate function as closure
		var proxy = (function() {
			var prevFunc = tree[methodName], // org. tree method or prev. proxy
				baseFunc = extension[methodName], //
				_local = tree.ext[extName],
				_super = function() {
					return prevFunc.apply(tree, arguments);
				},
				_superApply = function(args) {
					return prevFunc.apply(tree, args);
				};

			// Return the wrapper function
			return function() {
				var prevLocal = tree._local,
					prevSuper = tree._super,
					prevSuperApply = tree._superApply;

				try {
					tree._local = _local;
					tree._super = _super;
					tree._superApply = _superApply;
					return baseFunc.apply(tree, arguments);
				} finally {
					tree._local = prevLocal;
					tree._super = prevSuper;
					tree._superApply = prevSuperApply;
				}
			};
		})(); // end of Immediate Function
		return proxy;
	}

	/**
	 * Subclass `base` by creating proxy functions
	 */
	function _subclassObject(tree, base, extension, extName) {
		// $.ui.fancytree.debug("_subclassObject", tree, base, extension, extName);
		for (var attrName in extension) {
			if (typeof extension[attrName] === "function") {
				if (typeof tree[attrName] === "function") {
					// override existing method
					tree[attrName] = _makeVirtualFunction(
						attrName,
						tree,
						base,
						extension,
						extName
					);
				} else if (attrName.charAt(0) === "_") {
					// Create private methods in tree.ext.EXTENSION namespace
					tree.ext[extName][attrName] = _makeVirtualFunction(
						attrName,
						tree,
						base,
						extension,
						extName
					);
				} else {
					$.error(
						"Could not override tree." +
							attrName +
							". Use prefix '_' to create tree." +
							extName +
							"._" +
							attrName
					);
				}
			} else {
				// Create member variables in tree.ext.EXTENSION namespace
				if (attrName !== "options") {
					tree.ext[extName][attrName] = extension[attrName];
				}
			}
		}
	}

	function _getResolvedPromise(context, argArray) {
		if (context === undefined) {
			return $.Deferred(function() {
				this.resolve();
			}).promise();
		}
		return $.Deferred(function() {
			this.resolveWith(context, argArray);
		}).promise();
	}

	function _getRejectedPromise(context, argArray) {
		if (context === undefined) {
			return $.Deferred(function() {
				this.reject();
			}).promise();
		}
		return $.Deferred(function() {
			this.rejectWith(context, argArray);
		}).promise();
	}

	function _makeResolveFunc(deferred, context) {
		return function() {
			deferred.resolveWith(context);
		};
	}

	function _getElementDataAsDict($el) {
		// Evaluate 'data-NAME' attributes with special treatment for 'data-json'.
		var d = $.extend({}, $el.data()),
			json = d.json;

		delete d.fancytree; // added to container by widget factory (old jQuery UI)
		delete d.uiFancytree; // added to container by widget factory

		if (json) {
			delete d.json;
			// <li data-json='...'> is already returned as object (http://api.jquery.com/data/#data-html5)
			d = $.extend(d, json);
		}
		return d;
	}

	function _escapeTooltip(s) {
		return ("" + s).replace(REX_TOOLTIP, function(s) {
			return ENTITY_MAP[s];
		});
	}

	// TODO: use currying
	function _makeNodeTitleMatcher(s) {
		s = s.toLowerCase();
		return function(node) {
			return node.title.toLowerCase().indexOf(s) >= 0;
		};
	}

	function _makeNodeTitleStartMatcher(s) {
		var reMatch = new RegExp("^" + s, "i");
		return function(node) {
			return reMatch.test(node.title);
		};
	}

	/******************************************************************************
	 * FancytreeNode
	 */

	/**
	 * Creates a new FancytreeNode
	 *
	 * @class FancytreeNode
	 * @classdesc A FancytreeNode represents the hierarchical data model and operations.
	 *
	 * @param {FancytreeNode} parent
	 * @param {NodeData} obj
	 *
	 * @property {Fancytree} tree The tree instance
	 * @property {FancytreeNode} parent The parent node
	 * @property {string} key Node id (must be unique inside the tree)
	 * @property {string} title Display name (may contain HTML)
	 * @property {object} data Contains all extra data that was passed on node creation
	 * @property {FancytreeNode[] | null | undefined} children Array of child nodes.<br>
	 *     For lazy nodes, null or undefined means 'not yet loaded'. Use an empty array
	 *     to define a node that has no children.
	 * @property {boolean} expanded Use isExpanded(), setExpanded() to access this property.
	 * @property {string} extraClasses Additional CSS classes, added to the node's `<span>`.<br>
	 *     Note: use `node.add/remove/toggleClass()` to modify.
	 * @property {boolean} folder Folder nodes have different default icons and click behavior.<br>
	 *     Note: Also non-folders may have children.
	 * @property {string} statusNodeType null for standard nodes. Otherwise type of special system node: 'error', 'loading', 'nodata', or 'paging'.
	 * @property {boolean} lazy True if this node is loaded on demand, i.e. on first expansion.
	 * @property {boolean} selected Use isSelected(), setSelected() to access this property.
	 * @property {string} tooltip Alternative description used as hover popup
	 * @property {string} iconTooltip Description used as hover popup for icon. @since 2.27
	 * @property {string} type Node type, used with tree.types map. @since 2.27
	 */
	function FancytreeNode(parent, obj) {
		var i, l, name, cl;

		this.parent = parent;
		this.tree = parent.tree;
		this.ul = null;
		this.li = null; // <li id='key' ftnode=this> tag
		this.statusNodeType = null; // if this is a temp. node to display the status of its parent
		this._isLoading = false; // if this node itself is loading
		this._error = null; // {message: '...'} if a load error occurred
		this.data = {};

		// TODO: merge this code with node.toDict()
		// copy attributes from obj object
		for (i = 0, l = NODE_ATTRS.length; i < l; i++) {
			name = NODE_ATTRS[i];
			this[name] = obj[name];
		}
		// unselectableIgnore and unselectableStatus imply unselectable
		if (
			this.unselectableIgnore != null ||
			this.unselectableStatus != null
		) {
			this.unselectable = true;
		}
		if (obj.hideCheckbox) {
			$.error(
				"'hideCheckbox' node option was removed in v2.23.0: use 'checkbox: false'"
			);
		}
		// node.data += obj.data
		if (obj.data) {
			$.extend(this.data, obj.data);
		}
		// Copy all other attributes to this.data.NAME
		for (name in obj) {
			if (
				!NODE_ATTR_MAP[name] &&
				!$.isFunction(obj[name]) &&
				!NONE_NODE_DATA_MAP[name]
			) {
				// node.data.NAME = obj.NAME
				this.data[name] = obj[name];
			}
		}

		// Fix missing key
		if (this.key == null) {
			// test for null OR undefined
			if (this.tree.options.defaultKey) {
				this.key = this.tree.options.defaultKey(this);
				_assert(this.key, "defaultKey() must return a unique key");
			} else {
				this.key = "_" + FT._nextNodeKey++;
			}
		} else {
			this.key = "" + this.key; // Convert to string (#217)
		}

		// Fix tree.activeNode
		// TODO: not elegant: we use obj.active as marker to set tree.activeNode
		// when loading from a dictionary.
		if (obj.active) {
			_assert(
				this.tree.activeNode === null,
				"only one active node allowed"
			);
			this.tree.activeNode = this;
		}
		if (obj.selected) {
			// #186
			this.tree.lastSelectedNode = this;
		}
		// TODO: handle obj.focus = true

		// Create child nodes
		cl = obj.children;
		if (cl) {
			if (cl.length) {
				this._setChildren(cl);
			} else {
				// if an empty array was passed for a lazy node, keep it, in order to mark it 'loaded'
				this.children = this.lazy ? [] : null;
			}
		} else {
			this.children = null;
		}
		// Add to key/ref map (except for root node)
		//	if( parent ) {
		this.tree._callHook("treeRegisterNode", this.tree, true, this);
		//	}
	}

	FancytreeNode.prototype = /** @lends FancytreeNode# */ {
		/* Return the direct child FancytreeNode with a given key, index. */
		_findDirectChild: function(ptr) {
			var i,
				l,
				cl = this.children;

			if (cl) {
				if (typeof ptr === "string") {
					for (i = 0, l = cl.length; i < l; i++) {
						if (cl[i].key === ptr) {
							return cl[i];
						}
					}
				} else if (typeof ptr === "number") {
					return this.children[ptr];
				} else if (ptr.parent === this) {
					return ptr;
				}
			}
			return null;
		},
		// TODO: activate()
		// TODO: activateSilently()
		/* Internal helper called in recursive addChildren sequence.*/
		_setChildren: function(children) {
			_assert(
				children && (!this.children || this.children.length === 0),
				"only init supported"
			);
			this.children = [];
			for (var i = 0, l = children.length; i < l; i++) {
				this.children.push(new FancytreeNode(this, children[i]));
			}
			this.tree._callHook(
				"treeStructureChanged",
				this.tree,
				"setChildren"
			);
		},
		/**
		 * Append (or insert) a list of child nodes.
		 *
		 * @param {NodeData[]} children array of child node definitions (also single child accepted)
		 * @param {FancytreeNode | string | Integer} [insertBefore] child node (or key or index of such).
		 *     If omitted, the new children are appended.
		 * @returns {FancytreeNode} first child added
		 *
		 * @see FancytreeNode#applyPatch
		 */
		addChildren: function(children, insertBefore) {
			var i,
				l,
				pos,
				origFirstChild = this.getFirstChild(),
				origLastChild = this.getLastChild(),
				firstNode = null,
				nodeList = [];

			if ($.isPlainObject(children)) {
				children = [children];
			}
			if (!this.children) {
				this.children = [];
			}
			for (i = 0, l = children.length; i < l; i++) {
				nodeList.push(new FancytreeNode(this, children[i]));
			}
			firstNode = nodeList[0];
			if (insertBefore == null) {
				this.children = this.children.concat(nodeList);
			} else {
				// Returns null if insertBefore is not a direct child:
				insertBefore = this._findDirectChild(insertBefore);
				pos = $.inArray(insertBefore, this.children);
				_assert(pos >= 0, "insertBefore must be an existing child");
				// insert nodeList after children[pos]
				this.children.splice.apply(
					this.children,
					[pos, 0].concat(nodeList)
				);
			}
			if (origFirstChild && !insertBefore) {
				// #708: Fast path -- don't render every child of root, just the new ones!
				// #723, #729: but only if it's appended to an existing child list
				for (i = 0, l = nodeList.length; i < l; i++) {
					nodeList[i].render(); // New nodes were never rendered before
				}
				// Adjust classes where status may have changed
				// Has a first child
				if (origFirstChild !== this.getFirstChild()) {
					// Different first child -- recompute classes
					origFirstChild.renderStatus();
				}
				if (origLastChild !== this.getLastChild()) {
					// Different last child -- recompute classes
					origLastChild.renderStatus();
				}
			} else if (!this.parent || this.parent.ul || this.tr) {
				// render if the parent was rendered (or this is a root node)
				this.render();
			}
			if (this.tree.options.selectMode === 3) {
				this.fixSelection3FromEndNodes();
			}
			this.triggerModifyChild(
				"add",
				nodeList.length === 1 ? nodeList[0] : null
			);
			return firstNode;
		},
		/**
		 * Add class to node's span tag and to .extraClasses.
		 *
		 * @param {string} className class name
		 *
		 * @since 2.17
		 */
		addClass: function(className) {
			return this.toggleClass(className, true);
		},
		/**
		 * Append or prepend a node, or append a child node.
		 *
		 * This a convenience function that calls addChildren()
		 *
		 * @param {NodeData} node node definition
		 * @param {string} [mode=child] 'before', 'after', 'firstChild', or 'child' ('over' is a synonym for 'child')
		 * @returns {FancytreeNode} new node
		 */
		addNode: function(node, mode) {
			if (mode === undefined || mode === "over") {
				mode = "child";
			}
			switch (mode) {
				case "after":
					return this.getParent().addChildren(
						node,
						this.getNextSibling()
					);
				case "before":
					return this.getParent().addChildren(node, this);
				case "firstChild":
					// Insert before the first child if any
					var insertBefore = this.children ? this.children[0] : null;
					return this.addChildren(node, insertBefore);
				case "child":
				case "over":
					return this.addChildren(node);
			}
			_assert(false, "Invalid mode: " + mode);
		},
		/**Add child status nodes that indicate 'More...', etc.
		 *
		 * This also maintains the node's `partload` property.
		 * @param {boolean|object} node optional node definition. Pass `false` to remove all paging nodes.
		 * @param {string} [mode='child'] 'child'|firstChild'
		 * @since 2.15
		 */
		addPagingNode: function(node, mode) {
			var i, n;

			mode = mode || "child";
			if (node === false) {
				for (i = this.children.length - 1; i >= 0; i--) {
					n = this.children[i];
					if (n.statusNodeType === "paging") {
						this.removeChild(n);
					}
				}
				this.partload = false;
				return;
			}
			node = $.extend(
				{
					title: this.tree.options.strings.moreData,
					statusNodeType: "paging",
					icon: false,
				},
				node
			);
			this.partload = true;
			return this.addNode(node, mode);
		},
		/**
		 * Append new node after this.
		 *
		 * This a convenience function that calls addNode(node, 'after')
		 *
		 * @param {NodeData} node node definition
		 * @returns {FancytreeNode} new node
		 */
		appendSibling: function(node) {
			return this.addNode(node, "after");
		},
		/**
		 * (experimental) Apply a modification (or navigation) operation.
		 *
		 * @param {string} cmd
		 * @param {object} [opts]
		 * @see Fancytree#applyCommand
		 * @since 2.32
		 */
		applyCommand: function(cmd, opts) {
			return this.tree.applyCommand(cmd, this, opts);
		},
		/**
		 * Modify existing child nodes.
		 *
		 * @param {NodePatch} patch
		 * @returns {$.Promise}
		 * @see FancytreeNode#addChildren
		 */
		applyPatch: function(patch) {
			// patch [key, null] means 'remove'
			if (patch === null) {
				this.remove();
				return _getResolvedPromise(this);
			}
			// TODO: make sure that root node is not collapsed or modified
			// copy (most) attributes to node.ATTR or node.data.ATTR
			var name,
				promise,
				v,
				IGNORE_MAP = { children: true, expanded: true, parent: true }; // TODO: should be global

			for (name in patch) {
				if (patch.hasOwnProperty(name)) {
					v = patch[name];
					if (!IGNORE_MAP[name] && !$.isFunction(v)) {
						if (NODE_ATTR_MAP[name]) {
							this[name] = v;
						} else {
							this.data[name] = v;
						}
					}
				}
			}
			// Remove and/or create children
			if (patch.hasOwnProperty("children")) {
				this.removeChildren();
				if (patch.children) {
					// only if not null and not empty list
					// TODO: addChildren instead?
					this._setChildren(patch.children);
				}
				// TODO: how can we APPEND or INSERT child nodes?
			}
			if (this.isVisible()) {
				this.renderTitle();
				this.renderStatus();
			}
			// Expand collapse (final step, since this may be async)
			if (patch.hasOwnProperty("expanded")) {
				promise = this.setExpanded(patch.expanded);
			} else {
				promise = _getResolvedPromise(this);
			}
			return promise;
		},
		/** Collapse all sibling nodes.
		 * @returns {$.Promise}
		 */
		collapseSiblings: function() {
			return this.tree._callHook("nodeCollapseSiblings", this);
		},
		/** Copy this node as sibling or child of `node`.
		 *
		 * @param {FancytreeNode} node source node
		 * @param {string} [mode=child] 'before' | 'after' | 'child'
		 * @param {Function} [map] callback function(NodeData) that could modify the new node
		 * @returns {FancytreeNode} new
		 */
		copyTo: function(node, mode, map) {
			return node.addNode(this.toDict(true, map), mode);
		},
		/** Count direct and indirect children.
		 *
		 * @param {boolean} [deep=true] pass 'false' to only count direct children
		 * @returns {int} number of child nodes
		 */
		countChildren: function(deep) {
			var cl = this.children,
				i,
				l,
				n;
			if (!cl) {
				return 0;
			}
			n = cl.length;
			if (deep !== false) {
				for (i = 0, l = n; i < l; i++) {
					n += cl[i].countChildren();
				}
			}
			return n;
		},
		// TODO: deactivate()
		/** Write to browser console if debugLevel >= 4 (prepending node info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		debug: function(msg) {
			if (this.tree.options.debugLevel >= 4) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("log", arguments);
			}
		},
		/** Deprecated.
		 * @deprecated since 2014-02-16. Use resetLazy() instead.
		 */
		discard: function() {
			this.warn(
				"FancytreeNode.discard() is deprecated since 2014-02-16. Use .resetLazy() instead."
			);
			return this.resetLazy();
		},
		/** Remove DOM elements for all descendents. May be called on .collapse event
		 * to keep the DOM small.
		 * @param {boolean} [includeSelf=false]
		 */
		discardMarkup: function(includeSelf) {
			var fn = includeSelf ? "nodeRemoveMarkup" : "nodeRemoveChildMarkup";
			this.tree._callHook(fn, this);
		},
		/** Write error to browser console if debugLevel >= 1 (prepending tree info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		error: function(msg) {
			if (this.tree.options.debugLevel >= 1) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("error", arguments);
			}
		},
		/**Find all nodes that match condition (excluding self).
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode[]} array of nodes (may be empty)
		 */
		findAll: function(match) {
			match = $.isFunction(match) ? match : _makeNodeTitleMatcher(match);
			var res = [];
			this.visit(function(n) {
				if (match(n)) {
					res.push(n);
				}
			});
			return res;
		},
		/**Find first node that matches condition (excluding self).
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode} matching node or null
		 * @see FancytreeNode#findAll
		 */
		findFirst: function(match) {
			match = $.isFunction(match) ? match : _makeNodeTitleMatcher(match);
			var res = null;
			this.visit(function(n) {
				if (match(n)) {
					res = n;
					return false;
				}
			});
			return res;
		},
		/** Find a node relative to self.
		 *
		 * @param {number|string} where The keyCode that would normally trigger this move,
		 *		or a keyword ('down', 'first', 'last', 'left', 'parent', 'right', 'up').
		 * @returns {FancytreeNode}
		 * @since v2.31
		 */
		findRelatedNode: function(where, includeHidden) {
			return this.tree.findRelatedNode(this, where, includeHidden);
		},
		/* Apply selection state (internal use only) */
		_changeSelectStatusAttrs: function(state) {
			var changed = false,
				opts = this.tree.options,
				unselectable = FT.evalOption(
					"unselectable",
					this,
					this,
					opts,
					false
				),
				unselectableStatus = FT.evalOption(
					"unselectableStatus",
					this,
					this,
					opts,
					undefined
				);

			if (unselectable && unselectableStatus != null) {
				state = unselectableStatus;
			}
			switch (state) {
				case false:
					changed = this.selected || this.partsel;
					this.selected = false;
					this.partsel = false;
					break;
				case true:
					changed = !this.selected || !this.partsel;
					this.selected = true;
					this.partsel = true;
					break;
				case undefined:
					changed = this.selected || !this.partsel;
					this.selected = false;
					this.partsel = true;
					break;
				default:
					_assert(false, "invalid state: " + state);
			}
			// this.debug("fixSelection3AfterLoad() _changeSelectStatusAttrs()", state, changed);
			if (changed) {
				this.renderStatus();
			}
			return changed;
		},
		/**
		 * Fix selection status, after this node was (de)selected in multi-hier mode.
		 * This includes (de)selecting all children.
		 */
		fixSelection3AfterClick: function(callOpts) {
			var flag = this.isSelected();

			// this.debug("fixSelection3AfterClick()");

			this.visit(function(node) {
				node._changeSelectStatusAttrs(flag);
				if (node.radiogroup) {
					// #931: don't (de)select this branch
					return "skip";
				}
			});
			this.fixSelection3FromEndNodes(callOpts);
		},
		/**
		 * Fix selection status for multi-hier mode.
		 * Only end-nodes are considered to update the descendants branch and parents.
		 * Should be called after this node has loaded new children or after
		 * children have been modified using the API.
		 */
		fixSelection3FromEndNodes: function(callOpts) {
			var opts = this.tree.options;

			// this.debug("fixSelection3FromEndNodes()");
			_assert(opts.selectMode === 3, "expected selectMode 3");

			// Visit all end nodes and adjust their parent's `selected` and `partsel`
			// attributes. Return selection state true, false, or undefined.
			function _walk(node) {
				var i,
					l,
					child,
					s,
					state,
					allSelected,
					someSelected,
					unselIgnore,
					unselState,
					children = node.children;

				if (children && children.length) {
					// check all children recursively
					allSelected = true;
					someSelected = false;

					for (i = 0, l = children.length; i < l; i++) {
						child = children[i];
						// the selection state of a node is not relevant; we need the end-nodes
						s = _walk(child);
						// if( !child.unselectableIgnore ) {
						unselIgnore = FT.evalOption(
							"unselectableIgnore",
							child,
							child,
							opts,
							false
						);
						if (!unselIgnore) {
							if (s !== false) {
								someSelected = true;
							}
							if (s !== true) {
								allSelected = false;
							}
						}
					}
					// eslint-disable-next-line no-nested-ternary
					state = allSelected
						? true
						: someSelected
						? undefined
						: false;
				} else {
					// This is an end-node: simply report the status
					unselState = FT.evalOption(
						"unselectableStatus",
						node,
						node,
						opts,
						undefined
					);
					state = unselState == null ? !!node.selected : !!unselState;
				}
				// #939: Keep a `partsel` flag that was explicitly set on a lazy node
				if (
					node.partsel &&
					!node.selected &&
					node.lazy &&
					node.children == null
				) {
					state = undefined;
				}
				node._changeSelectStatusAttrs(state);
				return state;
			}
			_walk(this);

			// Update parent's state
			this.visitParents(function(node) {
				var i,
					l,
					child,
					state,
					unselIgnore,
					unselState,
					children = node.children,
					allSelected = true,
					someSelected = false;

				for (i = 0, l = children.length; i < l; i++) {
					child = children[i];
					unselIgnore = FT.evalOption(
						"unselectableIgnore",
						child,
						child,
						opts,
						false
					);
					if (!unselIgnore) {
						unselState = FT.evalOption(
							"unselectableStatus",
							child,
							child,
							opts,
							undefined
						);
						state =
							unselState == null
								? !!child.selected
								: !!unselState;
						// When fixing the parents, we trust the sibling status (i.e.
						// we don't recurse)
						if (state || child.partsel) {
							someSelected = true;
						}
						if (!state) {
							allSelected = false;
						}
					}
				}
				// eslint-disable-next-line no-nested-ternary
				state = allSelected ? true : someSelected ? undefined : false;
				node._changeSelectStatusAttrs(state);
			});
		},
		// TODO: focus()
		/**
		 * Update node data. If dict contains 'children', then also replace
		 * the hole sub tree.
		 * @param {NodeData} dict
		 *
		 * @see FancytreeNode#addChildren
		 * @see FancytreeNode#applyPatch
		 */
		fromDict: function(dict) {
			// copy all other attributes to this.data.xxx
			for (var name in dict) {
				if (NODE_ATTR_MAP[name]) {
					// node.NAME = dict.NAME
					this[name] = dict[name];
				} else if (name === "data") {
					// node.data += dict.data
					$.extend(this.data, dict.data);
				} else if (
					!$.isFunction(dict[name]) &&
					!NONE_NODE_DATA_MAP[name]
				) {
					// node.data.NAME = dict.NAME
					this.data[name] = dict[name];
				}
			}
			if (dict.children) {
				// recursively set children and render
				this.removeChildren();
				this.addChildren(dict.children);
			}
			this.renderTitle();
			/*
			var children = dict.children;
			if(children === undefined){
				this.data = $.extend(this.data, dict);
				this.render();
				return;
			}
			dict = $.extend({}, dict);
			dict.children = undefined;
			this.data = $.extend(this.data, dict);
			this.removeChildren();
			this.addChild(children);
			*/
		},
		/** Return the list of child nodes (undefined for unexpanded lazy nodes).
		 * @returns {FancytreeNode[] | undefined}
		 */
		getChildren: function() {
			if (this.hasChildren() === undefined) {
				// TODO: only required for lazy nodes?
				return undefined; // Lazy node: unloaded, currently loading, or load error
			}
			return this.children;
		},
		/** Return the first child node or null.
		 * @returns {FancytreeNode | null}
		 */
		getFirstChild: function() {
			return this.children ? this.children[0] : null;
		},
		/** Return the 0-based child index.
		 * @returns {int}
		 */
		getIndex: function() {
			// return this.parent.children.indexOf(this);
			return $.inArray(this, this.parent.children); // indexOf doesn't work in IE7
		},
		/** Return the hierarchical child index (1-based, e.g. '3.2.4').
		 * @param {string} [separator="."]
		 * @param {int} [digits=1]
		 * @returns {string}
		 */
		getIndexHier: function(separator, digits) {
			separator = separator || ".";
			var s,
				res = [];
			$.each(this.getParentList(false, true), function(i, o) {
				s = "" + (o.getIndex() + 1);
				if (digits) {
					// prepend leading zeroes
					s = ("0000000" + s).substr(-digits);
				}
				res.push(s);
			});
			return res.join(separator);
		},
		/** Return the parent keys separated by options.keyPathSeparator, e.g. "/id_1/id_17/id_32".
		 *
		 * (Unlike `node.getPath()`, this method prepends a "/" and inverts the first argument.)
		 *
		 * @see FancytreeNode#getPath
		 * @param {boolean} [excludeSelf=false]
		 * @returns {string}
		 */
		getKeyPath: function(excludeSelf) {
			var sep = this.tree.options.keyPathSeparator;

			return sep + this.getPath(!excludeSelf, "key", sep);
		},
		/** Return the last child of this node or null.
		 * @returns {FancytreeNode | null}
		 */
		getLastChild: function() {
			return this.children
				? this.children[this.children.length - 1]
				: null;
		},
		/** Return node depth. 0: System root node, 1: visible top-level node, 2: first sub-level, ... .
		 * @returns {int}
		 */
		getLevel: function() {
			var level = 0,
				dtn = this.parent;
			while (dtn) {
				level++;
				dtn = dtn.parent;
			}
			return level;
		},
		/** Return the successor node (under the same parent) or null.
		 * @returns {FancytreeNode | null}
		 */
		getNextSibling: function() {
			// TODO: use indexOf, if available: (not in IE6)
			if (this.parent) {
				var i,
					l,
					ac = this.parent.children;

				for (i = 0, l = ac.length - 1; i < l; i++) {
					// up to length-2, so next(last) = null
					if (ac[i] === this) {
						return ac[i + 1];
					}
				}
			}
			return null;
		},
		/** Return the parent node (null for the system root node).
		 * @returns {FancytreeNode | null}
		 */
		getParent: function() {
			// TODO: return null for top-level nodes?
			return this.parent;
		},
		/** Return an array of all parent nodes (top-down).
		 * @param {boolean} [includeRoot=false] Include the invisible system root node.
		 * @param {boolean} [includeSelf=false] Include the node itself.
		 * @returns {FancytreeNode[]}
		 */
		getParentList: function(includeRoot, includeSelf) {
			var l = [],
				dtn = includeSelf ? this : this.parent;
			while (dtn) {
				if (includeRoot || dtn.parent) {
					l.unshift(dtn);
				}
				dtn = dtn.parent;
			}
			return l;
		},
		/** Return a string representing the hierachical node path, e.g. "a/b/c".
		 * @param {boolean} [includeSelf=true]
		 * @param {string | function} [part="title"] node property name or callback
		 * @param {string} [separator="/"]
		 * @returns {string}
		 * @since v2.31
		 */
		getPath: function(includeSelf, part, separator) {
			includeSelf = includeSelf !== false;
			part = part || "title";
			separator = separator || "/";

			var val,
				path = [],
				isFunc = $.isFunction(part);

			this.visitParents(function(n) {
				if (n.parent) {
					val = isFunc ? part(n) : n[part];
					path.unshift(val);
				}
			}, includeSelf);
			return path.join(separator);
		},
		/** Return the predecessor node (under the same parent) or null.
		 * @returns {FancytreeNode | null}
		 */
		getPrevSibling: function() {
			if (this.parent) {
				var i,
					l,
					ac = this.parent.children;

				for (i = 1, l = ac.length; i < l; i++) {
					// start with 1, so prev(first) = null
					if (ac[i] === this) {
						return ac[i - 1];
					}
				}
			}
			return null;
		},
		/**
		 * Return an array of selected descendant nodes.
		 * @param {boolean} [stopOnParents=false] only return the topmost selected
		 *     node (useful with selectMode 3)
		 * @returns {FancytreeNode[]}
		 */
		getSelectedNodes: function(stopOnParents) {
			var nodeList = [];
			this.visit(function(node) {
				if (node.selected) {
					nodeList.push(node);
					if (stopOnParents === true) {
						return "skip"; // stop processing this branch
					}
				}
			});
			return nodeList;
		},
		/** Return true if node has children. Return undefined if not sure, i.e. the node is lazy and not yet loaded).
		 * @returns {boolean | undefined}
		 */
		hasChildren: function() {
			if (this.lazy) {
				if (this.children == null) {
					// null or undefined: Not yet loaded
					return undefined;
				} else if (this.children.length === 0) {
					// Loaded, but response was empty
					return false;
				} else if (
					this.children.length === 1 &&
					this.children[0].isStatusNode()
				) {
					// Currently loading or load error
					return undefined;
				}
				return true;
			}
			return !!(this.children && this.children.length);
		},
		/**
		 * Return true if node has `className` defined in .extraClasses.
		 *
		 * @param {string} className class name (separate multiple classes by space)
		 * @returns {boolean}
		 *
		 * @since 2.32
		 */
		hasClass: function(className) {
			return (
				(" " + (this.extraClasses || "") + " ").indexOf(
					" " + className + " "
				) >= 0
			);
		},
		/** Return true if node has keyboard focus.
		 * @returns {boolean}
		 */
		hasFocus: function() {
			return this.tree.hasFocus() && this.tree.focusNode === this;
		},
		/** Write to browser console if debugLevel >= 3 (prepending node info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		info: function(msg) {
			if (this.tree.options.debugLevel >= 3) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("info", arguments);
			}
		},
		/** Return true if node is active (see also FancytreeNode#isSelected).
		 * @returns {boolean}
		 */
		isActive: function() {
			return this.tree.activeNode === this;
		},
		/** Return true if node is vertically below `otherNode`, i.e. rendered in a subsequent row.
		 * @param {FancytreeNode} otherNode
		 * @returns {boolean}
		 * @since 2.28
		 */
		isBelowOf: function(otherNode) {
			return this.getIndexHier(".", 5) > otherNode.getIndexHier(".", 5);
		},
		/** Return true if node is a direct child of otherNode.
		 * @param {FancytreeNode} otherNode
		 * @returns {boolean}
		 */
		isChildOf: function(otherNode) {
			return this.parent && this.parent === otherNode;
		},
		/** Return true, if node is a direct or indirect sub node of otherNode.
		 * @param {FancytreeNode} otherNode
		 * @returns {boolean}
		 */
		isDescendantOf: function(otherNode) {
			if (!otherNode || otherNode.tree !== this.tree) {
				return false;
			}
			var p = this.parent;
			while (p) {
				if (p === otherNode) {
					return true;
				}
				if (p === p.parent) {
					$.error("Recursive parent link: " + p);
				}
				p = p.parent;
			}
			return false;
		},
		/** Return true if node is expanded.
		 * @returns {boolean}
		 */
		isExpanded: function() {
			return !!this.expanded;
		},
		/** Return true if node is the first node of its parent's children.
		 * @returns {boolean}
		 */
		isFirstSibling: function() {
			var p = this.parent;
			return !p || p.children[0] === this;
		},
		/** Return true if node is a folder, i.e. has the node.folder attribute set.
		 * @returns {boolean}
		 */
		isFolder: function() {
			return !!this.folder;
		},
		/** Return true if node is the last node of its parent's children.
		 * @returns {boolean}
		 */
		isLastSibling: function() {
			var p = this.parent;
			return !p || p.children[p.children.length - 1] === this;
		},
		/** Return true if node is lazy (even if data was already loaded)
		 * @returns {boolean}
		 */
		isLazy: function() {
			return !!this.lazy;
		},
		/** Return true if node is lazy and loaded. For non-lazy nodes always return true.
		 * @returns {boolean}
		 */
		isLoaded: function() {
			return !this.lazy || this.hasChildren() !== undefined; // Also checks if the only child is a status node
		},
		/** Return true if children are currently beeing loaded, i.e. a Ajax request is pending.
		 * @returns {boolean}
		 */
		isLoading: function() {
			return !!this._isLoading;
		},
		/*
		 * @deprecated since v2.4.0:  Use isRootNode() instead
		 */
		isRoot: function() {
			return this.isRootNode();
		},
		/** Return true if node is partially selected (tri-state).
		 * @returns {boolean}
		 * @since 2.23
		 */
		isPartsel: function() {
			return !this.selected && !!this.partsel;
		},
		/** (experimental) Return true if this is partially loaded.
		 * @returns {boolean}
		 * @since 2.15
		 */
		isPartload: function() {
			return !!this.partload;
		},
		/** Return true if this is the (invisible) system root node.
		 * @returns {boolean}
		 * @since 2.4
		 */
		isRootNode: function() {
			return this.tree.rootNode === this;
		},
		/** Return true if node is selected, i.e. has a checkmark set (see also FancytreeNode#isActive).
		 * @returns {boolean}
		 */
		isSelected: function() {
			return !!this.selected;
		},
		/** Return true if this node is a temporarily generated system node like
		 * 'loading', 'paging', or 'error' (node.statusNodeType contains the type).
		 * @returns {boolean}
		 */
		isStatusNode: function() {
			return !!this.statusNodeType;
		},
		/** Return true if this node is a status node of type 'paging'.
		 * @returns {boolean}
		 * @since 2.15
		 */
		isPagingNode: function() {
			return this.statusNodeType === "paging";
		},
		/** Return true if this a top level node, i.e. a direct child of the (invisible) system root node.
		 * @returns {boolean}
		 * @since 2.4
		 */
		isTopLevel: function() {
			return this.tree.rootNode === this.parent;
		},
		/** Return true if node is lazy and not yet loaded. For non-lazy nodes always return false.
		 * @returns {boolean}
		 */
		isUndefined: function() {
			return this.hasChildren() === undefined; // also checks if the only child is a status node
		},
		/** Return true if all parent nodes are expanded. Note: this does not check
		 * whether the node is scrolled into the visible part of the screen.
		 * @returns {boolean}
		 */
		isVisible: function() {
			var i,
				l,
				n,
				hasFilter = this.tree.enableFilter,
				parents = this.getParentList(false, false);

			// TODO: check $(n.span).is(":visible")
			// i.e. return false for nodes (but not parents) that are hidden
			// by a filter
			if (hasFilter && !this.match && !this.subMatchCount) {
				// this.debug( "isVisible: HIDDEN (" + hasFilter + ", " + this.match + ", " + this.match + ")" );
				return false;
			}

			for (i = 0, l = parents.length; i < l; i++) {
				n = parents[i];

				if (!n.expanded) {
					// this.debug("isVisible: HIDDEN (parent collapsed)");
					return false;
				}
				// if (hasFilter && !n.match && !n.subMatchCount) {
				// 	this.debug("isVisible: HIDDEN (" + hasFilter + ", " + this.match + ", " + this.match + ")");
				// 	return false;
				// }
			}
			// this.debug("isVisible: VISIBLE");
			return true;
		},
		/** Deprecated.
		 * @deprecated since 2014-02-16: use load() instead.
		 */
		lazyLoad: function(discard) {
			this.warn(
				"FancytreeNode.lazyLoad() is deprecated since 2014-02-16. Use .load() instead."
			);
			return this.load(discard);
		},
		/**
		 * Load all children of a lazy node if neccessary. The <i>expanded</i> state is maintained.
		 * @param {boolean} [forceReload=false] Pass true to discard any existing nodes before. Otherwise this method does nothing if the node was already loaded.
		 * @returns {$.Promise}
		 */
		load: function(forceReload) {
			var res,
				source,
				self = this,
				wasExpanded = this.isExpanded();

			_assert(this.isLazy(), "load() requires a lazy node");
			// _assert( forceReload || this.isUndefined(), "Pass forceReload=true to re-load a lazy node" );
			if (!forceReload && !this.isUndefined()) {
				return _getResolvedPromise(this);
			}
			if (this.isLoaded()) {
				this.resetLazy(); // also collapses
			}
			// This method is also called by setExpanded() and loadKeyPath(), so we
			// have to avoid recursion.
			source = this.tree._triggerNodeEvent("lazyLoad", this);
			if (source === false) {
				// #69
				return _getResolvedPromise(this);
			}
			_assert(
				typeof source !== "boolean",
				"lazyLoad event must return source in data.result"
			);
			res = this.tree._callHook("nodeLoadChildren", this, source);
			if (wasExpanded) {
				this.expanded = true;
				res.always(function() {
					self.render();
				});
			} else {
				res.always(function() {
					self.renderStatus(); // fix expander icon to 'loaded'
				});
			}
			return res;
		},
		/** Expand all parents and optionally scroll into visible area as neccessary.
		 * Promise is resolved, when lazy loading and animations are done.
		 * @param {object} [opts] passed to `setExpanded()`.
		 *     Defaults to {noAnimation: false, noEvents: false, scrollIntoView: true}
		 * @returns {$.Promise}
		 */
		makeVisible: function(opts) {
			var i,
				self = this,
				deferreds = [],
				dfd = new $.Deferred(),
				parents = this.getParentList(false, false),
				len = parents.length,
				effects = !(opts && opts.noAnimation === true),
				scroll = !(opts && opts.scrollIntoView === false);

			// Expand bottom-up, so only the top node is animated
			for (i = len - 1; i >= 0; i--) {
				// self.debug("pushexpand" + parents[i]);
				deferreds.push(parents[i].setExpanded(true, opts));
			}
			$.when.apply($, deferreds).done(function() {
				// All expands have finished
				// self.debug("expand DONE", scroll);
				if (scroll) {
					self.scrollIntoView(effects).done(function() {
						// self.debug("scroll DONE");
						dfd.resolve();
					});
				} else {
					dfd.resolve();
				}
			});
			return dfd.promise();
		},
		/** Move this node to targetNode.
		 *  @param {FancytreeNode} targetNode
		 *  @param {string} mode <pre>
		 *      'child': append this node as last child of targetNode.
		 *               This is the default. To be compatble with the D'n'd
		 *               hitMode, we also accept 'over'.
		 *      'firstChild': add this node as first child of targetNode.
		 *      'before': add this node as sibling before targetNode.
		 *      'after': add this node as sibling after targetNode.</pre>
		 *  @param {function} [map] optional callback(FancytreeNode) to allow modifcations
		 */
		moveTo: function(targetNode, mode, map) {
			if (mode === undefined || mode === "over") {
				mode = "child";
			} else if (mode === "firstChild") {
				if (targetNode.children && targetNode.children.length) {
					mode = "before";
					targetNode = targetNode.children[0];
				} else {
					mode = "child";
				}
			}
			var pos,
				tree = this.tree,
				prevParent = this.parent,
				targetParent =
					mode === "child" ? targetNode : targetNode.parent;

			if (this === targetNode) {
				return;
			} else if (!this.parent) {
				$.error("Cannot move system root");
			} else if (targetParent.isDescendantOf(this)) {
				$.error("Cannot move a node to its own descendant");
			}
			if (targetParent !== prevParent) {
				prevParent.triggerModifyChild("remove", this);
			}
			// Unlink this node from current parent
			if (this.parent.children.length === 1) {
				if (this.parent === targetParent) {
					return; // #258
				}
				this.parent.children = this.parent.lazy ? [] : null;
				this.parent.expanded = false;
			} else {
				pos = $.inArray(this, this.parent.children);
				_assert(pos >= 0, "invalid source parent");
				this.parent.children.splice(pos, 1);
			}
			// Remove from source DOM parent
			// if(this.parent.ul){
			// 	this.parent.ul.removeChild(this.li);
			// }

			// Insert this node to target parent's child list
			this.parent = targetParent;
			if (targetParent.hasChildren()) {
				switch (mode) {
					case "child":
						// Append to existing target children
						targetParent.children.push(this);
						break;
					case "before":
						// Insert this node before target node
						pos = $.inArray(targetNode, targetParent.children);
						_assert(pos >= 0, "invalid target parent");
						targetParent.children.splice(pos, 0, this);
						break;
					case "after":
						// Insert this node after target node
						pos = $.inArray(targetNode, targetParent.children);
						_assert(pos >= 0, "invalid target parent");
						targetParent.children.splice(pos + 1, 0, this);
						break;
					default:
						$.error("Invalid mode " + mode);
				}
			} else {
				targetParent.children = [this];
			}
			// Parent has no <ul> tag yet:
			// if( !targetParent.ul ) {
			// 	// This is the parent's first child: create UL tag
			// 	// (Hidden, because it will be
			// 	targetParent.ul = document.createElement("ul");
			// 	targetParent.ul.style.display = "none";
			// 	targetParent.li.appendChild(targetParent.ul);
			// }
			// // Issue 319: Add to target DOM parent (only if node was already rendered(expanded))
			// if(this.li){
			// 	targetParent.ul.appendChild(this.li);
			// }

			// Let caller modify the nodes
			if (map) {
				targetNode.visit(map, true);
			}
			if (targetParent === prevParent) {
				targetParent.triggerModifyChild("move", this);
			} else {
				// prevParent.triggerModifyChild("remove", this);
				targetParent.triggerModifyChild("add", this);
			}
			// Handle cross-tree moves
			if (tree !== targetNode.tree) {
				// Fix node.tree for all source nodes
				// 	_assert(false, "Cross-tree move is not yet implemented.");
				this.warn("Cross-tree moveTo is experimental!");
				this.visit(function(n) {
					// TODO: fix selection state and activation, ...
					n.tree = targetNode.tree;
				}, true);
			}

			// A collaposed node won't re-render children, so we have to remove it manually
			// if( !targetParent.expanded ){
			//   prevParent.ul.removeChild(this.li);
			// }
			tree._callHook("treeStructureChanged", tree, "moveTo");

			// Update HTML markup
			if (!prevParent.isDescendantOf(targetParent)) {
				prevParent.render();
			}
			if (
				!targetParent.isDescendantOf(prevParent) &&
				targetParent !== prevParent
			) {
				targetParent.render();
			}
			// TODO: fix selection state
			// TODO: fix active state

			/*
			var tree = this.tree;
			var opts = tree.options;
			var pers = tree.persistence;

			// Always expand, if it's below minExpandLevel
			// tree.logDebug ("%s._addChildNode(%o), l=%o", this, ftnode, ftnode.getLevel());
			if ( opts.minExpandLevel >= ftnode.getLevel() ) {
				// tree.logDebug ("Force expand for %o", ftnode);
				this.bExpanded = true;
			}

			// In multi-hier mode, update the parents selection state
			// DT issue #82: only if not initializing, because the children may not exist yet
			// if( !ftnode.data.isStatusNode() && opts.selectMode==3 && !isInitializing )
			// 	ftnode._fixSelectionState();

			// In multi-hier mode, update the parents selection state
			if( ftnode.bSelected && opts.selectMode==3 ) {
				var p = this;
				while( p ) {
					if( !p.hasSubSel )
						p._setSubSel(true);
					p = p.parent;
				}
			}
			// render this node and the new child
			if ( tree.bEnableUpdate )
				this.render();
			return ftnode;
			*/
		},
		/** Set focus relative to this node and optionally activate.
		 *
		 * 'left' collapses the node if it is expanded, or move to the parent
		 * otherwise.
		 * 'right' expands the node if it is collapsed, or move to the first
		 * child otherwise.
		 *
		 * @param {string|number} where 'down', 'first', 'last', 'left', 'parent', 'right', or 'up'.
		 *   (Alternatively the keyCode that would normally trigger this move,
		 *   e.g. `$.ui.keyCode.LEFT` = 'left'.
		 * @param {boolean} [activate=true]
		 * @returns {$.Promise}
		 */
		navigate: function(where, activate) {
			var node,
				KC = $.ui.keyCode;

			// Handle optional expand/collapse action for LEFT/RIGHT
			switch (where) {
				case "left":
				case KC.LEFT:
					if (this.expanded) {
						return this.setExpanded(false);
					}
					break;
				case "right":
				case KC.RIGHT:
					if (!this.expanded && (this.children || this.lazy)) {
						return this.setExpanded();
					}
					break;
			}
			// Otherwise activate or focus the related node
			node = this.findRelatedNode(where);
			if (node) {
				// setFocus/setActive will scroll later (if autoScroll is specified)
				try {
					node.makeVisible({ scrollIntoView: false });
				} catch (e) {} // #272
				if (activate === false) {
					node.setFocus();
					return _getResolvedPromise();
				}
				return node.setActive();
			}
			this.warn("Could not find related node '" + where + "'.");
			return _getResolvedPromise();
		},
		/**
		 * Remove this node (not allowed for system root).
		 */
		remove: function() {
			return this.parent.removeChild(this);
		},
		/**
		 * Remove childNode from list of direct children.
		 * @param {FancytreeNode} childNode
		 */
		removeChild: function(childNode) {
			return this.tree._callHook("nodeRemoveChild", this, childNode);
		},
		/**
		 * Remove all child nodes and descendents. This converts the node into a leaf.<br>
		 * If this was a lazy node, it is still considered 'loaded'; call node.resetLazy()
		 * in order to trigger lazyLoad on next expand.
		 */
		removeChildren: function() {
			return this.tree._callHook("nodeRemoveChildren", this);
		},
		/**
		 * Remove class from node's span tag and .extraClasses.
		 *
		 * @param {string} className class name
		 *
		 * @since 2.17
		 */
		removeClass: function(className) {
			return this.toggleClass(className, false);
		},
		/**
		 * This method renders and updates all HTML markup that is required
		 * to display this node in its current state.<br>
		 * Note:
		 * <ul>
		 * <li>It should only be neccessary to call this method after the node object
		 *     was modified by direct access to its properties, because the common
		 *     API methods (node.setTitle(), moveTo(), addChildren(), remove(), ...)
		 *     already handle this.
		 * <li> {@link FancytreeNode#renderTitle} and {@link FancytreeNode#renderStatus}
		 *     are implied. If changes are more local, calling only renderTitle() or
		 *     renderStatus() may be sufficient and faster.
		 * </ul>
		 *
		 * @param {boolean} [force=false] re-render, even if html markup was already created
		 * @param {boolean} [deep=false] also render all descendants, even if parent is collapsed
		 */
		render: function(force, deep) {
			return this.tree._callHook("nodeRender", this, force, deep);
		},
		/** Create HTML markup for the node's outer `<span>` (expander, checkbox, icon, and title).
		 * Implies {@link FancytreeNode#renderStatus}.
		 * @see Fancytree_Hooks#nodeRenderTitle
		 */
		renderTitle: function() {
			return this.tree._callHook("nodeRenderTitle", this);
		},
		/** Update element's CSS classes according to node state.
		 * @see Fancytree_Hooks#nodeRenderStatus
		 */
		renderStatus: function() {
			return this.tree._callHook("nodeRenderStatus", this);
		},
		/**
		 * (experimental) Replace this node with `source`.
		 * (Currently only available for paging nodes.)
		 * @param {NodeData[]} source List of child node definitions
		 * @since 2.15
		 */
		replaceWith: function(source) {
			var res,
				parent = this.parent,
				pos = $.inArray(this, parent.children),
				self = this;

			_assert(
				this.isPagingNode(),
				"replaceWith() currently requires a paging status node"
			);

			res = this.tree._callHook("nodeLoadChildren", this, source);
			res.done(function(data) {
				// New nodes are currently children of `this`.
				var children = self.children;
				// Prepend newly loaded child nodes to `this`
				// Move new children after self
				for (i = 0; i < children.length; i++) {
					children[i].parent = parent;
				}
				parent.children.splice.apply(
					parent.children,
					[pos + 1, 0].concat(children)
				);

				// Remove self
				self.children = null;
				self.remove();
				// Redraw new nodes
				parent.render();
				// TODO: set node.partload = false if this was tha last paging node?
				// parent.addPagingNode(false);
			}).fail(function() {
				self.setExpanded();
			});
			return res;
			// $.error("Not implemented: replaceWith()");
		},
		/**
		 * Remove all children, collapse, and set the lazy-flag, so that the lazyLoad
		 * event is triggered on next expand.
		 */
		resetLazy: function() {
			this.removeChildren();
			this.expanded = false;
			this.lazy = true;
			this.children = undefined;
			this.renderStatus();
		},
		/** Schedule activity for delayed execution (cancel any pending request).
		 *  scheduleAction('cancel') will only cancel a pending request (if any).
		 * @param {string} mode
		 * @param {number} ms
		 */
		scheduleAction: function(mode, ms) {
			if (this.tree.timer) {
				clearTimeout(this.tree.timer);
				this.tree.debug("clearTimeout(%o)", this.tree.timer);
			}
			this.tree.timer = null;
			var self = this; // required for closures
			switch (mode) {
				case "cancel":
					// Simply made sure that timer was cleared
					break;
				case "expand":
					this.tree.timer = setTimeout(function() {
						self.tree.debug("setTimeout: trigger expand");
						self.setExpanded(true);
					}, ms);
					break;
				case "activate":
					this.tree.timer = setTimeout(function() {
						self.tree.debug("setTimeout: trigger activate");
						self.setActive(true);
					}, ms);
					break;
				default:
					$.error("Invalid mode " + mode);
			}
			// this.tree.debug("setTimeout(%s, %s): %s", mode, ms, this.tree.timer);
		},
		/**
		 *
		 * @param {boolean | PlainObject} [effects=false] animation options.
		 * @param {object} [options=null] {topNode: null, effects: ..., parent: ...} this node will remain visible in
		 *     any case, even if `this` is outside the scroll pane.
		 * @returns {$.Promise}
		 */
		scrollIntoView: function(effects, options) {
			if (options !== undefined && _isNode(options)) {
				throw Error(
					"scrollIntoView() with 'topNode' option is deprecated since 2014-05-08. Use 'options.topNode' instead."
				);
			}
			// The scroll parent is typically the plain tree's <UL> container.
			// For ext-table, we choose the nearest parent that has `position: relative`
			// and `overflow` set.
			// (This default can be overridden by the local or global `scrollParent` option.)
			var opts = $.extend(
					{
						effects:
							effects === true
								? { duration: 200, queue: false }
								: effects,
						scrollOfs: this.tree.options.scrollOfs,
						scrollParent: this.tree.options.scrollParent,
						topNode: null,
					},
					options
				),
				$scrollParent = opts.scrollParent,
				$container = this.tree.$container,
				overflowY = $container.css("overflow-y");

			if (!$scrollParent) {
				if (this.tree.tbody) {
					$scrollParent = $container.scrollParent();
				} else if (overflowY === "scroll" || overflowY === "auto") {
					$scrollParent = $container;
				} else {
					// #922 plain tree in a non-fixed-sized UL scrolls inside its parent
					$scrollParent = $container.scrollParent();
				}
			} else if (!$scrollParent.jquery) {
				// Make sure we have a jQuery object
				$scrollParent = $($scrollParent);
			}
			if (
				$scrollParent[0] === document ||
				$scrollParent[0] === document.body
			) {
				// `document` may be returned by $().scrollParent(), if nothing is found,
				// but would not work: (see #894)
				this.debug(
					"scrollIntoView(): normalizing scrollParent to 'window':",
					$scrollParent[0]
				);
				$scrollParent = $(window);
			}
			// eslint-disable-next-line one-var
			var topNodeY,
				nodeY,
				horzScrollbarHeight,
				containerOffsetTop,
				dfd = new $.Deferred(),
				self = this,
				nodeHeight = $(this.span).height(),
				topOfs = opts.scrollOfs.top || 0,
				bottomOfs = opts.scrollOfs.bottom || 0,
				containerHeight = $scrollParent.height(),
				scrollTop = $scrollParent.scrollTop(),
				$animateTarget = $scrollParent,
				isParentWindow = $scrollParent[0] === window,
				topNode = opts.topNode || null,
				newScrollTop = null;

			// this.debug("scrollIntoView(), scrollTop=" + scrollTop, opts.scrollOfs);
			// _assert($(this.span).is(":visible"), "scrollIntoView node is invisible"); // otherwise we cannot calc offsets
			if (!this.isVisible()) {
				// We cannot calc offsets for hidden elements
				this.warn("scrollIntoView(): node is invisible.");
				return _getResolvedPromise();
			}
			if (isParentWindow) {
				nodeY = $(this.span).offset().top;
				topNodeY =
					topNode && topNode.span ? $(topNode.span).offset().top : 0;
				$animateTarget = $("html,body");
			} else {
				_assert(
					$scrollParent[0] !== document &&
						$scrollParent[0] !== document.body,
					"scrollParent should be a simple element or `window`, not document or body."
				);

				containerOffsetTop = $scrollParent.offset().top;
				nodeY =
					$(this.span).offset().top - containerOffsetTop + scrollTop; // relative to scroll parent
				topNodeY = topNode
					? $(topNode.span).offset().top -
					  containerOffsetTop +
					  scrollTop
					: 0;
				horzScrollbarHeight = Math.max(
					0,
					$scrollParent.innerHeight() - $scrollParent[0].clientHeight
				);
				containerHeight -= horzScrollbarHeight;
			}

			// this.debug("    scrollIntoView(), nodeY=" + nodeY + ", containerHeight=" + containerHeight);
			if (nodeY < scrollTop + topOfs) {
				// Node is above visible container area
				newScrollTop = nodeY - topOfs;
				// this.debug("    scrollIntoView(), UPPER newScrollTop=" + newScrollTop);
			} else if (
				nodeY + nodeHeight >
				scrollTop + containerHeight - bottomOfs
			) {
				newScrollTop = nodeY + nodeHeight - containerHeight + bottomOfs;
				// this.debug("    scrollIntoView(), LOWER newScrollTop=" + newScrollTop);
				// If a topNode was passed, make sure that it is never scrolled
				// outside the upper border
				if (topNode) {
					_assert(
						topNode.isRootNode() || topNode.isVisible(),
						"topNode must be visible"
					);
					if (topNodeY < newScrollTop) {
						newScrollTop = topNodeY - topOfs;
						// this.debug("    scrollIntoView(), TOP newScrollTop=" + newScrollTop);
					}
				}
			}

			if (newScrollTop === null) {
				dfd.resolveWith(this);
			} else {
				// this.debug("    scrollIntoView(), SET newScrollTop=" + newScrollTop);
				if (opts.effects) {
					opts.effects.complete = function() {
						dfd.resolveWith(self);
					};
					$animateTarget.stop(true).animate(
						{
							scrollTop: newScrollTop,
						},
						opts.effects
					);
				} else {
					$animateTarget[0].scrollTop = newScrollTop;
					dfd.resolveWith(this);
				}
			}
			return dfd.promise();
		},

		/**Activate this node.
		 *
		 * The `cell` option requires the ext-table and ext-ariagrid extensions.
		 *
		 * @param {boolean} [flag=true] pass false to deactivate
		 * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false, cell: null}
		 * @returns {$.Promise}
		 */
		setActive: function(flag, opts) {
			return this.tree._callHook("nodeSetActive", this, flag, opts);
		},
		/**Expand or collapse this node. Promise is resolved, when lazy loading and animations are done.
		 * @param {boolean} [flag=true] pass false to collapse
		 * @param {object} [opts] additional options. Defaults to {noAnimation: false, noEvents: false}
		 * @returns {$.Promise}
		 */
		setExpanded: function(flag, opts) {
			return this.tree._callHook("nodeSetExpanded", this, flag, opts);
		},
		/**Set keyboard focus to this node.
		 * @param {boolean} [flag=true] pass false to blur
		 * @see Fancytree#setFocus
		 */
		setFocus: function(flag) {
			return this.tree._callHook("nodeSetFocus", this, flag);
		},
		/**Select this node, i.e. check the checkbox.
		 * @param {boolean} [flag=true] pass false to deselect
		 * @param {object} [opts] additional options. Defaults to {noEvents: false, p
		 *     propagateDown: null, propagateUp: null, callback: null }
		 */
		setSelected: function(flag, opts) {
			return this.tree._callHook("nodeSetSelected", this, flag, opts);
		},
		/**Mark a lazy node as 'error', 'loading', 'nodata', or 'ok'.
		 * @param {string} status 'error'|'empty'|'ok'
		 * @param {string} [message]
		 * @param {string} [details]
		 */
		setStatus: function(status, message, details) {
			return this.tree._callHook(
				"nodeSetStatus",
				this,
				status,
				message,
				details
			);
		},
		/**Rename this node.
		 * @param {string} title
		 */
		setTitle: function(title) {
			this.title = title;
			this.renderTitle();
			this.triggerModify("rename");
		},
		/**Sort child list by title.
		 * @param {function} [cmp] custom compare function(a, b) that returns -1, 0, or 1 (defaults to sort by title).
		 * @param {boolean} [deep=false] pass true to sort all descendant nodes
		 */
		sortChildren: function(cmp, deep) {
			var i,
				l,
				cl = this.children;

			if (!cl) {
				return;
			}
			cmp =
				cmp ||
				function(a, b) {
					var x = a.title.toLowerCase(),
						y = b.title.toLowerCase();

					// eslint-disable-next-line no-nested-ternary
					return x === y ? 0 : x > y ? 1 : -1;
				};
			cl.sort(cmp);
			if (deep) {
				for (i = 0, l = cl.length; i < l; i++) {
					if (cl[i].children) {
						cl[i].sortChildren(cmp, "$norender$");
					}
				}
			}
			if (deep !== "$norender$") {
				this.render();
			}
			this.triggerModifyChild("sort");
		},
		/** Convert node (or whole branch) into a plain object.
		 *
		 * The result is compatible with node.addChildren().
		 *
		 * @param {boolean} [recursive=false] include child nodes
		 * @param {function} [callback] callback(dict, node) is called for every node, in order to allow modifications.
		 *     Return `false` to ignore this node or "skip" to include this node without its children.
		 * @returns {NodeData}
		 */
		toDict: function(recursive, callback) {
			var i,
				l,
				node,
				res,
				dict = {},
				self = this;

			$.each(NODE_ATTRS, function(i, a) {
				if (self[a] || self[a] === false) {
					dict[a] = self[a];
				}
			});
			if (!$.isEmptyObject(this.data)) {
				dict.data = $.extend({}, this.data);
				if ($.isEmptyObject(dict.data)) {
					delete dict.data;
				}
			}
			if (callback) {
				res = callback(dict, self);
				if (res === false) {
					return false; // Don't include this node nor its children
				}
				if (res === "skip") {
					recursive = false; // Include this node, but not the children
				}
			}
			if (recursive) {
				if (this.hasChildren()) {
					dict.children = [];
					for (i = 0, l = this.children.length; i < l; i++) {
						node = this.children[i];
						if (!node.isStatusNode()) {
							res = node.toDict(true, callback);
							if (res !== false) {
								dict.children.push(res);
							}
						}
					}
				}
			}
			return dict;
		},
		/**
		 * Set, clear, or toggle class of node's span tag and .extraClasses.
		 *
		 * @param {string} className class name (separate multiple classes by space)
		 * @param {boolean} [flag] true/false to add/remove class. If omitted, class is toggled.
		 * @returns {boolean} true if a class was added
		 *
		 * @since 2.17
		 */
		toggleClass: function(value, flag) {
			var className,
				hasClass,
				rnotwhite = /\S+/g,
				classNames = value.match(rnotwhite) || [],
				i = 0,
				wasAdded = false,
				statusElem = this[this.tree.statusClassPropName],
				curClasses = " " + (this.extraClasses || "") + " ";

			// this.info("toggleClass('" + value + "', " + flag + ")", curClasses);
			// Modify DOM element directly if it already exists
			if (statusElem) {
				$(statusElem).toggleClass(value, flag);
			}
			// Modify node.extraClasses to make this change persistent
			// Toggle if flag was not passed
			while ((className = classNames[i++])) {
				hasClass = curClasses.indexOf(" " + className + " ") >= 0;
				flag = flag === undefined ? !hasClass : !!flag;
				if (flag) {
					if (!hasClass) {
						curClasses += className + " ";
						wasAdded = true;
					}
				} else {
					while (curClasses.indexOf(" " + className + " ") > -1) {
						curClasses = curClasses.replace(
							" " + className + " ",
							" "
						);
					}
				}
			}
			this.extraClasses = $.trim(curClasses);
			// this.info("-> toggleClass('" + value + "', " + flag + "): '" + this.extraClasses + "'");
			return wasAdded;
		},
		/** Flip expanded status. */
		toggleExpanded: function() {
			return this.tree._callHook("nodeToggleExpanded", this);
		},
		/** Flip selection status. */
		toggleSelected: function() {
			return this.tree._callHook("nodeToggleSelected", this);
		},
		toString: function() {
			return "FancytreeNode@" + this.key + "[title='" + this.title + "']";
			// return "<FancytreeNode(#" + this.key + ", '" + this.title + "')>";
		},
		/**
		 * Trigger `modifyChild` event on a parent to signal that a child was modified.
		 * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...
		 * @param {FancytreeNode} [childNode]
		 * @param {object} [extra]
		 */
		triggerModifyChild: function(operation, childNode, extra) {
			var data,
				modifyChild = this.tree.options.modifyChild;

			if (modifyChild) {
				if (childNode && childNode.parent !== this) {
					$.error(
						"childNode " + childNode + " is not a child of " + this
					);
				}
				data = {
					node: this,
					tree: this.tree,
					operation: operation,
					childNode: childNode || null,
				};
				if (extra) {
					$.extend(data, extra);
				}
				modifyChild({ type: "modifyChild" }, data);
			}
		},
		/**
		 * Trigger `modifyChild` event on node.parent(!).
		 * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...
		 * @param {object} [extra]
		 */
		triggerModify: function(operation, extra) {
			this.parent.triggerModifyChild(operation, this, extra);
		},
		/** Call fn(node) for all child nodes in hierarchical order (depth-first).<br>
		 * Stop iteration, if fn() returns false. Skip current branch, if fn() returns "skip".<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and
		 *     its children only.
		 * @param {boolean} [includeSelf=false]
		 * @returns {boolean}
		 */
		visit: function(fn, includeSelf) {
			var i,
				l,
				res = true,
				children = this.children;

			if (includeSelf === true) {
				res = fn(this);
				if (res === false || res === "skip") {
					return res;
				}
			}
			if (children) {
				for (i = 0, l = children.length; i < l; i++) {
					res = children[i].visit(fn, true);
					if (res === false) {
						break;
					}
				}
			}
			return res;
		},
		/** Call fn(node) for all child nodes and recursively load lazy children.<br>
		 * <b>Note:</b> If you need this method, you probably should consider to review
		 * your architecture! Recursivley loading nodes is a perfect way for lazy
		 * programmers to flood the server with requests ;-)
		 *
		 * @param {function} [fn] optional callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and
		 *     its children only.
		 * @param {boolean} [includeSelf=false]
		 * @returns {$.Promise}
		 * @since 2.4
		 */
		visitAndLoad: function(fn, includeSelf, _recursion) {
			var dfd,
				res,
				loaders,
				node = this;

			// node.debug("visitAndLoad");
			if (fn && includeSelf === true) {
				res = fn(node);
				if (res === false || res === "skip") {
					return _recursion ? res : _getResolvedPromise();
				}
			}
			if (!node.children && !node.lazy) {
				return _getResolvedPromise();
			}
			dfd = new $.Deferred();
			loaders = [];
			// node.debug("load()...");
			node.load().done(function() {
				// node.debug("load()... done.");
				for (var i = 0, l = node.children.length; i < l; i++) {
					res = node.children[i].visitAndLoad(fn, true, true);
					if (res === false) {
						dfd.reject();
						break;
					} else if (res !== "skip") {
						loaders.push(res); // Add promise to the list
					}
				}
				$.when.apply(this, loaders).then(function() {
					dfd.resolve();
				});
			});
			return dfd.promise();
		},
		/** Call fn(node) for all parent nodes, bottom-up, including invisible system root.<br>
		 * Stop iteration, if fn() returns false.<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and children only.
		 * @param {boolean} [includeSelf=false]
		 * @returns {boolean}
		 */
		visitParents: function(fn, includeSelf) {
			// Visit parent nodes (bottom up)
			if (includeSelf && fn(this) === false) {
				return false;
			}
			var p = this.parent;
			while (p) {
				if (fn(p) === false) {
					return false;
				}
				p = p.parent;
			}
			return true;
		},
		/** Call fn(node) for all sibling nodes.<br>
		 * Stop iteration, if fn() returns false.<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration.
		 * @param {boolean} [includeSelf=false]
		 * @returns {boolean}
		 */
		visitSiblings: function(fn, includeSelf) {
			var i,
				l,
				n,
				ac = this.parent.children;

			for (i = 0, l = ac.length; i < l; i++) {
				n = ac[i];
				if (includeSelf || n !== this) {
					if (fn(n) === false) {
						return false;
					}
				}
			}
			return true;
		},
		/** Write warning to browser console if debugLevel >= 2 (prepending node info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		warn: function(msg) {
			if (this.tree.options.debugLevel >= 2) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("warn", arguments);
			}
		},
	};

	/******************************************************************************
	 * Fancytree
	 */
	/**
	 * Construct a new tree object.
	 *
	 * @class Fancytree
	 * @classdesc The controller behind a fancytree.
	 * This class also contains 'hook methods': see {@link Fancytree_Hooks}.
	 *
	 * @param {Widget} widget
	 *
	 * @property {string} _id Automatically generated unique tree instance ID, e.g. "1".
	 * @property {string} _ns Automatically generated unique tree namespace, e.g. ".fancytree-1".
	 * @property {FancytreeNode} activeNode Currently active node or null.
	 * @property {string} ariaPropName Property name of FancytreeNode that contains the element which will receive the aria attributes.
	 *     Typically "li", but "tr" for table extension.
	 * @property {jQueryObject} $container Outer `<ul>` element (or `<table>` element for ext-table).
	 * @property {jQueryObject} $div A jQuery object containing the element used to instantiate the tree widget (`widget.element`)
	 * @property {object|array} columns Recommended place to store shared column meta data. @since 2.27
	 * @property {object} data Metadata, i.e. properties that may be passed to `source` in addition to a children array.
	 * @property {object} ext Hash of all active plugin instances.
	 * @property {FancytreeNode} focusNode Currently focused node or null.
	 * @property {FancytreeNode} lastSelectedNode Used to implement selectMode 1 (single select)
	 * @property {string} nodeContainerAttrName Property name of FancytreeNode that contains the outer element of single nodes.
	 *     Typically "li", but "tr" for table extension.
	 * @property {FancytreeOptions} options Current options, i.e. default options + options passed to constructor.
	 * @property {FancytreeNode} rootNode Invisible system root node.
	 * @property {string} statusClassPropName Property name of FancytreeNode that contains the element which will receive the status classes.
	 *     Typically "span", but "tr" for table extension.
	 * @property {object} types Map for shared type specific meta data, used with node.type attribute. @since 2.27
	 * @property {object} viewport See ext-vieport. @since v2.31
	 * @property {object} widget Base widget instance.
	 */
	function Fancytree(widget) {
		this.widget = widget;
		this.$div = widget.element;
		this.options = widget.options;
		if (this.options) {
			if (this.options.lazyload !== undefined) {
				$.error(
					"The 'lazyload' event is deprecated since 2014-02-25. Use 'lazyLoad' (with uppercase L) instead."
				);
			}
			if (this.options.loaderror !== undefined) {
				$.error(
					"The 'loaderror' event was renamed since 2014-07-03. Use 'loadError' (with uppercase E) instead."
				);
			}
			if (this.options.fx !== undefined) {
				$.error(
					"The 'fx' option was replaced by 'toggleEffect' since 2014-11-30."
				);
			}
			if (this.options.removeNode !== undefined) {
				$.error(
					"The 'removeNode' event was replaced by 'modifyChild' since 2.20 (2016-09-10)."
				);
			}
		}
		this.ext = {}; // Active extension instances
		this.types = {};
		this.columns = {};
		// allow to init tree.data.foo from <div data-foo=''>
		this.data = _getElementDataAsDict(this.$div);
		// TODO: use widget.uuid instead?
		this._id = "" + (this.options.treeId || $.ui.fancytree._nextId++);
		// TODO: use widget.eventNamespace instead?
		this._ns = ".fancytree-" + this._id; // append for namespaced events
		this.activeNode = null;
		this.focusNode = null;
		this._hasFocus = null;
		this._tempCache = {};
		this._lastMousedownNode = null;
		this._enableUpdate = true;
		this.lastSelectedNode = null;
		this.systemFocusElement = null;
		this.lastQuicksearchTerm = "";
		this.lastQuicksearchTime = 0;
		this.viewport = null; // ext-grid

		this.statusClassPropName = "span";
		this.ariaPropName = "li";
		this.nodeContainerAttrName = "li";

		// Remove previous markup if any
		this.$div.find(">ul.fancytree-container").remove();

		// Create a node without parent.
		var fakeParent = { tree: this },
			$ul;
		this.rootNode = new FancytreeNode(fakeParent, {
			title: "root",
			key: "root_" + this._id,
			children: null,
			expanded: true,
		});
		this.rootNode.parent = null;

		// Create root markup
		$ul = $("<ul>", {
			id: "ft-id-" + this._id,
			class: "ui-fancytree fancytree-container fancytree-plain",
		}).appendTo(this.$div);
		this.$container = $ul;
		this.rootNode.ul = $ul[0];

		if (this.options.debugLevel == null) {
			this.options.debugLevel = FT.debugLevel;
		}
		// // Add container to the TAB chain
		// // See http://www.w3.org/TR/wai-aria-practices/#focus_activedescendant
		// // #577: Allow to set tabindex to "0", "-1" and ""
		// this.$container.attr("tabindex", this.options.tabindex);

		// if( this.options.rtl ) {
		// 	this.$container.attr("DIR", "RTL").addClass("fancytree-rtl");
		// // }else{
		// //	this.$container.attr("DIR", null).removeClass("fancytree-rtl");
		// }
		// if(this.options.aria){
		// 	this.$container.attr("role", "tree");
		// 	if( this.options.selectMode !== 1 ) {
		// 		this.$container.attr("aria-multiselectable", true);
		// 	}
		// }
	}

	Fancytree.prototype = /** @lends Fancytree# */ {
		/* Return a context object that can be re-used for _callHook().
		 * @param {Fancytree | FancytreeNode | EventData} obj
		 * @param {Event} originalEvent
		 * @param {Object} extra
		 * @returns {EventData}
		 */
		_makeHookContext: function(obj, originalEvent, extra) {
			var ctx, tree;
			if (obj.node !== undefined) {
				// obj is already a context object
				if (originalEvent && obj.originalEvent !== originalEvent) {
					$.error("invalid args");
				}
				ctx = obj;
			} else if (obj.tree) {
				// obj is a FancytreeNode
				tree = obj.tree;
				ctx = {
					node: obj,
					tree: tree,
					widget: tree.widget,
					options: tree.widget.options,
					originalEvent: originalEvent,
					typeInfo: tree.types[obj.type] || {},
				};
			} else if (obj.widget) {
				// obj is a Fancytree
				ctx = {
					node: null,
					tree: obj,
					widget: obj.widget,
					options: obj.widget.options,
					originalEvent: originalEvent,
				};
			} else {
				$.error("invalid args");
			}
			if (extra) {
				$.extend(ctx, extra);
			}
			return ctx;
		},
		/* Trigger a hook function: funcName(ctx, [...]).
		 *
		 * @param {string} funcName
		 * @param {Fancytree|FancytreeNode|EventData} contextObject
		 * @param {any}  [_extraArgs] optional additional arguments
		 * @returns {any}
		 */
		_callHook: function(funcName, contextObject, _extraArgs) {
			var ctx = this._makeHookContext(contextObject),
				fn = this[funcName],
				args = Array.prototype.slice.call(arguments, 2);
			if (!$.isFunction(fn)) {
				$.error("_callHook('" + funcName + "') is not a function");
			}
			args.unshift(ctx);
			// this.debug("_hook", funcName, ctx.node && ctx.node.toString() || ctx.tree.toString(), args);
			return fn.apply(this, args);
		},
		_setExpiringValue: function(key, value, ms) {
			this._tempCache[key] = {
				value: value,
				expire: Date.now() + (+ms || 50),
			};
		},
		_getExpiringValue: function(key) {
			var entry = this._tempCache[key];
			if (entry && entry.expire > Date.now()) {
				return entry.value;
			}
			delete this._tempCache[key];
			return null;
		},
		/* Check if current extensions dependencies are met and throw an error if not.
		 *
		 * This method may be called inside the `treeInit` hook for custom extensions.
		 *
		 * @param {string} extension name of the required extension
		 * @param {boolean} [required=true] pass `false` if the extension is optional, but we want to check for order if it is present
		 * @param {boolean} [before] `true` if `name` must be included before this, `false` otherwise (use `null` if order doesn't matter)
		 * @param {string} [message] optional error message (defaults to a descriptve error message)
		 */
		_requireExtension: function(name, required, before, message) {
			if (before != null) {
				before = !!before;
			}
			var thisName = this._local.name,
				extList = this.options.extensions,
				isBefore =
					$.inArray(name, extList) < $.inArray(thisName, extList),
				isMissing = required && this.ext[name] == null,
				badOrder = !isMissing && before != null && before !== isBefore;

			_assert(
				thisName && thisName !== name,
				"invalid or same name '" + thisName + "' (require yourself?)"
			);

			if (isMissing || badOrder) {
				if (!message) {
					if (isMissing || required) {
						message =
							"'" +
							thisName +
							"' extension requires '" +
							name +
							"'";
						if (badOrder) {
							message +=
								" to be registered " +
								(before ? "before" : "after") +
								" itself";
						}
					} else {
						message =
							"If used together, `" +
							name +
							"` must be registered " +
							(before ? "before" : "after") +
							" `" +
							thisName +
							"`";
					}
				}
				$.error(message);
				return false;
			}
			return true;
		},
		/** Activate node with a given key and fire focus and activate events.
		 *
		 * A previously activated node will be deactivated.
		 * If activeVisible option is set, all parents will be expanded as necessary.
		 * Pass key = false, to deactivate the current node only.
		 * @param {string} key
		 * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false}
		 * @returns {FancytreeNode} activated node (null, if not found)
		 */
		activateKey: function(key, opts) {
			var node = this.getNodeByKey(key);
			if (node) {
				node.setActive(true, opts);
			} else if (this.activeNode) {
				this.activeNode.setActive(false, opts);
			}
			return node;
		},
		/** (experimental) Add child status nodes that indicate 'More...', ....
		 * @param {boolean|object} node optional node definition. Pass `false` to remove all paging nodes.
		 * @param {string} [mode='append'] 'child'|firstChild'
		 * @since 2.15
		 */
		addPagingNode: function(node, mode) {
			return this.rootNode.addPagingNode(node, mode);
		},
		/**
		 * (experimental) Apply a modification (or navigation) operation.
		 *
		 * Valid commands:
		 *   - 'moveUp', 'moveDown'
		 *   - 'indent', 'outdent'
		 *   - 'remove'
		 *   - 'edit', 'addChild', 'addSibling': (reqires ext-edit extension)
		 *   - 'cut', 'copy', 'paste': (use an internal singleton 'clipboard')
		 *   - 'down', 'first', 'last', 'left', 'parent', 'right', 'up': navigate
		 *
		 * @param {string} cmd
		 * @param {FancytreeNode} [node=active_node]
		 * @param {object} [opts] Currently unused
		 *
		 * @since 2.32
		 */
		applyCommand: function(cmd, node, opts_) {
			var // clipboard,
				refNode;
			// opts = $.extend(
			// 	{ setActive: true, clipboard: CLIPBOARD },
			// 	opts_
			// );

			node = node || this.getActiveNode();
			// clipboard = opts.clipboard;

			switch (cmd) {
				// Sorting and indentation:
				case "moveUp":
					refNode = node.getPrevSibling();
					if (refNode) {
						node.moveTo(refNode, "before");
						node.setActive();
					}
					break;
				case "moveDown":
					refNode = node.getNextSibling();
					if (refNode) {
						node.moveTo(refNode, "after");
						node.setActive();
					}
					break;
				case "indent":
					refNode = node.getPrevSibling();
					if (refNode) {
						node.moveTo(refNode, "child");
						refNode.setExpanded();
						node.setActive();
					}
					break;
				case "outdent":
					if (!node.isTopLevel()) {
						node.moveTo(node.getParent(), "after");
						node.setActive();
					}
					break;
				// Remove:
				case "remove":
					refNode = node.getPrevSibling() || node.getParent();
					node.remove();
					if (refNode) {
						refNode.setActive();
					}
					break;
				// Add, edit (requires ext-edit):
				case "addChild":
					node.editCreateNode("child", "");
					break;
				case "addSibling":
					node.editCreateNode("after", "");
					break;
				case "rename":
					node.editStart();
					break;
				// Simple clipboard simulation:
				// case "cut":
				// 	clipboard = { mode: cmd, data: node };
				// 	break;
				// case "copy":
				// 	clipboard = {
				// 		mode: cmd,
				// 		data: node.toDict(function(n) {
				// 			delete n.key;
				// 		}),
				// 	};
				// 	break;
				// case "clear":
				// 	clipboard = null;
				// 	break;
				// case "paste":
				// 	if (clipboard.mode === "cut") {
				// 		// refNode = node.getPrevSibling();
				// 		clipboard.data.moveTo(node, "child");
				// 		clipboard.data.setActive();
				// 	} else if (clipboard.mode === "copy") {
				// 		node.addChildren(clipboard.data).setActive();
				// 	}
				// 	break;
				// Navigation commands:
				case "down":
				case "first":
				case "last":
				case "left":
				case "parent":
				case "right":
				case "up":
					return node.navigate(cmd);
				default:
					$.error("Unhandled command: '" + cmd + "'");
			}
		},
		/** (experimental) Modify existing data model.
		 *
		 * @param {Array} patchList array of [key, NodePatch] arrays
		 * @returns {$.Promise} resolved, when all patches have been applied
		 * @see TreePatch
		 */
		applyPatch: function(patchList) {
			var dfd,
				i,
				p2,
				key,
				patch,
				node,
				patchCount = patchList.length,
				deferredList = [];

			for (i = 0; i < patchCount; i++) {
				p2 = patchList[i];
				_assert(
					p2.length === 2,
					"patchList must be an array of length-2-arrays"
				);
				key = p2[0];
				patch = p2[1];
				node = key === null ? this.rootNode : this.getNodeByKey(key);
				if (node) {
					dfd = new $.Deferred();
					deferredList.push(dfd);
					node.applyPatch(patch).always(_makeResolveFunc(dfd, node));
				} else {
					this.warn("could not find node with key '" + key + "'");
				}
			}
			// Return a promise that is resolved, when ALL patches were applied
			return $.when.apply($, deferredList).promise();
		},
		/* TODO: implement in dnd extension
		cancelDrag: function() {
				var dd = $.ui.ddmanager.current;
				if(dd){
					dd.cancel();
				}
			},
		*/
		/** Remove all nodes.
		 * @since 2.14
		 */
		clear: function(source) {
			this._callHook("treeClear", this);
		},
		/** Return the number of nodes.
		 * @returns {integer}
		 */
		count: function() {
			return this.rootNode.countChildren();
		},
		/** Write to browser console if debugLevel >= 4 (prepending tree name)
		 *
		 * @param {*} msg string or object or array of such
		 */
		debug: function(msg) {
			if (this.options.debugLevel >= 4) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("log", arguments);
			}
		},
		/** Enable (or disable) the tree control.
		 *
		 * @param {boolean} [flag=true] pass false to disable
		 * @since 2.30
		 */
		enable: function(flag) {
			if (flag === false) {
				this.widget.disable();
			} else {
				this.widget.enable();
			}
		},
		/** Temporarily suppress rendering to improve performance on bulk-updates.
		 *
		 * @param {boolean} flag
		 * @returns {boolean} previous status
		 * @since 2.19
		 */
		enableUpdate: function(flag) {
			flag = flag !== false;
			if (!!this._enableUpdate === !!flag) {
				return flag;
			}
			this._enableUpdate = flag;
			if (flag) {
				this.debug("enableUpdate(true): redraw "); //, this._dirtyRoots);
				this._callHook("treeStructureChanged", this, "enableUpdate");
				this.render();
			} else {
				// 	this._dirtyRoots = null;
				this.debug("enableUpdate(false)...");
			}
			return !flag; // return previous value
		},
		/** Write error to browser console if debugLevel >= 1 (prepending tree info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		error: function(msg) {
			if (this.options.debugLevel >= 1) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("error", arguments);
			}
		},
		/** Expand (or collapse) all parent nodes.
		 *
		 * This convenience method uses `tree.visit()` and `tree.setExpanded()`
		 * internally.
		 *
		 * @param {boolean} [flag=true] pass false to collapse
		 * @param {object} [opts] passed to setExpanded()
		 * @since 2.30
		 */
		expandAll: function(flag, opts) {
			var prev = this.enableUpdate(false);

			flag = flag !== false;
			this.visit(function(node) {
				if (
					node.hasChildren() !== false &&
					node.isExpanded() !== flag
				) {
					node.setExpanded(flag, opts);
				}
			});
			this.enableUpdate(prev);
		},
		/**Find all nodes that matches condition.
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode[]} array of nodes (may be empty)
		 * @see FancytreeNode#findAll
		 * @since 2.12
		 */
		findAll: function(match) {
			return this.rootNode.findAll(match);
		},
		/**Find first node that matches condition.
		 *
		 * @param {string | function(node)} match title string to search for, or a
		 *     callback function that returns `true` if a node is matched.
		 * @returns {FancytreeNode} matching node or null
		 * @see FancytreeNode#findFirst
		 * @since 2.12
		 */
		findFirst: function(match) {
			return this.rootNode.findFirst(match);
		},
		/** Find the next visible node that starts with `match`, starting at `startNode`
		 * and wrap-around at the end.
		 *
		 * @param {string|function} match
		 * @param {FancytreeNode} [startNode] defaults to first node
		 * @returns {FancytreeNode} matching node or null
		 */
		findNextNode: function(match, startNode) {
			//, visibleOnly) {
			var res = null,
				firstNode = this.getFirstChild();

			match =
				typeof match === "string"
					? _makeNodeTitleStartMatcher(match)
					: match;
			startNode = startNode || firstNode;

			function _checkNode(n) {
				// console.log("_check " + n)
				if (match(n)) {
					res = n;
				}
				if (res || n === startNode) {
					return false;
				}
			}
			this.visitRows(_checkNode, {
				start: startNode,
				includeSelf: false,
			});
			// Wrap around search
			if (!res && startNode !== firstNode) {
				this.visitRows(_checkNode, {
					start: firstNode,
					includeSelf: true,
				});
			}
			return res;
		},
		/** Find a node relative to another node.
		 *
		 * @param {FancytreeNode} node
		 * @param {string|number} where 'down', 'first', 'last', 'left', 'parent', 'right', or 'up'.
		 *   (Alternatively the keyCode that would normally trigger this move,
		 *   e.g. `$.ui.keyCode.LEFT` = 'left'.
		 * @param {boolean} [includeHidden=false] Not yet implemented
		 * @returns {FancytreeNode|null}
		 * @since v2.31
		 */
		findRelatedNode: function(node, where, includeHidden) {
			var res = null,
				KC = $.ui.keyCode;

			switch (where) {
				case "parent":
				case KC.BACKSPACE:
					if (node.parent && node.parent.parent) {
						res = node.parent;
					}
					break;
				case "first":
				case KC.HOME:
					// First visible node
					this.visit(function(n) {
						if (n.isVisible()) {
							res = n;
							return false;
						}
					});
					break;
				case "last":
				case KC.END:
					this.visit(function(n) {
						// last visible node
						if (n.isVisible()) {
							res = n;
						}
					});
					break;
				case "left":
				case KC.LEFT:
					if (node.expanded) {
						node.setExpanded(false);
					} else if (node.parent && node.parent.parent) {
						res = node.parent;
					}
					break;
				case "right":
				case KC.RIGHT:
					if (!node.expanded && (node.children || node.lazy)) {
						node.setExpanded();
						res = node;
					} else if (node.children && node.children.length) {
						res = node.children[0];
					}
					break;
				case "up":
				case KC.UP:
					this.visitRows(
						function(n) {
							res = n;
							return false;
						},
						{ start: node, reverse: true, includeSelf: false }
					);
					break;
				case "down":
				case KC.DOWN:
					this.visitRows(
						function(n) {
							res = n;
							return false;
						},
						{ start: node, includeSelf: false }
					);
					break;
				default:
					this.tree.warn("Unknown relation '" + where + "'.");
			}
			return res;
		},
		// TODO: fromDict
		/**
		 * Generate INPUT elements that can be submitted with html forms.
		 *
		 * In selectMode 3 only the topmost selected nodes are considered, unless
		 * `opts.stopOnParents: false` is passed.
		 *
		 * @example
		 * // Generate input elements for active and selected nodes
		 * tree.generateFormElements();
		 * // Generate input elements selected nodes, using a custom `name` attribute
		 * tree.generateFormElements("cust_sel", false);
		 * // Generate input elements using a custom filter
		 * tree.generateFormElements(true, true, { filter: function(node) {
		 *     return node.isSelected() && node.data.yes;
		 * }});
		 *
		 * @param {boolean | string} [selected=true] Pass false to disable, pass a string to override the field name (default: 'ft_ID[]')
		 * @param {boolean | string} [active=true] Pass false to disable, pass a string to override the field name (default: 'ft_ID_active')
		 * @param {object} [opts] default { filter: null, stopOnParents: true }
		 */
		generateFormElements: function(selected, active, opts) {
			opts = opts || {};

			var nodeList,
				selectedName =
					typeof selected === "string"
						? selected
						: "ft_" + this._id + "[]",
				activeName =
					typeof active === "string"
						? active
						: "ft_" + this._id + "_active",
				id = "fancytree_result_" + this._id,
				$result = $("#" + id),
				stopOnParents =
					this.options.selectMode === 3 &&
					opts.stopOnParents !== false;

			if ($result.length) {
				$result.empty();
			} else {
				$result = $("<div>", {
					id: id,
				})
					.hide()
					.insertAfter(this.$container);
			}
			if (active !== false && this.activeNode) {
				$result.append(
					$("<input>", {
						type: "radio",
						name: activeName,
						value: this.activeNode.key,
						checked: true,
					})
				);
			}
			function _appender(node) {
				$result.append(
					$("<input>", {
						type: "checkbox",
						name: selectedName,
						value: node.key,
						checked: true,
					})
				);
			}
			if (opts.filter) {
				this.visit(function(node) {
					var res = opts.filter(node);
					if (res === "skip") {
						return res;
					}
					if (res !== false) {
						_appender(node);
					}
				});
			} else if (selected !== false) {
				nodeList = this.getSelectedNodes(stopOnParents);
				$.each(nodeList, function(idx, node) {
					_appender(node);
				});
			}
		},
		/**
		 * Return the currently active node or null.
		 * @returns {FancytreeNode}
		 */
		getActiveNode: function() {
			return this.activeNode;
		},
		/** Return the first top level node if any (not the invisible root node).
		 * @returns {FancytreeNode | null}
		 */
		getFirstChild: function() {
			return this.rootNode.getFirstChild();
		},
		/**
		 * Return node that has keyboard focus or null.
		 * @returns {FancytreeNode}
		 */
		getFocusNode: function() {
			return this.focusNode;
		},
		/**
		 * Return current option value.
		 * (Note: this is the preferred variant of `$().fancytree("option", "KEY")`)
		 *
		 * @param {string} name option name (may contain '.')
		 * @returns {any}
		 */
		getOption: function(optionName) {
			return this.widget.option(optionName);
		},
		/**
		 * Return node with a given key or null if not found.
		 *
		 * @param {string} key
		 * @param {FancytreeNode} [searchRoot] only search below this node
		 * @returns {FancytreeNode | null}
		 */
		getNodeByKey: function(key, searchRoot) {
			// Search the DOM by element ID (assuming this is faster than traversing all nodes).
			var el, match;
			// TODO: use tree.keyMap if available
			// TODO: check opts.generateIds === true
			if (!searchRoot) {
				el = document.getElementById(this.options.idPrefix + key);
				if (el) {
					return el.ftnode ? el.ftnode : null;
				}
			}
			// Not found in the DOM, but still may be in an unrendered part of tree
			searchRoot = searchRoot || this.rootNode;
			match = null;
			searchRoot.visit(function(node) {
				if (node.key === key) {
					match = node;
					return false; // Stop iteration
				}
			}, true);
			return match;
		},
		/** Return the invisible system root node.
		 * @returns {FancytreeNode}
		 */
		getRootNode: function() {
			return this.rootNode;
		},
		/**
		 * Return an array of selected nodes.
		 *
		 * Note: you cannot send this result via Ajax directly. Instead the
		 * node object need to be converted to plain objects, for example
		 * by using `$.map()` and `node.toDict()`.
		 * @param {boolean} [stopOnParents=false] only return the topmost selected
		 *     node (useful with selectMode 3)
		 * @returns {FancytreeNode[]}
		 */
		getSelectedNodes: function(stopOnParents) {
			return this.rootNode.getSelectedNodes(stopOnParents);
		},
		/** Return true if the tree control has keyboard focus
		 * @returns {boolean}
		 */
		hasFocus: function() {
			return !!this._hasFocus;
		},
		/** Write to browser console if debugLevel >= 3 (prepending tree name)
		 * @param {*} msg string or object or array of such
		 */
		info: function(msg) {
			if (this.options.debugLevel >= 3) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("info", arguments);
			}
		},
		/** Return true if any node is currently beeing loaded, i.e. a Ajax request is pending.
		 * @returns {boolean}
		 * @since 2.32
		 */
		isLoading: function() {
			var res = false;

			this.rootNode.visit(function(n) {
				// also visit rootNode
				if (n._isLoading || n._requestId) {
					res = true;
					return false;
				}
			}, true);
			return res;
		},
		/*
		TODO: isInitializing: function() {
			return ( this.phase=="init" || this.phase=="postInit" );
		},
		TODO: isReloading: function() {
			return ( this.phase=="init" || this.phase=="postInit" ) && this.options.persist && this.persistence.cookiesFound;
		},
		TODO: isUserEvent: function() {
			return ( this.phase=="userEvent" );
		},
		*/

		/**
		 * Make sure that a node with a given ID is loaded, by traversing - and
		 * loading - its parents. This method is meant for lazy hierarchies.
		 * A callback is executed for every node as we go.
		 * @example
		 * // Resolve using node.key:
		 * tree.loadKeyPath("/_3/_23/_26/_27", function(node, status){
		 *   if(status === "loaded") {
		 *     console.log("loaded intermediate node " + node);
		 *   }else if(status === "ok") {
		 *     node.activate();
		 *   }
		 * });
		 * // Use deferred promise:
		 * tree.loadKeyPath("/_3/_23/_26/_27").progress(function(data){
		 *   if(data.status === "loaded") {
		 *     console.log("loaded intermediate node " + data.node);
		 *   }else if(data.status === "ok") {
		 *     node.activate();
		 *   }
		 * }).done(function(){
		 *    ...
		 * });
		 * // Custom path segment resolver:
		 * tree.loadKeyPath("/321/431/21/2", {
		 *   matchKey: function(node, key){
		 *     return node.data.refKey === key;
		 *   },
		 *   callback: function(node, status){
		 *     if(status === "loaded") {
		 *       console.log("loaded intermediate node " + node);
		 *     }else if(status === "ok") {
		 *       node.activate();
		 *     }
		 *   }
		 * });
		 * @param {string | string[]} keyPathList one or more key paths (e.g. '/3/2_1/7')
		 * @param {function | object} optsOrCallback callback(node, status) is called for every visited node ('loading', 'loaded', 'ok', 'error').
		 *     Pass an object to define custom key matchers for the path segments: {callback: function, matchKey: function}.
		 * @returns {$.Promise}
		 */
		loadKeyPath: function(keyPathList, optsOrCallback) {
			var callback,
				i,
				path,
				self = this,
				dfd = new $.Deferred(),
				parent = this.getRootNode(),
				sep = this.options.keyPathSeparator,
				pathSegList = [],
				opts = $.extend({}, optsOrCallback);

			// Prepare options
			if (typeof optsOrCallback === "function") {
				callback = optsOrCallback;
			} else if (optsOrCallback && optsOrCallback.callback) {
				callback = optsOrCallback.callback;
			}
			opts.callback = function(ctx, node, status) {
				if (callback) {
					callback.call(ctx, node, status);
				}
				dfd.notifyWith(ctx, [{ node: node, status: status }]);
			};
			if (opts.matchKey == null) {
				opts.matchKey = function(node, key) {
					return node.key === key;
				};
			}
			// Convert array of path strings to array of segment arrays
			if (!$.isArray(keyPathList)) {
				keyPathList = [keyPathList];
			}
			for (i = 0; i < keyPathList.length; i++) {
				path = keyPathList[i];
				// strip leading slash
				if (path.charAt(0) === sep) {
					path = path.substr(1);
				}
				// segListMap[path] = { parent: parent, segList: path.split(sep) };
				pathSegList.push(path.split(sep));
				// targetList.push({ parent: parent, segList: path.split(sep)/* , path: path*/});
			}
			// The timeout forces async behavior always (even if nodes are all loaded)
			// This way a potential progress() event will fire.
			setTimeout(function() {
				self._loadKeyPathImpl(dfd, opts, parent, pathSegList).done(
					function() {
						dfd.resolve();
					}
				);
			}, 0);
			return dfd.promise();
		},
		/*
		 * Resolve a list of paths, relative to one parent node.
		 */
		_loadKeyPathImpl: function(dfd, opts, parent, pathSegList) {
			var deferredList,
				i,
				key,
				node,
				nodeKey,
				remain,
				remainMap,
				tmpParent,
				segList,
				subDfd,
				self = this;

			function __findChild(parent, key) {
				// console.log("__findChild", key, parent);
				var i,
					l,
					cl = parent.children;

				if (cl) {
					for (i = 0, l = cl.length; i < l; i++) {
						if (opts.matchKey(cl[i], key)) {
							return cl[i];
						}
					}
				}
				return null;
			}

			// console.log("_loadKeyPathImpl, parent=", parent, ", pathSegList=", pathSegList);

			// Pass 1:
			// Handle all path segments for nodes that are already loaded.
			// Collect distinct top-most lazy nodes in a map.
			// Note that we can use node.key to de-dupe entries, even if a custom matcher would
			// look for other node attributes.
			// map[node.key] => {node: node, pathList: [list of remaining rest-paths]}
			remainMap = {};

			for (i = 0; i < pathSegList.length; i++) {
				segList = pathSegList[i];
				// target = targetList[i];

				// Traverse and pop path segments (i.e. keys), until we hit a lazy, unloaded node
				tmpParent = parent;
				while (segList.length) {
					key = segList.shift();
					node = __findChild(tmpParent, key);
					if (!node) {
						this.warn(
							"loadKeyPath: key not found: " +
								key +
								" (parent: " +
								tmpParent +
								")"
						);
						opts.callback(this, key, "error");
						break;
					} else if (segList.length === 0) {
						opts.callback(this, node, "ok");
						break;
					} else if (!node.lazy || node.hasChildren() !== undefined) {
						opts.callback(this, node, "loaded");
						tmpParent = node;
					} else {
						opts.callback(this, node, "loaded");
						key = node.key; //target.segList.join(sep);
						if (remainMap[key]) {
							remainMap[key].pathSegList.push(segList);
						} else {
							remainMap[key] = {
								parent: node,
								pathSegList: [segList],
							};
						}
						break;
					}
				}
			}
			// console.log("_loadKeyPathImpl AFTER pass 1, remainMap=", remainMap);

			// Now load all lazy nodes and continue iteration for remaining paths
			deferredList = [];

			// Avoid jshint warning 'Don't make functions within a loop.':
			function __lazyload(dfd, parent, pathSegList) {
				// console.log("__lazyload", parent, "pathSegList=", pathSegList);
				opts.callback(self, parent, "loading");
				parent
					.load()
					.done(function() {
						self._loadKeyPathImpl
							.call(self, dfd, opts, parent, pathSegList)
							.always(_makeResolveFunc(dfd, self));
					})
					.fail(function(errMsg) {
						self.warn("loadKeyPath: error loading lazy " + parent);
						opts.callback(self, node, "error");
						dfd.rejectWith(self);
					});
			}
			// remainMap contains parent nodes, each with a list of relative sub-paths.
			// We start loading all of them now, and pass the the list to each loader.
			for (nodeKey in remainMap) {
				if (remainMap.hasOwnProperty(nodeKey)) {
					remain = remainMap[nodeKey];
					// console.log("for(): remain=", remain, "remainMap=", remainMap);
					// key = remain.segList.shift();
					// node = __findChild(remain.parent, key);
					// if (node == null) {  // #576
					// 	// Issue #576, refactored for v2.27:
					// 	// The root cause was, that sometimes the wrong parent was used here
					// 	// to find the next segment.
					// 	// Falling back to getNodeByKey() was a hack that no longer works if a custom
					// 	// matcher is used, because we cannot assume that a single segment-key is unique
					// 	// throughout the tree.
					// 	self.error("loadKeyPath: error loading child by key '" + key + "' (parent: " + target.parent + ")", target);
					// 	// 	node = self.getNodeByKey(key);
					// 	continue;
					// }
					subDfd = new $.Deferred();
					deferredList.push(subDfd);
					__lazyload(subDfd, remain.parent, remain.pathSegList);
				}
			}
			// Return a promise that is resolved, when ALL paths were loaded
			return $.when.apply($, deferredList).promise();
		},
		/** Re-fire beforeActivate, activate, and (optional) focus events.
		 * Calling this method in the `init` event, will activate the node that
		 * was marked 'active' in the source data, and optionally set the keyboard
		 * focus.
		 * @param [setFocus=false]
		 */
		reactivate: function(setFocus) {
			var res,
				node = this.activeNode;

			if (!node) {
				return _getResolvedPromise();
			}
			this.activeNode = null; // Force re-activating
			res = node.setActive(true, { noFocus: true });
			if (setFocus) {
				node.setFocus();
			}
			return res;
		},
		/** Reload tree from source and return a promise.
		 * @param [source] optional new source (defaults to initial source data)
		 * @returns {$.Promise}
		 */
		reload: function(source) {
			this._callHook("treeClear", this);
			return this._callHook("treeLoad", this, source);
		},
		/**Render tree (i.e. create DOM elements for all top-level nodes).
		 * @param {boolean} [force=false] create DOM elemnts, even if parent is collapsed
		 * @param {boolean} [deep=false]
		 */
		render: function(force, deep) {
			return this.rootNode.render(force, deep);
		},
		/**(De)select all nodes.
		 * @param {boolean} [flag=true]
		 * @since 2.28
		 */
		selectAll: function(flag) {
			this.visit(function(node) {
				node.setSelected(flag);
			});
		},
		// TODO: selectKey: function(key, select)
		// TODO: serializeArray: function(stopOnParents)
		/**
		 * @param {boolean} [flag=true]
		 */
		setFocus: function(flag) {
			return this._callHook("treeSetFocus", this, flag);
		},
		/**
		 * Set current option value.
		 * (Note: this is the preferred variant of `$().fancytree("option", "KEY", VALUE)`)
		 * @param {string} name option name (may contain '.')
		 * @param {any} new value
		 */
		setOption: function(optionName, value) {
			return this.widget.option(optionName, value);
		},
		/**
		 * Return all nodes as nested list of {@link NodeData}.
		 *
		 * @param {boolean} [includeRoot=false] Returns the hidden system root node (and its children)
		 * @param {function} [callback] callback(dict, node) is called for every node, in order to allow modifications.
		 *     Return `false` to ignore this node or "skip" to include this node without its children.
		 * @returns {Array | object}
		 * @see FancytreeNode#toDict
		 */
		toDict: function(includeRoot, callback) {
			var res = this.rootNode.toDict(true, callback);
			return includeRoot ? res : res.children;
		},
		/* Implicitly called for string conversions.
		 * @returns {string}
		 */
		toString: function() {
			return "Fancytree@" + this._id;
			// return "<Fancytree(#" + this._id + ")>";
		},
		/* _trigger a widget event with additional node ctx.
		 * @see EventData
		 */
		_triggerNodeEvent: function(type, node, originalEvent, extra) {
			// this.debug("_trigger(" + type + "): '" + ctx.node.title + "'", ctx);
			var ctx = this._makeHookContext(node, originalEvent, extra),
				res = this.widget._trigger(type, originalEvent, ctx);
			if (res !== false && ctx.result !== undefined) {
				return ctx.result;
			}
			return res;
		},
		/* _trigger a widget event with additional tree data. */
		_triggerTreeEvent: function(type, originalEvent, extra) {
			// this.debug("_trigger(" + type + ")", ctx);
			var ctx = this._makeHookContext(this, originalEvent, extra),
				res = this.widget._trigger(type, originalEvent, ctx);

			if (res !== false && ctx.result !== undefined) {
				return ctx.result;
			}
			return res;
		},
		/** Call fn(node) for all nodes in hierarchical order (depth-first).
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and children only.
		 * @returns {boolean} false, if the iterator was stopped.
		 */
		visit: function(fn) {
			return this.rootNode.visit(fn, false);
		},
		/** Call fn(node) for all nodes in vertical order, top down (or bottom up).<br>
		 * Stop iteration, if fn() returns false.<br>
		 * Return false if iteration was stopped.
		 *
		 * @param {function} fn the callback function.
		 *     Return false to stop iteration, return "skip" to skip this node and children only.
		 * @param {object} [options]
		 *     Defaults:
		 *     {start: First top node, reverse: false, includeSelf: true, includeHidden: false}
		 * @returns {boolean} false if iteration was cancelled
		 * @since 2.28
		 */
		visitRows: function(fn, opts) {
			if (!this.rootNode.children) {
				return false;
			}
			if (opts && opts.reverse) {
				delete opts.reverse;
				return this._visitRowsUp(fn, opts);
			}
			opts = opts || {};

			var i,
				nextIdx,
				parent,
				res,
				siblings,
				siblingOfs = 0,
				skipFirstNode = opts.includeSelf === false,
				includeHidden = !!opts.includeHidden,
				checkFilter = !includeHidden && this.enableFilter,
				node = opts.start || this.rootNode.children[0];

			parent = node.parent;
			while (parent) {
				// visit siblings
				siblings = parent.children;
				nextIdx = siblings.indexOf(node) + siblingOfs;

				for (i = nextIdx; i < siblings.length; i++) {
					node = siblings[i];
					if (checkFilter && !node.match && !node.subMatchCount) {
						continue;
					}
					if (!skipFirstNode && fn(node) === false) {
						return false;
					}
					skipFirstNode = false;
					// Dive into node's child nodes
					if (
						node.children &&
						node.children.length &&
						(includeHidden || node.expanded)
					) {
						// Disable warning: Functions declared within loops referencing an outer
						// scoped variable may lead to confusing semantics:
						/*jshint -W083 */
						res = node.visit(function(n) {
							if (checkFilter && !n.match && !n.subMatchCount) {
								return "skip";
							}
							if (fn(n) === false) {
								return false;
							}
							if (!includeHidden && n.children && !n.expanded) {
								return "skip";
							}
						}, false);
						/*jshint +W083 */
						if (res === false) {
							return false;
						}
					}
				}
				// Visit parent nodes (bottom up)
				node = parent;
				parent = parent.parent;
				siblingOfs = 1; //
			}
			return true;
		},
		/* Call fn(node) for all nodes in vertical order, bottom up.
		 */
		_visitRowsUp: function(fn, opts) {
			var children,
				idx,
				parent,
				includeHidden = !!opts.includeHidden,
				node = opts.start || this.rootNode.children[0];

			while (true) {
				parent = node.parent;
				children = parent.children;

				if (children[0] === node) {
					// If this is already the first sibling, goto parent
					node = parent;
					if (!node.parent) {
						break; // first node of the tree
					}
					children = parent.children;
				} else {
					// Otherwise, goto prev. sibling
					idx = children.indexOf(node);
					node = children[idx - 1];
					// If the prev. sibling has children, follow down to last descendant
					while (
						// See: https://github.com/eslint/eslint/issues/11302
						// eslint-disable-next-line no-unmodified-loop-condition
						(includeHidden || node.expanded) &&
						node.children &&
						node.children.length
					) {
						children = node.children;
						parent = node;
						node = children[children.length - 1];
					}
				}
				// Skip invisible
				if (!includeHidden && !node.isVisible()) {
					continue;
				}
				if (fn(node) === false) {
					return false;
				}
			}
		},
		/** Write warning to browser console if debugLevel >= 2 (prepending tree info)
		 *
		 * @param {*} msg string or object or array of such
		 */
		warn: function(msg) {
			if (this.options.debugLevel >= 2) {
				Array.prototype.unshift.call(arguments, this.toString());
				consoleApply("warn", arguments);
			}
		},
	};

	/**
	 * These additional methods of the {@link Fancytree} class are 'hook functions'
	 * that can be used and overloaded by extensions.
	 * (See <a href="https://github.com/mar10/fancytree/wiki/TutorialExtensions">writing extensions</a>.)
	 * @mixin Fancytree_Hooks
	 */
	$.extend(
		Fancytree.prototype,
		/** @lends Fancytree_Hooks# */
		{
			/** Default handling for mouse click events.
			 *
			 * @param {EventData} ctx
			 */
			nodeClick: function(ctx) {
				var activate,
					expand,
					// event = ctx.originalEvent,
					targetType = ctx.targetType,
					node = ctx.node;

				// this.debug("ftnode.onClick(" + event.type + "): ftnode:" + this + ", button:" + event.button + ", which: " + event.which, ctx);
				// TODO: use switch
				// TODO: make sure clicks on embedded <input> doesn't steal focus (see table sample)
				if (targetType === "expander") {
					if (node.isLoading()) {
						// #495: we probably got a click event while a lazy load is pending.
						// The 'expanded' state is not yet set, so 'toggle' would expand
						// and trigger lazyLoad again.
						// It would be better to allow to collapse/expand the status node
						// while loading (instead of ignoring), but that would require some
						// more work.
						node.debug("Got 2nd click while loading: ignored");
						return;
					}
					// Clicking the expander icon always expands/collapses
					this._callHook("nodeToggleExpanded", ctx);
				} else if (targetType === "checkbox") {
					// Clicking the checkbox always (de)selects
					this._callHook("nodeToggleSelected", ctx);
					if (ctx.options.focusOnSelect) {
						// #358
						this._callHook("nodeSetFocus", ctx, true);
					}
				} else {
					// Honor `clickFolderMode` for
					expand = false;
					activate = true;
					if (node.folder) {
						switch (ctx.options.clickFolderMode) {
							case 2: // expand only
								expand = true;
								activate = false;
								break;
							case 3: // expand and activate
								activate = true;
								expand = true; //!node.isExpanded();
								break;
							// else 1 or 4: just activate
						}
					}
					if (activate) {
						this.nodeSetFocus(ctx);
						this._callHook("nodeSetActive", ctx, true);
					}
					if (expand) {
						if (!activate) {
							// this._callHook("nodeSetFocus", ctx);
						}
						// this._callHook("nodeSetExpanded", ctx, true);
						this._callHook("nodeToggleExpanded", ctx);
					}
				}
				// Make sure that clicks stop, otherwise <a href='#'> jumps to the top
				// if(event.target.localName === "a" && event.target.className === "fancytree-title"){
				// 	event.preventDefault();
				// }
				// TODO: return promise?
			},
			/** Collapse all other  children of same parent.
			 *
			 * @param {EventData} ctx
			 * @param {object} callOpts
			 */
			nodeCollapseSiblings: function(ctx, callOpts) {
				// TODO: return promise?
				var ac,
					i,
					l,
					node = ctx.node;

				if (node.parent) {
					ac = node.parent.children;
					for (i = 0, l = ac.length; i < l; i++) {
						if (ac[i] !== node && ac[i].expanded) {
							this._callHook(
								"nodeSetExpanded",
								ac[i],
								false,
								callOpts
							);
						}
					}
				}
			},
			/** Default handling for mouse douleclick events.
			 * @param {EventData} ctx
			 */
			nodeDblclick: function(ctx) {
				// TODO: return promise?
				if (
					ctx.targetType === "title" &&
					ctx.options.clickFolderMode === 4
				) {
					// this.nodeSetFocus(ctx);
					// this._callHook("nodeSetActive", ctx, true);
					this._callHook("nodeToggleExpanded", ctx);
				}
				// TODO: prevent text selection on dblclicks
				if (ctx.targetType === "title") {
					ctx.originalEvent.preventDefault();
				}
			},
			/** Default handling for mouse keydown events.
			 *
			 * NOTE: this may be called with node == null if tree (but no node) has focus.
			 * @param {EventData} ctx
			 */
			nodeKeydown: function(ctx) {
				// TODO: return promise?
				var matchNode,
					stamp,
					_res,
					focusNode,
					event = ctx.originalEvent,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					which = event.which,
					// #909: Use event.key, to get unicode characters.
					// We can't use `/\w/.test(key)`, because that would
					// only detect plain ascii alpha-numerics. But we still need
					// to ignore modifier-only, whitespace, cursor-keys, etc.
					key = event.key || String.fromCharCode(which),
					specialModifiers = !!(
						event.altKey ||
						event.ctrlKey ||
						event.metaKey
					),
					isAlnum =
						!MODIFIERS[which] &&
						!SPECIAL_KEYCODES[which] &&
						!specialModifiers,
					$target = $(event.target),
					handled = true,
					activate = !(event.ctrlKey || !opts.autoActivate);

				// (node || FT).debug("ftnode.nodeKeydown(" + event.type + "): ftnode:" + this + ", charCode:" + event.charCode + ", keyCode: " + event.keyCode + ", which: " + event.which);
				// FT.debug( "eventToString(): " + FT.eventToString(event) + ", key='" + key + "', isAlnum: " + isAlnum );

				// Set focus to active (or first node) if no other node has the focus yet
				if (!node) {
					focusNode = this.getActiveNode() || this.getFirstChild();
					if (focusNode) {
						focusNode.setFocus();
						node = ctx.node = this.focusNode;
						node.debug("Keydown force focus on active node");
					}
				}

				if (
					opts.quicksearch &&
					isAlnum &&
					!$target.is(":input:enabled")
				) {
					// Allow to search for longer streaks if typed in quickly
					stamp = Date.now();
					if (stamp - tree.lastQuicksearchTime > 500) {
						tree.lastQuicksearchTerm = "";
					}
					tree.lastQuicksearchTime = stamp;
					tree.lastQuicksearchTerm += key;
					// tree.debug("quicksearch find", tree.lastQuicksearchTerm);
					matchNode = tree.findNextNode(
						tree.lastQuicksearchTerm,
						tree.getActiveNode()
					);
					if (matchNode) {
						matchNode.setActive();
					}
					event.preventDefault();
					return;
				}
				switch (FT.eventToString(event)) {
					case "+":
					case "=": // 187: '+' @ Chrome, Safari
						tree.nodeSetExpanded(ctx, true);
						break;
					case "-":
						tree.nodeSetExpanded(ctx, false);
						break;
					case "space":
						if (node.isPagingNode()) {
							tree._triggerNodeEvent("clickPaging", ctx, event);
						} else if (
							FT.evalOption("checkbox", node, node, opts, false)
						) {
							// #768
							tree.nodeToggleSelected(ctx);
						} else {
							tree.nodeSetActive(ctx, true);
						}
						break;
					case "return":
						tree.nodeSetActive(ctx, true);
						break;
					case "home":
					case "end":
					case "backspace":
					case "left":
					case "right":
					case "up":
					case "down":
						_res = node.navigate(event.which, activate);
						break;
					default:
						handled = false;
				}
				if (handled) {
					event.preventDefault();
				}
			},

			// /** Default handling for mouse keypress events. */
			// nodeKeypress: function(ctx) {
			//     var event = ctx.originalEvent;
			// },

			// /** Trigger lazyLoad event (async). */
			// nodeLazyLoad: function(ctx) {
			//     var node = ctx.node;
			//     if(this._triggerNodeEvent())
			// },
			/** Load child nodes (async).
			 *
			 * @param {EventData} ctx
			 * @param {object[]|object|string|$.Promise|function} source
			 * @returns {$.Promise} The deferred will be resolved as soon as the (ajax)
			 *     data was rendered.
			 */
			nodeLoadChildren: function(ctx, source) {
				var ajax,
					delay,
					dfd,
					res,
					tree = ctx.tree,
					node = ctx.node,
					requestId = Date.now();

				if ($.isFunction(source)) {
					source = source.call(tree, { type: "source" }, ctx);
					_assert(
						!$.isFunction(source),
						"source callback must not return another function"
					);
				}
				if (source.url) {
					if (node._requestId) {
						node.warn(
							"Recursive load request #" +
								requestId +
								" while #" +
								node._requestId +
								" is pending."
						);
						// } else {
						// 	node.debug("Send load request #" + requestId);
					}
					// `source` is an Ajax options object
					ajax = $.extend({}, ctx.options.ajax, source);
					node._requestId = requestId;
					if (ajax.debugDelay) {
						// simulate a slow server
						delay = ajax.debugDelay;
						delete ajax.debugDelay; // remove debug option
						if ($.isArray(delay)) {
							// random delay range [min..max]
							delay =
								delay[0] +
								Math.random() * (delay[1] - delay[0]);
						}
						node.warn(
							"nodeLoadChildren waiting debugDelay " +
								Math.round(delay) +
								" ms ..."
						);
						dfd = $.Deferred(function(dfd) {
							setTimeout(function() {
								$.ajax(ajax)
									.done(function() {
										dfd.resolveWith(this, arguments);
									})
									.fail(function() {
										dfd.rejectWith(this, arguments);
									});
							}, delay);
						});
					} else {
						dfd = $.ajax(ajax);
					}

					// Defer the deferred: we want to be able to reject, even if ajax
					// resolved ok.
					source = new $.Deferred();
					dfd.done(function(data, textStatus, jqXHR) {
						var errorObj, res;

						if (
							(this.dataType === "json" ||
								this.dataType === "jsonp") &&
							typeof data === "string"
						) {
							$.error(
								"Ajax request returned a string (did you get the JSON dataType wrong?)."
							);
						}
						if (node._requestId && node._requestId > requestId) {
							// The expected request time stamp is later than `requestId`
							// (which was kept as as closure variable to this handler function)
							// node.warn("Ignored load response for obsolete request #" + requestId + " (expected #" + node._requestId + ")");
							source.rejectWith(this, [RECURSIVE_REQUEST_ERROR]);
							return;
							// } else {
							// 	node.debug("Response returned for load request #" + requestId);
						}
						// postProcess is similar to the standard ajax dataFilter hook,
						// but it is also called for JSONP
						if (ctx.options.postProcess) {
							try {
								// The handler may either
								//   - modify `ctx.response` in-place (and leave `ctx.result` undefined)
								//     => res = undefined
								//   - return a replacement in `ctx.result`
								//     => res = <new data>
								// If res contains an `error` property, an error status is displayed
								res = tree._triggerNodeEvent(
									"postProcess",
									ctx,
									ctx.originalEvent,
									{
										response: data,
										error: null,
										dataType: this.dataType,
									}
								);
							} catch (e) {
								res = {
									error: e,
									message: "" + e,
									details: "postProcess failed",
								};
							}
							if (res.error) {
								errorObj = $.isPlainObject(res.error)
									? res.error
									: { message: res.error };
								errorObj = tree._makeHookContext(
									node,
									null,
									errorObj
								);
								source.rejectWith(this, [errorObj]);
								return;
							}
							if (
								$.isArray(res) ||
								($.isPlainObject(res) &&
									$.isArray(res.children))
							) {
								// Use `ctx.result` if valid
								// (otherwise use existing data, which may have been modified in-place)
								data = res;
							}
						} else if (
							data &&
							data.hasOwnProperty("d") &&
							ctx.options.enableAspx
						) {
							// Process ASPX WebMethod JSON object inside "d" property
							data =
								typeof data.d === "string"
									? $.parseJSON(data.d)
									: data.d;
						}
						source.resolveWith(this, [data]);
					}).fail(function(jqXHR, textStatus, errorThrown) {
						var errorObj = tree._makeHookContext(node, null, {
							error: jqXHR,
							args: Array.prototype.slice.call(arguments),
							message: errorThrown,
							details: jqXHR.status + ": " + errorThrown,
						});
						source.rejectWith(this, [errorObj]);
					});
				}
				// #383: accept and convert ECMAScript 6 Promise
				if ($.isFunction(source.then) && $.isFunction(source.catch)) {
					dfd = source;
					source = new $.Deferred();
					dfd.then(
						function(value) {
							source.resolve(value);
						},
						function(reason) {
							source.reject(reason);
						}
					);
				}
				if ($.isFunction(source.promise)) {
					// `source` is a deferred, i.e. ajax request
					// _assert(!node.isLoading(), "recursive load");
					tree.nodeSetStatus(ctx, "loading");

					source
						.done(function(children) {
							tree.nodeSetStatus(ctx, "ok");
							node._requestId = null;
						})
						.fail(function(error) {
							var ctxErr;

							if (error === RECURSIVE_REQUEST_ERROR) {
								node.warn(
									"Ignored response for obsolete load request #" +
										requestId +
										" (expected #" +
										node._requestId +
										")"
								);
								return;
							} else if (
								error.node &&
								error.error &&
								error.message
							) {
								// error is already a context object
								ctxErr = error;
							} else {
								ctxErr = tree._makeHookContext(node, null, {
									error: error, // it can be jqXHR or any custom error
									args: Array.prototype.slice.call(arguments),
									message: error
										? error.message || error.toString()
										: "",
								});
								if (ctxErr.message === "[object Object]") {
									ctxErr.message = "";
								}
							}
							node.warn(
								"Load children failed (" + ctxErr.message + ")",
								ctxErr
							);
							if (
								tree._triggerNodeEvent(
									"loadError",
									ctxErr,
									null
								) !== false
							) {
								tree.nodeSetStatus(
									ctx,
									"error",
									ctxErr.message,
									ctxErr.details
								);
							}
						});
				} else {
					if (ctx.options.postProcess) {
						// #792: Call postProcess for non-deferred source
						res = tree._triggerNodeEvent(
							"postProcess",
							ctx,
							ctx.originalEvent,
							{
								response: source,
								error: null,
								dataType: typeof source,
							}
						);

						if (
							$.isArray(res) ||
							($.isPlainObject(res) && $.isArray(res.children))
						) {
							// Use `ctx.result` if valid
							// (otherwise use existing data, which may have been modified in-place)
							source = res;
						}
					}
				}
				// $.when(source) resolves also for non-deferreds
				return $.when(source).done(function(children) {
					var metaData, noDataRes;

					if ($.isPlainObject(children)) {
						// We got {foo: 'abc', children: [...]}
						// Copy extra properties to tree.data.foo
						_assert(
							node.isRootNode(),
							"source may only be an object for root nodes (expecting an array of child objects otherwise)"
						);
						_assert(
							$.isArray(children.children),
							"if an object is passed as source, it must contain a 'children' array (all other properties are added to 'tree.data')"
						);
						metaData = children;
						children = children.children;
						delete metaData.children;
						// Copy some attributes to tree.data
						$.each(TREE_ATTRS, function(i, attr) {
							if (metaData[attr] !== undefined) {
								tree[attr] = metaData[attr];
								delete metaData[attr];
							}
						});
						// Copy all other attributes to tree.data.NAME
						$.extend(tree.data, metaData);
					}
					_assert($.isArray(children), "expected array of children");
					node._setChildren(children);

					if (tree.options.nodata && children.length === 0) {
						if ($.isFunction(tree.options.nodata)) {
							noDataRes = tree.options.nodata.call(
								tree,
								{ type: "nodata" },
								ctx
							);
						} else if (
							tree.options.nodata === true &&
							node.isRootNode()
						) {
							noDataRes = tree.options.strings.nodata;
						} else if (
							typeof tree.options.nodata === "string" &&
							node.isRootNode()
						) {
							noDataRes = tree.options.nodata;
						}
						if (noDataRes) {
							node.setStatus("nodata", noDataRes);
						}
					}
					// trigger fancytreeloadchildren
					tree._triggerNodeEvent("loadChildren", node);
				});
			},
			/** [Not Implemented]  */
			nodeLoadKeyPath: function(ctx, keyPathList) {
				// TODO: implement and improve
				// http://code.google.com/p/dynatree/issues/detail?id=222
			},
			/**
			 * Remove a single direct child of ctx.node.
			 * @param {EventData} ctx
			 * @param {FancytreeNode} childNode dircect child of ctx.node
			 */
			nodeRemoveChild: function(ctx, childNode) {
				var idx,
					node = ctx.node,
					// opts = ctx.options,
					subCtx = $.extend({}, ctx, { node: childNode }),
					children = node.children;

				// FT.debug("nodeRemoveChild()", node.toString(), childNode.toString());

				if (children.length === 1) {
					_assert(childNode === children[0], "invalid single child");
					return this.nodeRemoveChildren(ctx);
				}
				if (
					this.activeNode &&
					(childNode === this.activeNode ||
						this.activeNode.isDescendantOf(childNode))
				) {
					this.activeNode.setActive(false); // TODO: don't fire events
				}
				if (
					this.focusNode &&
					(childNode === this.focusNode ||
						this.focusNode.isDescendantOf(childNode))
				) {
					this.focusNode = null;
				}
				// TODO: persist must take care to clear select and expand cookies
				this.nodeRemoveMarkup(subCtx);
				this.nodeRemoveChildren(subCtx);
				idx = $.inArray(childNode, children);
				_assert(idx >= 0, "invalid child");
				// Notify listeners
				node.triggerModifyChild("remove", childNode);
				// Unlink to support GC
				childNode.visit(function(n) {
					n.parent = null;
				}, true);
				this._callHook("treeRegisterNode", this, false, childNode);
				// remove from child list
				children.splice(idx, 1);
			},
			/**Remove HTML markup for all descendents of ctx.node.
			 * @param {EventData} ctx
			 */
			nodeRemoveChildMarkup: function(ctx) {
				var node = ctx.node;

				// FT.debug("nodeRemoveChildMarkup()", node.toString());
				// TODO: Unlink attr.ftnode to support GC
				if (node.ul) {
					if (node.isRootNode()) {
						$(node.ul).empty();
					} else {
						$(node.ul).remove();
						node.ul = null;
					}
					node.visit(function(n) {
						n.li = n.ul = null;
					});
				}
			},
			/**Remove all descendants of ctx.node.
			 * @param {EventData} ctx
			 */
			nodeRemoveChildren: function(ctx) {
				var //subCtx,
					tree = ctx.tree,
					node = ctx.node,
					children = node.children;
				// opts = ctx.options;

				// FT.debug("nodeRemoveChildren()", node.toString());
				if (!children) {
					return;
				}
				if (this.activeNode && this.activeNode.isDescendantOf(node)) {
					this.activeNode.setActive(false); // TODO: don't fire events
				}
				if (this.focusNode && this.focusNode.isDescendantOf(node)) {
					this.focusNode = null;
				}
				// TODO: persist must take care to clear select and expand cookies
				this.nodeRemoveChildMarkup(ctx);
				// Unlink children to support GC
				// TODO: also delete this.children (not possible using visit())
				// subCtx = $.extend({}, ctx);
				node.triggerModifyChild("remove", null);
				node.visit(function(n) {
					n.parent = null;
					tree._callHook("treeRegisterNode", tree, false, n);
				});
				if (node.lazy) {
					// 'undefined' would be interpreted as 'not yet loaded' for lazy nodes
					node.children = [];
				} else {
					node.children = null;
				}
				if (!node.isRootNode()) {
					node.expanded = false; // #449, #459
				}
				this.nodeRenderStatus(ctx);
			},
			/**Remove HTML markup for ctx.node and all its descendents.
			 * @param {EventData} ctx
			 */
			nodeRemoveMarkup: function(ctx) {
				var node = ctx.node;
				// FT.debug("nodeRemoveMarkup()", node.toString());
				// TODO: Unlink attr.ftnode to support GC
				if (node.li) {
					$(node.li).remove();
					node.li = null;
				}
				this.nodeRemoveChildMarkup(ctx);
			},
			/**
			 * Create `<li><span>..</span> .. </li>` tags for this node.
			 *
			 * This method takes care that all HTML markup is created that is required
			 * to display this node in its current state.
			 *
			 * Call this method to create new nodes, or after the strucuture
			 * was changed (e.g. after moving this node or adding/removing children)
			 * nodeRenderTitle() and nodeRenderStatus() are implied.
			 * ```html
			 * <li id='KEY' ftnode=NODE>
			 *     <span class='fancytree-node fancytree-expanded fancytree-has-children fancytree-lastsib fancytree-exp-el fancytree-ico-e'>
			 *         <span class="fancytree-expander"></span>
			 *         <span class="fancytree-checkbox"></span> // only present in checkbox mode
			 *         <span class="fancytree-icon"></span>
			 *         <a href="#" class="fancytree-title"> Node 1 </a>
			 *     </span>
			 *     <ul> // only present if node has children
			 *         <li id='KEY' ftnode=NODE> child1 ... </li>
			 *         <li id='KEY' ftnode=NODE> child2 ... </li>
			 *     </ul>
			 * </li>
			 * ```
			 *
			 * @param {EventData} ctx
			 * @param {boolean} [force=false] re-render, even if html markup was already created
			 * @param {boolean} [deep=false] also render all descendants, even if parent is collapsed
			 * @param {boolean} [collapsed=false] force root node to be collapsed, so we can apply animated expand later
			 */
			nodeRender: function(ctx, force, deep, collapsed, _recursive) {
				/* This method must take care of all cases where the current data mode
				 * (i.e. node hierarchy) does not match the current markup.
				 *
				 * - node was not yet rendered:
				 *   create markup
				 * - node was rendered: exit fast
				 * - children have been added
				 * - children have been removed
				 */
				var childLI,
					childNode1,
					childNode2,
					i,
					l,
					next,
					subCtx,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					aria = opts.aria,
					firstTime = false,
					parent = node.parent,
					isRootNode = !parent,
					children = node.children,
					successorLi = null;
				// FT.debug("nodeRender(" + !!force + ", " + !!deep + ")", node.toString());

				if (tree._enableUpdate === false) {
					// tree.debug("no render", tree._enableUpdate);
					return;
				}
				if (!isRootNode && !parent.ul) {
					// Calling node.collapse on a deep, unrendered node
					return;
				}
				_assert(isRootNode || parent.ul, "parent UL must exist");

				// Render the node
				if (!isRootNode) {
					// Discard markup on force-mode, or if it is not linked to parent <ul>
					if (
						node.li &&
						(force || node.li.parentNode !== node.parent.ul)
					) {
						if (node.li.parentNode === node.parent.ul) {
							// #486: store following node, so we can insert the new markup there later
							successorLi = node.li.nextSibling;
						} else {
							// May happen, when a top-level node was dropped over another
							this.debug(
								"Unlinking " +
									node +
									" (must be child of " +
									node.parent +
									")"
							);
						}
						//	            this.debug("nodeRemoveMarkup...");
						this.nodeRemoveMarkup(ctx);
					}
					// Create <li><span /> </li>
					// node.debug("render...");
					if (node.li) {
						// this.nodeRenderTitle(ctx);
						this.nodeRenderStatus(ctx);
					} else {
						// node.debug("render... really");
						firstTime = true;
						node.li = document.createElement("li");
						node.li.ftnode = node;

						if (node.key && opts.generateIds) {
							node.li.id = opts.idPrefix + node.key;
						}
						node.span = document.createElement("span");
						node.span.className = "fancytree-node";
						if (aria && !node.tr) {
							$(node.li).attr("role", "treeitem");
						}
						node.li.appendChild(node.span);

						// Create inner HTML for the <span> (expander, checkbox, icon, and title)
						this.nodeRenderTitle(ctx);

						// Allow tweaking and binding, after node was created for the first time
						if (opts.createNode) {
							opts.createNode.call(
								tree,
								{ type: "createNode" },
								ctx
							);
						}
					}
					// Allow tweaking after node state was rendered
					if (opts.renderNode) {
						opts.renderNode.call(tree, { type: "renderNode" }, ctx);
					}
				}

				// Visit child nodes
				if (children) {
					if (isRootNode || node.expanded || deep === true) {
						// Create a UL to hold the children
						if (!node.ul) {
							node.ul = document.createElement("ul");
							if (
								(collapsed === true && !_recursive) ||
								!node.expanded
							) {
								// hide top UL, so we can use an animation to show it later
								node.ul.style.display = "none";
							}
							if (aria) {
								$(node.ul).attr("role", "group");
							}
							if (node.li) {
								// issue #67
								node.li.appendChild(node.ul);
							} else {
								node.tree.$div.append(node.ul);
							}
						}
						// Add child markup
						for (i = 0, l = children.length; i < l; i++) {
							subCtx = $.extend({}, ctx, { node: children[i] });
							this.nodeRender(subCtx, force, deep, false, true);
						}
						// Remove <li> if nodes have moved to another parent
						childLI = node.ul.firstChild;
						while (childLI) {
							childNode2 = childLI.ftnode;
							if (childNode2 && childNode2.parent !== node) {
								node.debug(
									"_fixParent: remove missing " + childNode2,
									childLI
								);
								next = childLI.nextSibling;
								childLI.parentNode.removeChild(childLI);
								childLI = next;
							} else {
								childLI = childLI.nextSibling;
							}
						}
						// Make sure, that <li> order matches node.children order.
						childLI = node.ul.firstChild;
						for (i = 0, l = children.length - 1; i < l; i++) {
							childNode1 = children[i];
							childNode2 = childLI.ftnode;
							if (childNode1 === childNode2) {
								childLI = childLI.nextSibling;
							} else {
								// node.debug("_fixOrder: mismatch at index " + i + ": " + childNode1 + " != " + childNode2);
								node.ul.insertBefore(
									childNode1.li,
									childNode2.li
								);
							}
						}
					}
				} else {
					// No children: remove markup if any
					if (node.ul) {
						// alert("remove child markup for " + node);
						this.warn("remove child markup for " + node);
						this.nodeRemoveChildMarkup(ctx);
					}
				}
				if (!isRootNode) {
					// Update element classes according to node state
					// this.nodeRenderStatus(ctx);
					// Finally add the whole structure to the DOM, so the browser can render
					if (firstTime) {
						// #486: successorLi is set, if we re-rendered (i.e. discarded)
						// existing markup, which  we want to insert at the same position.
						// (null is equivalent to append)
						// 		parent.ul.appendChild(node.li);
						parent.ul.insertBefore(node.li, successorLi);
					}
				}
			},
			/** Create HTML inside the node's outer `<span>` (i.e. expander, checkbox,
			 * icon, and title).
			 *
			 * nodeRenderStatus() is implied.
			 * @param {EventData} ctx
			 * @param {string} [title] optinal new title
			 */
			nodeRenderTitle: function(ctx, title) {
				// set node connector images, links and text
				var checkbox,
					className,
					icon,
					nodeTitle,
					role,
					tabindex,
					tooltip,
					iconTooltip,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					aria = opts.aria,
					level = node.getLevel(),
					ares = [];

				if (title !== undefined) {
					node.title = title;
				}
				if (!node.span || tree._enableUpdate === false) {
					// Silently bail out if node was not rendered yet, assuming
					// node.render() will be called as the node becomes visible
					return;
				}
				// Connector (expanded, expandable or simple)
				role =
					aria && node.hasChildren() !== false
						? " role='button'"
						: "";
				if (level < opts.minExpandLevel) {
					if (!node.lazy) {
						node.expanded = true;
					}
					if (level > 1) {
						ares.push(
							"<span " +
								role +
								" class='fancytree-expander fancytree-expander-fixed'></span>"
						);
					}
					// .. else (i.e. for root level) skip expander/connector alltogether
				} else {
					ares.push(
						"<span " + role + " class='fancytree-expander'></span>"
					);
				}
				// Checkbox mode
				checkbox = FT.evalOption("checkbox", node, node, opts, false);

				if (checkbox && !node.isStatusNode()) {
					role = aria ? " role='checkbox'" : "";
					className = "fancytree-checkbox";
					if (
						checkbox === "radio" ||
						(node.parent && node.parent.radiogroup)
					) {
						className += " fancytree-radio";
					}
					ares.push(
						"<span " + role + " class='" + className + "'></span>"
					);
				}
				// Folder or doctype icon
				if (node.data.iconClass !== undefined) {
					// 2015-11-16
					// Handle / warn about backward compatibility
					if (node.icon) {
						$.error(
							"'iconClass' node option is deprecated since v2.14.0: use 'icon' only instead"
						);
					} else {
						node.warn(
							"'iconClass' node option is deprecated since v2.14.0: use 'icon' instead"
						);
						node.icon = node.data.iconClass;
					}
				}
				// If opts.icon is a callback and returns something other than undefined, use that
				// else if node.icon is a boolean or string, use that
				// else if opts.icon is a boolean or string, use that
				// else show standard icon (which may be different for folders or documents)
				icon = FT.evalOption("icon", node, node, opts, true);
				// if( typeof icon !== "boolean" ) {
				// 	// icon is defined, but not true/false: must be a string
				// 	icon = "" + icon;
				// }
				if (icon !== false) {
					role = aria ? " role='presentation'" : "";

					iconTooltip = FT.evalOption(
						"iconTooltip",
						node,
						node,
						opts,
						null
					);
					iconTooltip = iconTooltip
						? " title='" + _escapeTooltip(iconTooltip) + "'"
						: "";

					if (typeof icon === "string") {
						if (TEST_IMG.test(icon)) {
							// node.icon is an image url. Prepend imagePath
							icon =
								icon.charAt(0) === "/"
									? icon
									: (opts.imagePath || "") + icon;
							ares.push(
								"<img src='" +
									icon +
									"' class='fancytree-icon'" +
									iconTooltip +
									" alt='' />"
							);
						} else {
							ares.push(
								"<span " +
									role +
									" class='fancytree-custom-icon " +
									icon +
									"'" +
									iconTooltip +
									"></span>"
							);
						}
					} else if (icon.text) {
						ares.push(
							"<span " +
								role +
								" class='fancytree-custom-icon " +
								(icon.addClass || "") +
								"'" +
								iconTooltip +
								">" +
								FT.escapeHtml(icon.text) +
								"</span>"
						);
					} else if (icon.html) {
						ares.push(
							"<span " +
								role +
								" class='fancytree-custom-icon " +
								(icon.addClass || "") +
								"'" +
								iconTooltip +
								">" +
								icon.html +
								"</span>"
						);
					} else {
						// standard icon: theme css will take care of this
						ares.push(
							"<span " +
								role +
								" class='fancytree-icon'" +
								iconTooltip +
								"></span>"
						);
					}
				}
				// Node title
				nodeTitle = "";
				if (opts.renderTitle) {
					nodeTitle =
						opts.renderTitle.call(
							tree,
							{ type: "renderTitle" },
							ctx
						) || "";
				}
				if (!nodeTitle) {
					tooltip = FT.evalOption("tooltip", node, node, opts, null);
					if (tooltip === true) {
						tooltip = node.title;
					}
					// if( node.tooltip ) {
					// 	tooltip = node.tooltip;
					// } else if ( opts.tooltip ) {
					// 	tooltip = opts.tooltip === true ? node.title : opts.tooltip.call(tree, node);
					// }
					tooltip = tooltip
						? " title='" + _escapeTooltip(tooltip) + "'"
						: "";
					tabindex = opts.titlesTabbable ? " tabindex='0'" : "";

					nodeTitle =
						"<span class='fancytree-title'" +
						tooltip +
						tabindex +
						">" +
						(opts.escapeTitles
							? FT.escapeHtml(node.title)
							: node.title) +
						"</span>";
				}
				ares.push(nodeTitle);
				// Note: this will trigger focusout, if node had the focus
				//$(node.span).html(ares.join("")); // it will cleanup the jQuery data currently associated with SPAN (if any), but it executes more slowly
				node.span.innerHTML = ares.join("");
				// Update CSS classes
				this.nodeRenderStatus(ctx);
				if (opts.enhanceTitle) {
					ctx.$title = $(">span.fancytree-title", node.span);
					nodeTitle =
						opts.enhanceTitle.call(
							tree,
							{ type: "enhanceTitle" },
							ctx
						) || "";
				}
			},
			/** Update element classes according to node state.
			 * @param {EventData} ctx
			 */
			nodeRenderStatus: function(ctx) {
				// Set classes for current status
				var $ariaElem,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					// 	nodeContainer = node[tree.nodeContainerAttrName],
					hasChildren = node.hasChildren(),
					isLastSib = node.isLastSibling(),
					aria = opts.aria,
					cn = opts._classNames,
					cnList = [],
					statusElem = node[tree.statusClassPropName];

				if (!statusElem || tree._enableUpdate === false) {
					// if this function is called for an unrendered node, ignore it (will be updated on nect render anyway)
					return;
				}
				if (aria) {
					$ariaElem = $(node.tr || node.li);
				}
				// Build a list of class names that we will add to the node <span>
				cnList.push(cn.node);
				if (tree.activeNode === node) {
					cnList.push(cn.active);
					// 		$(">span.fancytree-title", statusElem).attr("tabindex", "0");
					// 		tree.$container.removeAttr("tabindex");
					// }else{
					// 		$(">span.fancytree-title", statusElem).removeAttr("tabindex");
					// 		tree.$container.attr("tabindex", "0");
				}
				if (tree.focusNode === node) {
					cnList.push(cn.focused);
				}
				if (node.expanded) {
					cnList.push(cn.expanded);
				}
				if (aria) {
					if (hasChildren === false) {
						$ariaElem.removeAttr("aria-expanded");
					} else {
						$ariaElem.attr("aria-expanded", Boolean(node.expanded));
					}
				}
				if (node.folder) {
					cnList.push(cn.folder);
				}
				if (hasChildren !== false) {
					cnList.push(cn.hasChildren);
				}
				// TODO: required?
				if (isLastSib) {
					cnList.push(cn.lastsib);
				}
				if (node.lazy && node.children == null) {
					cnList.push(cn.lazy);
				}
				if (node.partload) {
					cnList.push(cn.partload);
				}
				if (node.partsel) {
					cnList.push(cn.partsel);
				}
				if (FT.evalOption("unselectable", node, node, opts, false)) {
					cnList.push(cn.unselectable);
				}
				if (node._isLoading) {
					cnList.push(cn.loading);
				}
				if (node._error) {
					cnList.push(cn.error);
				}
				if (node.statusNodeType) {
					cnList.push(cn.statusNodePrefix + node.statusNodeType);
				}
				if (node.selected) {
					cnList.push(cn.selected);
					if (aria) {
						$ariaElem.attr("aria-selected", true);
					}
				} else if (aria) {
					$ariaElem.attr("aria-selected", false);
				}
				if (node.extraClasses) {
					cnList.push(node.extraClasses);
				}
				// IE6 doesn't correctly evaluate multiple class names,
				// so we create combined class names that can be used in the CSS
				if (hasChildren === false) {
					cnList.push(
						cn.combinedExpanderPrefix + "n" + (isLastSib ? "l" : "")
					);
				} else {
					cnList.push(
						cn.combinedExpanderPrefix +
							(node.expanded ? "e" : "c") +
							(node.lazy && node.children == null ? "d" : "") +
							(isLastSib ? "l" : "")
					);
				}
				cnList.push(
					cn.combinedIconPrefix +
						(node.expanded ? "e" : "c") +
						(node.folder ? "f" : "")
				);
				// node.span.className = cnList.join(" ");
				statusElem.className = cnList.join(" ");

				// TODO: we should not set this in the <span> tag also, if we set it here:
				// Maybe most (all) of the classes should be set in LI instead of SPAN?
				if (node.li) {
					// #719: we have to consider that there may be already other classes:
					$(node.li).toggleClass(cn.lastsib, isLastSib);
				}
			},
			/** Activate node.
			 * flag defaults to true.
			 * If flag is true, the node is activated (must be a synchronous operation)
			 * If flag is false, the node is deactivated (must be a synchronous operation)
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 * @param {object} [opts] additional options. Defaults to {noEvents: false, noFocus: false}
			 * @returns {$.Promise}
			 */
			nodeSetActive: function(ctx, flag, callOpts) {
				// Handle user click / [space] / [enter], according to clickFolderMode.
				callOpts = callOpts || {};
				var subCtx,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					noEvents = callOpts.noEvents === true,
					noFocus = callOpts.noFocus === true,
					scroll = callOpts.scrollIntoView !== false,
					isActive = node === tree.activeNode;

				// flag defaults to true
				flag = flag !== false;
				// node.debug("nodeSetActive", flag);

				if (isActive === flag) {
					// Nothing to do
					return _getResolvedPromise(node);
				} else if (
					flag &&
					!noEvents &&
					this._triggerNodeEvent(
						"beforeActivate",
						node,
						ctx.originalEvent
					) === false
				) {
					// Callback returned false
					return _getRejectedPromise(node, ["rejected"]);
				}
				if (flag) {
					if (tree.activeNode) {
						_assert(
							tree.activeNode !== node,
							"node was active (inconsistency)"
						);
						subCtx = $.extend({}, ctx, { node: tree.activeNode });
						tree.nodeSetActive(subCtx, false);
						_assert(
							tree.activeNode === null,
							"deactivate was out of sync?"
						);
					}

					if (opts.activeVisible) {
						// If no focus is set (noFocus: true) and there is no focused node, this node is made visible.
						// scroll = noFocus && tree.focusNode == null;
						// #863: scroll by default (unless `scrollIntoView: false` was passed)
						node.makeVisible({ scrollIntoView: scroll });
					}
					tree.activeNode = node;
					tree.nodeRenderStatus(ctx);
					if (!noFocus) {
						tree.nodeSetFocus(ctx);
					}
					if (!noEvents) {
						tree._triggerNodeEvent(
							"activate",
							node,
							ctx.originalEvent
						);
					}
				} else {
					_assert(
						tree.activeNode === node,
						"node was not active (inconsistency)"
					);
					tree.activeNode = null;
					this.nodeRenderStatus(ctx);
					if (!noEvents) {
						ctx.tree._triggerNodeEvent(
							"deactivate",
							node,
							ctx.originalEvent
						);
					}
				}
				return _getResolvedPromise(node);
			},
			/** Expand or collapse node, return Deferred.promise.
			 *
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 * @param {object} [opts] additional options. Defaults to `{noAnimation: false, noEvents: false}`
			 * @returns {$.Promise} The deferred will be resolved as soon as the (lazy)
			 *     data was retrieved, rendered, and the expand animation finished.
			 */
			nodeSetExpanded: function(ctx, flag, callOpts) {
				callOpts = callOpts || {};
				var _afterLoad,
					dfd,
					i,
					l,
					parents,
					prevAC,
					node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					noAnimation = callOpts.noAnimation === true,
					noEvents = callOpts.noEvents === true;

				// flag defaults to true
				flag = flag !== false;

				// node.debug("nodeSetExpanded(" + flag + ")");

				if ((node.expanded && flag) || (!node.expanded && !flag)) {
					// Nothing to do
					// node.debug("nodeSetExpanded(" + flag + "): nothing to do");
					return _getResolvedPromise(node);
				} else if (flag && !node.lazy && !node.hasChildren()) {
					// Prevent expanding of empty nodes
					// return _getRejectedPromise(node, ["empty"]);
					return _getResolvedPromise(node);
				} else if (!flag && node.getLevel() < opts.minExpandLevel) {
					// Prevent collapsing locked levels
					return _getRejectedPromise(node, ["locked"]);
				} else if (
					!noEvents &&
					this._triggerNodeEvent(
						"beforeExpand",
						node,
						ctx.originalEvent
					) === false
				) {
					// Callback returned false
					return _getRejectedPromise(node, ["rejected"]);
				}
				// If this node inside a collpased node, no animation and scrolling is needed
				if (!noAnimation && !node.isVisible()) {
					noAnimation = callOpts.noAnimation = true;
				}

				dfd = new $.Deferred();

				// Auto-collapse mode: collapse all siblings
				if (flag && !node.expanded && opts.autoCollapse) {
					parents = node.getParentList(false, true);
					prevAC = opts.autoCollapse;
					try {
						opts.autoCollapse = false;
						for (i = 0, l = parents.length; i < l; i++) {
							// TODO: should return promise?
							this._callHook(
								"nodeCollapseSiblings",
								parents[i],
								callOpts
							);
						}
					} finally {
						opts.autoCollapse = prevAC;
					}
				}
				// Trigger expand/collapse after expanding
				dfd.done(function() {
					var lastChild = node.getLastChild();

					if (
						flag &&
						opts.autoScroll &&
						!noAnimation &&
						lastChild &&
						tree._enableUpdate
					) {
						// Scroll down to last child, but keep current node visible
						lastChild
							.scrollIntoView(true, { topNode: node })
							.always(function() {
								if (!noEvents) {
									ctx.tree._triggerNodeEvent(
										flag ? "expand" : "collapse",
										ctx
									);
								}
							});
					} else {
						if (!noEvents) {
							ctx.tree._triggerNodeEvent(
								flag ? "expand" : "collapse",
								ctx
							);
						}
					}
				});
				// vvv Code below is executed after loading finished:
				_afterLoad = function(callback) {
					var cn = opts._classNames,
						isVisible,
						isExpanded,
						effect = opts.toggleEffect;

					node.expanded = flag;
					tree._callHook(
						"treeStructureChanged",
						ctx,
						flag ? "expand" : "collapse"
					);
					// Create required markup, but make sure the top UL is hidden, so we
					// can animate later
					tree._callHook("nodeRender", ctx, false, false, true);

					// Hide children, if node is collapsed
					if (node.ul) {
						isVisible = node.ul.style.display !== "none";
						isExpanded = !!node.expanded;
						if (isVisible === isExpanded) {
							node.warn(
								"nodeSetExpanded: UL.style.display already set"
							);
						} else if (!effect || noAnimation) {
							node.ul.style.display =
								node.expanded || !parent ? "" : "none";
						} else {
							// The UI toggle() effect works with the ext-wide extension,
							// while jQuery.animate() has problems when the title span
							// has position: absolute.
							// Since jQuery UI 1.12, the blind effect requires the parent
							// element to have 'position: relative'.
							// See #716, #717
							$(node.li).addClass(cn.animating); // #717

							if ($.isFunction($(node.ul)[effect.effect])) {
								// tree.debug( "use jquery." + effect.effect + " method" );
								$(node.ul)[effect.effect]({
									duration: effect.duration,
									always: function() {
										// node.debug("fancytree-animating end: " + node.li.className);
										$(this).removeClass(cn.animating); // #716
										$(node.li).removeClass(cn.animating); // #717
										callback();
									},
								});
							} else {
								// The UI toggle() effect works with the ext-wide extension,
								// while jQuery.animate() has problems when the title span
								// has positon: absolute.
								// Since jQuery UI 1.12, the blind effect requires the parent
								// element to have 'position: relative'.
								// See #716, #717
								// tree.debug("use specified effect (" + effect.effect + ") with the jqueryui.toggle method");

								// try to stop an animation that might be already in progress
								$(node.ul).stop(true, true); //< does not work after resetLazy has been called for a node whose animation wasn't complete and effect was "blind"

								// dirty fix to remove a defunct animation (effect: "blind") after resetLazy has been called
								$(node.ul)
									.parent()
									.find(".ui-effects-placeholder")
									.remove();

								$(node.ul).toggle(
									effect.effect,
									effect.options,
									effect.duration,
									function() {
										// node.debug("fancytree-animating end: " + node.li.className);
										$(this).removeClass(cn.animating); // #716
										$(node.li).removeClass(cn.animating); // #717
										callback();
									}
								);
							}
							return;
						}
					}
					callback();
				};
				// ^^^ Code above is executed after loading finshed.

				// Load lazy nodes, if any. Then continue with _afterLoad()
				if (flag && node.lazy && node.hasChildren() === undefined) {
					// node.debug("nodeSetExpanded: load start...");
					node.load()
						.done(function() {
							// node.debug("nodeSetExpanded: load done");
							if (dfd.notifyWith) {
								// requires jQuery 1.6+
								dfd.notifyWith(node, ["loaded"]);
							}
							_afterLoad(function() {
								dfd.resolveWith(node);
							});
						})
						.fail(function(errMsg) {
							_afterLoad(function() {
								dfd.rejectWith(node, [
									"load failed (" + errMsg + ")",
								]);
							});
						});
					/*
					var source = tree._triggerNodeEvent("lazyLoad", node, ctx.originalEvent);
					_assert(typeof source !== "boolean", "lazyLoad event must return source in data.result");
					node.debug("nodeSetExpanded: load start...");
					this._callHook("nodeLoadChildren", ctx, source).done(function(){
						node.debug("nodeSetExpanded: load done");
						if(dfd.notifyWith){ // requires jQuery 1.6+
							dfd.notifyWith(node, ["loaded"]);
						}
						_afterLoad.call(tree);
					}).fail(function(errMsg){
						dfd.rejectWith(node, ["load failed (" + errMsg + ")"]);
					});
					*/
				} else {
					_afterLoad(function() {
						dfd.resolveWith(node);
					});
				}
				// node.debug("nodeSetExpanded: returns");
				return dfd.promise();
			},
			/** Focus or blur this node.
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 */
			nodeSetFocus: function(ctx, flag) {
				// ctx.node.debug("nodeSetFocus(" + flag + ")");
				var ctx2,
					tree = ctx.tree,
					node = ctx.node,
					opts = tree.options,
					// et = ctx.originalEvent && ctx.originalEvent.type,
					isInput = ctx.originalEvent
						? $(ctx.originalEvent.target).is(":input")
						: false;

				flag = flag !== false;

				// (node || tree).debug("nodeSetFocus(" + flag + "), event: " + et + ", isInput: "+ isInput);
				// Blur previous node if any
				if (tree.focusNode) {
					if (tree.focusNode === node && flag) {
						// node.debug("nodeSetFocus(" + flag + "): nothing to do");
						return;
					}
					ctx2 = $.extend({}, ctx, { node: tree.focusNode });
					tree.focusNode = null;
					this._triggerNodeEvent("blur", ctx2);
					this._callHook("nodeRenderStatus", ctx2);
				}
				// Set focus to container and node
				if (flag) {
					if (!this.hasFocus()) {
						node.debug("nodeSetFocus: forcing container focus");
						this._callHook("treeSetFocus", ctx, true, {
							calledByNode: true,
						});
					}
					node.makeVisible({ scrollIntoView: false });
					tree.focusNode = node;
					if (opts.titlesTabbable) {
						if (!isInput) {
							// #621
							$(node.span)
								.find(".fancytree-title")
								.focus();
						}
					}
					if (opts.aria) {
						// Set active descendant to node's span ID (create one, if needed)
						$(tree.$container).attr(
							"aria-activedescendant",
							$(node.tr || node.li)
								.uniqueId()
								.attr("id")
						);
						// "ftal_" + opts.idPrefix + node.key);
					}
					// $(node.span).find(".fancytree-title").focus();
					this._triggerNodeEvent("focus", ctx);

					// determine if we have focus on or inside tree container
					var hasFancytreeFocus =
						document.activeElement === tree.$container.get(0) ||
						$(document.activeElement, tree.$container).length >= 1;

					if (!hasFancytreeFocus) {
						// We cannot set KB focus to a node, so use the tree container
						// #563, #570: IE scrolls on every call to .focus(), if the container
						// is partially outside the viewport. So do it only, when absolutely
						// necessary.
						$(tree.$container).focus();
					}

					// if( opts.autoActivate ){
					// 	tree.nodeSetActive(ctx, true);
					// }
					if (opts.autoScroll) {
						node.scrollIntoView();
					}
					this._callHook("nodeRenderStatus", ctx);
				}
			},
			/** (De)Select node, return new status (sync).
			 *
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 * @param {object} [opts] additional options. Defaults to {noEvents: false,
			 *     propagateDown: null, propagateUp: null,
			 *     callback: null,
			 *     }
			 * @returns {boolean} previous status
			 */
			nodeSetSelected: function(ctx, flag, callOpts) {
				callOpts = callOpts || {};
				var node = ctx.node,
					tree = ctx.tree,
					opts = ctx.options,
					noEvents = callOpts.noEvents === true,
					parent = node.parent;

				// flag defaults to true
				flag = flag !== false;

				// node.debug("nodeSetSelected(" + flag + ")", ctx);

				// Cannot (de)select unselectable nodes directly (only by propagation or
				// by setting the `.selected` property)
				if (FT.evalOption("unselectable", node, node, opts, false)) {
					return;
				}

				// Remember the user's intent, in case down -> up propagation prevents
				// applying it to node.selected
				node._lastSelectIntent = flag; // Confusing use of '!'

				// Nothing to do?
				if (!!node.selected === flag) {
					if (opts.selectMode === 3 && node.partsel && !flag) {
						// If propagation prevented selecting this node last time, we still
						// want to allow to apply setSelected(false) now
					} else {
						return flag;
					}
				}

				if (
					!noEvents &&
					this._triggerNodeEvent(
						"beforeSelect",
						node,
						ctx.originalEvent
					) === false
				) {
					return !!node.selected;
				}
				if (flag && opts.selectMode === 1) {
					// single selection mode (we don't uncheck all tree nodes, for performance reasons)
					if (tree.lastSelectedNode) {
						tree.lastSelectedNode.setSelected(false);
					}
					node.selected = flag;
				} else if (
					opts.selectMode === 3 &&
					parent &&
					!parent.radiogroup &&
					!node.radiogroup
				) {
					// multi-hierarchical selection mode
					node.selected = flag;
					node.fixSelection3AfterClick(callOpts);
				} else if (parent && parent.radiogroup) {
					node.visitSiblings(function(n) {
						n._changeSelectStatusAttrs(flag && n === node);
					}, true);
				} else {
					// default: selectMode: 2, multi selection mode
					node.selected = flag;
				}
				this.nodeRenderStatus(ctx);
				tree.lastSelectedNode = flag ? node : null;
				if (!noEvents) {
					tree._triggerNodeEvent("select", ctx);
				}
			},
			/** Show node status (ok, loading, error, nodata) using styles and a dummy child node.
			 *
			 * @param {EventData} ctx
			 * @param status
			 * @param message
			 * @param details
			 * @since 2.3
			 */
			nodeSetStatus: function(ctx, status, message, details) {
				var node = ctx.node,
					tree = ctx.tree;

				function _clearStatusNode() {
					// Remove dedicated dummy node, if any
					var firstChild = node.children ? node.children[0] : null;
					if (firstChild && firstChild.isStatusNode()) {
						try {
							// I've seen exceptions here with loadKeyPath...
							if (node.ul) {
								node.ul.removeChild(firstChild.li);
								firstChild.li = null; // avoid leaks (DT issue 215)
							}
						} catch (e) {}
						if (node.children.length === 1) {
							node.children = [];
						} else {
							node.children.shift();
						}
						tree._callHook(
							"treeStructureChanged",
							ctx,
							"clearStatusNode"
						);
					}
				}
				function _setStatusNode(data, type) {
					// Create/modify the dedicated dummy node for 'loading...' or
					// 'error!' status. (only called for direct child of the invisible
					// system root)
					var firstChild = node.children ? node.children[0] : null;
					if (firstChild && firstChild.isStatusNode()) {
						$.extend(firstChild, data);
						firstChild.statusNodeType = type;
						tree._callHook("nodeRenderTitle", firstChild);
					} else {
						node._setChildren([data]);
						tree._callHook(
							"treeStructureChanged",
							ctx,
							"setStatusNode"
						);
						node.children[0].statusNodeType = type;
						tree.render();
					}
					return node.children[0];
				}

				switch (status) {
					case "ok":
						_clearStatusNode();
						node._isLoading = false;
						node._error = null;
						node.renderStatus();
						break;
					case "loading":
						if (!node.parent) {
							_setStatusNode(
								{
									title:
										tree.options.strings.loading +
										(message ? " (" + message + ")" : ""),
									// icon: true,  // needed for 'loding' icon
									checkbox: false,
									tooltip: details,
								},
								status
							);
						}
						node._isLoading = true;
						node._error = null;
						node.renderStatus();
						break;
					case "error":
						_setStatusNode(
							{
								title:
									tree.options.strings.loadError +
									(message ? " (" + message + ")" : ""),
								// icon: false,
								checkbox: false,
								tooltip: details,
							},
							status
						);
						node._isLoading = false;
						node._error = { message: message, details: details };
						node.renderStatus();
						break;
					case "nodata":
						_setStatusNode(
							{
								title: message || tree.options.strings.noData,
								// icon: false,
								checkbox: false,
								tooltip: details,
							},
							status
						);
						node._isLoading = false;
						node._error = null;
						node.renderStatus();
						break;
					default:
						$.error("invalid node status " + status);
				}
			},
			/**
			 *
			 * @param {EventData} ctx
			 */
			nodeToggleExpanded: function(ctx) {
				return this.nodeSetExpanded(ctx, !ctx.node.expanded);
			},
			/**
			 * @param {EventData} ctx
			 */
			nodeToggleSelected: function(ctx) {
				var node = ctx.node,
					flag = !node.selected;

				// In selectMode: 3 this node may be unselected+partsel, even if
				// setSelected(true) was called before, due to `unselectable` children.
				// In this case, we now toggle as `setSelected(false)`
				if (
					node.partsel &&
					!node.selected &&
					node._lastSelectIntent === true
				) {
					flag = false;
					node.selected = true; // so it is not considered 'nothing to do'
				}
				node._lastSelectIntent = flag;
				return this.nodeSetSelected(ctx, flag);
			},
			/** Remove all nodes.
			 * @param {EventData} ctx
			 */
			treeClear: function(ctx) {
				var tree = ctx.tree;
				tree.activeNode = null;
				tree.focusNode = null;
				tree.$div.find(">ul.fancytree-container").empty();
				// TODO: call destructors and remove reference loops
				tree.rootNode.children = null;
				tree._callHook("treeStructureChanged", ctx, "clear");
			},
			/** Widget was created (called only once, even it re-initialized).
			 * @param {EventData} ctx
			 */
			treeCreate: function(ctx) {},
			/** Widget was destroyed.
			 * @param {EventData} ctx
			 */
			treeDestroy: function(ctx) {
				this.$div.find(">ul.fancytree-container").remove();
				if (this.$source) {
					this.$source.removeClass("fancytree-helper-hidden");
				}
			},
			/** Widget was (re-)initialized.
			 * @param {EventData} ctx
			 */
			treeInit: function(ctx) {
				var tree = ctx.tree,
					opts = tree.options;

				//this.debug("Fancytree.treeInit()");
				// Add container to the TAB chain
				// See http://www.w3.org/TR/wai-aria-practices/#focus_activedescendant
				// #577: Allow to set tabindex to "0", "-1" and ""
				tree.$container.attr("tabindex", opts.tabindex);

				// Copy some attributes to tree.data
				$.each(TREE_ATTRS, function(i, attr) {
					if (opts[attr] !== undefined) {
						tree.info("Move option " + attr + " to tree");
						tree[attr] = opts[attr];
						delete opts[attr];
					}
				});

				if (opts.checkboxAutoHide) {
					tree.$container.addClass("fancytree-checkbox-auto-hide");
				}
				if (opts.rtl) {
					tree.$container
						.attr("DIR", "RTL")
						.addClass("fancytree-rtl");
				} else {
					tree.$container
						.removeAttr("DIR")
						.removeClass("fancytree-rtl");
				}
				if (opts.aria) {
					tree.$container.attr("role", "tree");
					if (opts.selectMode !== 1) {
						tree.$container.attr("aria-multiselectable", true);
					}
				}
				this.treeLoad(ctx);
			},
			/** Parse Fancytree from source, as configured in the options.
			 * @param {EventData} ctx
			 * @param {object} [source] optional new source (use last data otherwise)
			 */
			treeLoad: function(ctx, source) {
				var metaData,
					type,
					$ul,
					tree = ctx.tree,
					$container = ctx.widget.element,
					dfd,
					// calling context for root node
					rootCtx = $.extend({}, ctx, { node: this.rootNode });

				if (tree.rootNode.children) {
					this.treeClear(ctx);
				}
				source = source || this.options.source;

				if (!source) {
					type = $container.data("type") || "html";
					switch (type) {
						case "html":
							// There should be an embedded `<ul>` with initial nodes,
							// but another `<ul class='fancytree-container'>` is appended
							// to the tree's <div> on startup anyway.
							$ul = $container
								.find(">ul")
								.not(".fancytree-container")
								.first();

							if ($ul.length) {
								$ul.addClass(
									"ui-fancytree-source fancytree-helper-hidden"
								);
								source = $.ui.fancytree.parseHtml($ul);
								// allow to init tree.data.foo from <ul data-foo=''>
								this.data = $.extend(
									this.data,
									_getElementDataAsDict($ul)
								);
							} else {
								FT.warn(
									"No `source` option was passed and container does not contain `<ul>`: assuming `source: []`."
								);
								source = [];
							}
							break;
						case "json":
							source = $.parseJSON($container.text());
							// $container already contains the <ul>, but we remove the plain (json) text
							// $container.empty();
							$container
								.contents()
								.filter(function() {
									return this.nodeType === 3;
								})
								.remove();
							if ($.isPlainObject(source)) {
								// We got {foo: 'abc', children: [...]}
								_assert(
									$.isArray(source.children),
									"if an object is passed as source, it must contain a 'children' array (all other properties are added to 'tree.data')"
								);
								metaData = source;
								source = source.children;
								delete metaData.children;
								// Copy some attributes to tree.data
								$.each(TREE_ATTRS, function(i, attr) {
									if (metaData[attr] !== undefined) {
										tree[attr] = metaData[attr];
										delete metaData[attr];
									}
								});
								// Copy extra properties to tree.data.foo
								$.extend(tree.data, metaData);
							}
							break;
						default:
							$.error("Invalid data-type: " + type);
					}
				} else if (typeof source === "string") {
					// TODO: source is an element ID
					$.error("Not implemented");
				}

				// preInit is fired when the widget markup is created, but nodes
				// not yet loaded
				tree._triggerTreeEvent("preInit", null);

				// Trigger fancytreeinit after nodes have been loaded
				dfd = this.nodeLoadChildren(rootCtx, source)
					.done(function() {
						tree._callHook(
							"treeStructureChanged",
							ctx,
							"loadChildren"
						);
						tree.render();
						if (ctx.options.selectMode === 3) {
							tree.rootNode.fixSelection3FromEndNodes();
						}
						if (tree.activeNode && tree.options.activeVisible) {
							tree.activeNode.makeVisible();
						}
						tree._triggerTreeEvent("init", null, { status: true });
					})
					.fail(function() {
						tree.render();
						tree._triggerTreeEvent("init", null, { status: false });
					});
				return dfd;
			},
			/** Node was inserted into or removed from the tree.
			 * @param {EventData} ctx
			 * @param {boolean} add
			 * @param {FancytreeNode} node
			 */
			treeRegisterNode: function(ctx, add, node) {
				ctx.tree._callHook(
					"treeStructureChanged",
					ctx,
					add ? "addNode" : "removeNode"
				);
			},
			/** Widget got focus.
			 * @param {EventData} ctx
			 * @param {boolean} [flag=true]
			 */
			treeSetFocus: function(ctx, flag, callOpts) {
				var targetNode;

				flag = flag !== false;

				// this.debug("treeSetFocus(" + flag + "), callOpts: ", callOpts, this.hasFocus());
				// this.debug("    focusNode: " + this.focusNode);
				// this.debug("    activeNode: " + this.activeNode);
				if (flag !== this.hasFocus()) {
					this._hasFocus = flag;
					if (!flag && this.focusNode) {
						// Node also looses focus if widget blurs
						this.focusNode.setFocus(false);
					} else if (flag && (!callOpts || !callOpts.calledByNode)) {
						$(this.$container).focus();
					}
					this.$container.toggleClass("fancytree-treefocus", flag);
					this._triggerTreeEvent(flag ? "focusTree" : "blurTree");
					if (flag && !this.activeNode) {
						// #712: Use last mousedowned node ('click' event fires after focusin)
						targetNode =
							this._lastMousedownNode || this.getFirstChild();
						if (targetNode) {
							targetNode.setFocus();
						}
					}
				}
			},
			/** Widget option was set using `$().fancytree("option", "KEY", VALUE)`.
			 *
			 * Note: `key` may reference a nested option, e.g. 'dnd5.scroll'.
			 * In this case `value`contains the complete, modified `dnd5` option hash.
			 * We can check for changed values like
			 *     if( value.scroll !== tree.options.dnd5.scroll ) {...}
			 *
			 * @param {EventData} ctx
			 * @param {string} key option name
			 * @param {any} value option value
			 */
			treeSetOption: function(ctx, key, value) {
				var tree = ctx.tree,
					callDefault = true,
					callCreate = false,
					callRender = false;

				switch (key) {
					case "aria":
					case "checkbox":
					case "icon":
					case "minExpandLevel":
					case "tabindex":
						// tree._callHook("treeCreate", tree);
						callCreate = true;
						callRender = true;
						break;
					case "checkboxAutoHide":
						tree.$container.toggleClass(
							"fancytree-checkbox-auto-hide",
							!!value
						);
						break;
					case "escapeTitles":
					case "tooltip":
						callRender = true;
						break;
					case "rtl":
						if (value === false) {
							tree.$container
								.removeAttr("DIR")
								.removeClass("fancytree-rtl");
						} else {
							tree.$container
								.attr("DIR", "RTL")
								.addClass("fancytree-rtl");
						}
						callRender = true;
						break;
					case "source":
						callDefault = false;
						tree._callHook("treeLoad", tree, value);
						callRender = true;
						break;
				}
				tree.debug(
					"set option " +
						key +
						"=" +
						value +
						" <" +
						typeof value +
						">"
				);
				if (callDefault) {
					if (this.widget._super) {
						// jQuery UI 1.9+
						this.widget._super.call(this.widget, key, value);
					} else {
						// jQuery UI <= 1.8, we have to manually invoke the _setOption method from the base widget
						$.Widget.prototype._setOption.call(
							this.widget,
							key,
							value
						);
					}
				}
				if (callCreate) {
					tree._callHook("treeCreate", tree);
				}
				if (callRender) {
					tree.render(true, false); // force, not-deep
				}
			},
			/** A Node was added, removed, moved, or it's visibility changed.
			 * @param {EventData} ctx
			 */
			treeStructureChanged: function(ctx, type) {},
		}
	);

	/*******************************************************************************
	 * jQuery UI widget boilerplate
	 */

	/**
	 * The plugin (derrived from <a href=" http://api.jqueryui.com/jQuery.widget/">jQuery.Widget</a>).<br>
	 * This constructor is not called directly. Use `$(selector).fancytree({})`
	 * to initialize the plugin instead.<br>
	 * <pre class="sh_javascript sunlight-highlight-javascript">// Access widget methods and members:
	 * var tree = $("#tree").fancytree("getTree");
	 * var node = $("#tree").fancytree("getActiveNode", "1234");
	 * </pre>
	 *
	 * @mixin Fancytree_Widget
	 */

	$.widget(
		"ui.fancytree",
		/** @lends Fancytree_Widget# */
		{
			/**These options will be used as defaults
			 * @type {FancytreeOptions}
			 */
			options: {
				activeVisible: true,
				ajax: {
					type: "GET",
					cache: false, // false: Append random '_' argument to the request url to prevent caching.
					// timeout: 0, // >0: Make sure we get an ajax error if server is unreachable
					dataType: "json", // Expect json format and pass json object to callbacks.
				},
				aria: true,
				autoActivate: true,
				autoCollapse: false,
				autoScroll: false,
				checkbox: false,
				clickFolderMode: 4,
				debugLevel: null, // 0..4 (null: use global setting $.ui.fancytree.debugLevel)
				disabled: false, // TODO: required anymore?
				enableAspx: true,
				escapeTitles: false,
				extensions: [],
				// fx: { height: "toggle", duration: 200 },
				// toggleEffect: { effect: "drop", options: {direction: "left"}, duration: 200 },
				// toggleEffect: { effect: "slide", options: {direction: "up"}, duration: 200 },
				//toggleEffect: { effect: "blind", options: {direction: "vertical", scale: "box"}, duration: 200 },
				toggleEffect: { effect: "slideToggle", duration: 200 }, //< "toggle" or "slideToggle" to use jQuery instead of jQueryUI for toggleEffect animation
				generateIds: false,
				icon: true,
				idPrefix: "ft_",
				focusOnSelect: false,
				keyboard: true,
				keyPathSeparator: "/",
				minExpandLevel: 1,
				nodata: true, // (bool, string, or callback) display message, when no data available
				quicksearch: false,
				rtl: false,
				scrollOfs: { top: 0, bottom: 0 },
				scrollParent: null,
				selectMode: 2,
				strings: {
					loading: "Loading...", // &#8230; would be escaped when escapeTitles is true
					loadError: "Load error!",
					moreData: "More...",
					noData: "No data.",
				},
				tabindex: "0",
				titlesTabbable: false,
				tooltip: false,
				treeId: null,
				_classNames: {
					node: "fancytree-node",
					folder: "fancytree-folder",
					animating: "fancytree-animating",
					combinedExpanderPrefix: "fancytree-exp-",
					combinedIconPrefix: "fancytree-ico-",
					hasChildren: "fancytree-has-children",
					active: "fancytree-active",
					selected: "fancytree-selected",
					expanded: "fancytree-expanded",
					lazy: "fancytree-lazy",
					focused: "fancytree-focused",
					partload: "fancytree-partload",
					partsel: "fancytree-partsel",
					radio: "fancytree-radio",
					// radiogroup: "fancytree-radiogroup",
					unselectable: "fancytree-unselectable",
					lastsib: "fancytree-lastsib",
					loading: "fancytree-loading",
					error: "fancytree-error",
					statusNodePrefix: "fancytree-statusnode-",
				},
				// events
				lazyLoad: null,
				postProcess: null,
			},
			/* Set up the widget, Called on first $().fancytree() */
			_create: function() {
				this.tree = new Fancytree(this);

				this.$source =
					this.source || this.element.data("type") === "json"
						? this.element
						: this.element.find(">ul").first();
				// Subclass Fancytree instance with all enabled extensions
				var extension,
					extName,
					i,
					opts = this.options,
					extensions = opts.extensions,
					base = this.tree;

				for (i = 0; i < extensions.length; i++) {
					extName = extensions[i];
					extension = $.ui.fancytree._extensions[extName];
					if (!extension) {
						$.error(
							"Could not apply extension '" +
								extName +
								"' (it is not registered, did you forget to include it?)"
						);
					}
					// Add extension options as tree.options.EXTENSION
					// 	_assert(!this.tree.options[extName], "Extension name must not exist as option name: " + extName);

					// console.info("extend " + extName, extension.options, this.tree.options[extName])
					// issue #876: we want to replace custom array-options, not merge them
					this.tree.options[extName] = _simpleDeepMerge(
						{},
						extension.options,
						this.tree.options[extName]
					);
					// this.tree.options[extName] = $.extend(true, {}, extension.options, this.tree.options[extName]);

					// console.info("extend " + extName + " =>", this.tree.options[extName])
					// console.info("extend " + extName + " org default =>", extension.options)

					// Add a namespace tree.ext.EXTENSION, to hold instance data
					_assert(
						this.tree.ext[extName] === undefined,
						"Extension name must not exist as Fancytree.ext attribute: '" +
							extName +
							"'"
					);
					// this.tree[extName] = extension;
					this.tree.ext[extName] = {};
					// Subclass Fancytree methods using proxies.
					_subclassObject(this.tree, base, extension, extName);
					// current extension becomes base for the next extension
					base = extension;
				}
				//
				if (opts.icons !== undefined) {
					// 2015-11-16
					if (opts.icon === true) {
						this.tree.warn(
							"'icons' tree option is deprecated since v2.14.0: use 'icon' instead"
						);
						opts.icon = opts.icons;
					} else {
						$.error(
							"'icons' tree option is deprecated since v2.14.0: use 'icon' only instead"
						);
					}
				}
				if (opts.iconClass !== undefined) {
					// 2015-11-16
					if (opts.icon) {
						$.error(
							"'iconClass' tree option is deprecated since v2.14.0: use 'icon' only instead"
						);
					} else {
						this.tree.warn(
							"'iconClass' tree option is deprecated since v2.14.0: use 'icon' instead"
						);
						opts.icon = opts.iconClass;
					}
				}
				if (opts.tabbable !== undefined) {
					// 2016-04-04
					opts.tabindex = opts.tabbable ? "0" : "-1";
					this.tree.warn(
						"'tabbable' tree option is deprecated since v2.17.0: use 'tabindex='" +
							opts.tabindex +
							"' instead"
					);
				}
				//
				this.tree._callHook("treeCreate", this.tree);
				// Note: 'fancytreecreate' event is fired by widget base class
				//        this.tree._triggerTreeEvent("create");
			},

			/* Called on every $().fancytree() */
			_init: function() {
				this.tree._callHook("treeInit", this.tree);
				// TODO: currently we call bind after treeInit, because treeInit
				// might change tree.$container.
				// It would be better, to move event binding into hooks altogether
				this._bind();
			},

			/* Use the _setOption method to respond to changes to options. */
			_setOption: function(key, value) {
				return this.tree._callHook(
					"treeSetOption",
					this.tree,
					key,
					value
				);
			},

			/** Use the destroy method to clean up any modifications your widget has made to the DOM */
			destroy: function() {
				this._unbind();
				this.tree._callHook("treeDestroy", this.tree);
				// In jQuery UI 1.8, you must invoke the destroy method from the base widget
				$.Widget.prototype.destroy.call(this);
				// TODO: delete tree and nodes to make garbage collect easier?
				// TODO: In jQuery UI 1.9 and above, you would define _destroy instead of destroy and not call the base method
			},

			// -------------------------------------------------------------------------

			/* Remove all event handlers for our namespace */
			_unbind: function() {
				var ns = this.tree._ns;
				this.element.off(ns);
				this.tree.$container.off(ns);
				$(document).off(ns);
			},
			/* Add mouse and kyboard handlers to the container */
			_bind: function() {
				var self = this,
					opts = this.options,
					tree = this.tree,
					ns = tree._ns;
				// selstartEvent = ( $.support.selectstart ? "selectstart" : "mousedown" )

				// Remove all previuous handlers for this tree
				this._unbind();

				//alert("keydown" + ns + "foc=" + tree.hasFocus() + tree.$container);
				// tree.debug("bind events; container: ", tree.$container);
				tree.$container
					.on("focusin" + ns + " focusout" + ns, function(event) {
						var node = FT.getNode(event),
							flag = event.type === "focusin";

						if (!flag && node && $(event.target).is("a")) {
							// #764
							node.debug(
								"Ignored focusout on embedded <a> element."
							);
							return;
						}
						// tree.treeOnFocusInOut.call(tree, event);
						// tree.debug("Tree container got event " + event.type, node, event, FT.getEventTarget(event));
						if (flag) {
							if (tree._getExpiringValue("focusin")) {
								// #789: IE 11 may send duplicate focusin events
								tree.debug("Ignored double focusin.");
								return;
							}
							tree._setExpiringValue("focusin", true, 50);

							if (!node) {
								// #789: IE 11 may send focusin before mousdown(?)
								node = tree._getExpiringValue("mouseDownNode");
								if (node) {
									tree.debug(
										"Reconstruct mouse target for focusin from recent event."
									);
								}
							}
						}
						if (node) {
							// For example clicking into an <input> that is part of a node
							tree._callHook(
								"nodeSetFocus",
								tree._makeHookContext(node, event),
								flag
							);
						} else {
							if (
								tree.tbody &&
								$(event.target).parents(
									"table.fancytree-container > thead"
								).length
							) {
								// #767: ignore events in the table's header
								tree.debug(
									"Ignore focus event outside table body.",
									event
								);
							} else {
								tree._callHook("treeSetFocus", tree, flag);
							}
						}
					})
					.on("selectstart" + ns, "span.fancytree-title", function(
						event
					) {
						// prevent mouse-drags to select text ranges
						// tree.debug("<span title> got event " + event.type);
						event.preventDefault();
					})
					.on("keydown" + ns, function(event) {
						// TODO: also bind keyup and keypress
						// tree.debug("got event " + event.type + ", hasFocus:" + tree.hasFocus());
						// if(opts.disabled || opts.keyboard === false || !tree.hasFocus() ){
						if (opts.disabled || opts.keyboard === false) {
							return true;
						}
						var res,
							node = tree.focusNode, // node may be null
							ctx = tree._makeHookContext(node || tree, event),
							prevPhase = tree.phase;

						try {
							tree.phase = "userEvent";
							// If a 'fancytreekeydown' handler returns false, skip the default
							// handling (implemented by tree.nodeKeydown()).
							if (node) {
								res = tree._triggerNodeEvent(
									"keydown",
									node,
									event
								);
							} else {
								res = tree._triggerTreeEvent("keydown", event);
							}
							if (res === "preventNav") {
								res = true; // prevent keyboard navigation, but don't prevent default handling of embedded input controls
							} else if (res !== false) {
								res = tree._callHook("nodeKeydown", ctx);
							}
							return res;
						} finally {
							tree.phase = prevPhase;
						}
					})
					.on("mousedown" + ns, function(event) {
						var et = FT.getEventTarget(event);
						// self.tree.debug("event(" + event.type + "): node: ", et.node);
						// #712: Store the clicked node, so we can use it when we get a focusin event
						//       ('click' event fires after focusin)
						// tree.debug("event(" + event.type + "): node: ", et.node);
						tree._lastMousedownNode = et ? et.node : null;
						// #789: Store the node also for a short period, so we can use it
						// in a *resulting* focusin event
						tree._setExpiringValue(
							"mouseDownNode",
							tree._lastMousedownNode
						);
					})
					.on("click" + ns + " dblclick" + ns, function(event) {
						if (opts.disabled) {
							return true;
						}
						var ctx,
							et = FT.getEventTarget(event),
							node = et.node,
							tree = self.tree,
							prevPhase = tree.phase;

						// self.tree.debug("event(" + event.type + "): node: ", node);
						if (!node) {
							return true; // Allow bubbling of other events
						}
						ctx = tree._makeHookContext(node, event);
						// self.tree.debug("event(" + event.type + "): node: ", node);
						try {
							tree.phase = "userEvent";
							switch (event.type) {
								case "click":
									ctx.targetType = et.type;
									if (node.isPagingNode()) {
										return (
											tree._triggerNodeEvent(
												"clickPaging",
												ctx,
												event
											) === true
										);
									}
									return tree._triggerNodeEvent(
										"click",
										ctx,
										event
									) === false
										? false
										: tree._callHook("nodeClick", ctx);
								case "dblclick":
									ctx.targetType = et.type;
									return tree._triggerNodeEvent(
										"dblclick",
										ctx,
										event
									) === false
										? false
										: tree._callHook("nodeDblclick", ctx);
							}
						} finally {
							tree.phase = prevPhase;
						}
					});
			},
			/** Return the active node or null.
			 * @returns {FancytreeNode}
			 */
			getActiveNode: function() {
				return this.tree.activeNode;
			},
			/** Return the matching node or null.
			 * @param {string} key
			 * @returns {FancytreeNode}
			 */
			getNodeByKey: function(key) {
				return this.tree.getNodeByKey(key);
			},
			/** Return the invisible system root node.
			 * @returns {FancytreeNode}
			 */
			getRootNode: function() {
				return this.tree.rootNode;
			},
			/** Return the current tree instance.
			 * @returns {Fancytree}
			 */
			getTree: function() {
				return this.tree;
			},
		}
	);

	// $.ui.fancytree was created by the widget factory. Create a local shortcut:
	FT = $.ui.fancytree;

	/**
	 * Static members in the `$.ui.fancytree` namespace.<br>
	 * <br>
	 * <pre class="sh_javascript sunlight-highlight-javascript">// Access static members:
	 * var node = $.ui.fancytree.getNode(element);
	 * alert($.ui.fancytree.version);
	 * </pre>
	 *
	 * @mixin Fancytree_Static
	 */
	$.extend(
		$.ui.fancytree,
		/** @lends Fancytree_Static# */
		{
			/** @type {string} */
			version: "2.33.0", // Set to semver by 'grunt release'
			/** @type {string} */
			buildType: "production", // Set to 'production' by 'grunt build'
			/** @type {int} */
			debugLevel: 3, // Set to 3 by 'grunt build'
			// Used by $.ui.fancytree.debug() and as default for tree.options.debugLevel

			_nextId: 1,
			_nextNodeKey: 1,
			_extensions: {},
			// focusTree: null,

			/** Expose class object as $.ui.fancytree._FancytreeClass */
			_FancytreeClass: Fancytree,
			/** Expose class object as $.ui.fancytree._FancytreeNodeClass */
			_FancytreeNodeClass: FancytreeNode,
			/* Feature checks to provide backwards compatibility */
			jquerySupports: {
				// http://jqueryui.com/upgrade-guide/1.9/#deprecated-offset-option-merged-into-my-and-at
				positionMyOfs: isVersionAtLeast($.ui.version, 1, 9),
			},
			/** Throw an error if condition fails (debug method).
			 * @param {boolean} cond
			 * @param {string} msg
			 */
			assert: function(cond, msg) {
				return _assert(cond, msg);
			},
			/** Create a new Fancytree instance on a target element.
			 *
			 * @param {Element | jQueryObject | string} el Target DOM element or selector
			 * @param {FancytreeOptions} [opts] Fancytree options
			 * @returns {Fancytree} new tree instance
			 * @example
			 * var tree = $.ui.fancytree.createTree("#tree", {
			 *     source: {url: "my/webservice"}
			 * }); // Create tree for this matching element
			 *
			 * @since 2.25
			 */
			createTree: function(el, opts) {
				var tree = $(el)
					.fancytree(opts)
					.fancytree("getTree");
				return tree;
			},
			/** Return a function that executes *fn* at most every *timeout* ms.
			 * @param {integer} timeout
			 * @param {function} fn
			 * @param {boolean} [invokeAsap=false]
			 * @param {any} [ctx]
			 */
			debounce: function(timeout, fn, invokeAsap, ctx) {
				var timer;
				if (arguments.length === 3 && typeof invokeAsap !== "boolean") {
					ctx = invokeAsap;
					invokeAsap = false;
				}
				return function() {
					var args = arguments;
					ctx = ctx || this;
					// eslint-disable-next-line no-unused-expressions
					invokeAsap && !timer && fn.apply(ctx, args);
					clearTimeout(timer);
					timer = setTimeout(function() {
						// eslint-disable-next-line no-unused-expressions
						invokeAsap || fn.apply(ctx, args);
						timer = null;
					}, timeout);
				};
			},
			/** Write message to console if debugLevel >= 4
			 * @param {string} msg
			 */
			debug: function(msg) {
				if ($.ui.fancytree.debugLevel >= 4) {
					consoleApply("log", arguments);
				}
			},
			/** Write error message to console if debugLevel >= 1.
			 * @param {string} msg
			 */
			error: function(msg) {
				if ($.ui.fancytree.debugLevel >= 1) {
					consoleApply("error", arguments);
				}
			},
			/** Convert `<`, `>`, `&`, `"`, `'`, and `/` to the equivalent entities.
			 *
			 * @param {string} s
			 * @returns {string}
			 */
			escapeHtml: function(s) {
				return ("" + s).replace(REX_HTML, function(s) {
					return ENTITY_MAP[s];
				});
			},
			/** Make jQuery.position() arguments backwards compatible, i.e. if
			 * jQuery UI version <= 1.8, convert
			 *   { my: "left+3 center", at: "left bottom", of: $target }
			 * to
			 *   { my: "left center", at: "left bottom", of: $target, offset: "3  0" }
			 *
			 * See http://jqueryui.com/upgrade-guide/1.9/#deprecated-offset-option-merged-into-my-and-at
			 * and http://jsfiddle.net/mar10/6xtu9a4e/
			 *
			 * @param {object} opts
			 * @returns {object} the (potentially modified) original opts hash object
			 */
			fixPositionOptions: function(opts) {
				if (opts.offset || ("" + opts.my + opts.at).indexOf("%") >= 0) {
					$.error(
						"expected new position syntax (but '%' is not supported)"
					);
				}
				if (!$.ui.fancytree.jquerySupports.positionMyOfs) {
					var // parse 'left+3 center' into ['left+3 center', 'left', '+3', 'center', undefined]
						myParts = /(\w+)([+-]?\d+)?\s+(\w+)([+-]?\d+)?/.exec(
							opts.my
						),
						atParts = /(\w+)([+-]?\d+)?\s+(\w+)([+-]?\d+)?/.exec(
							opts.at
						),
						// convert to numbers
						dx =
							(myParts[2] ? +myParts[2] : 0) +
							(atParts[2] ? +atParts[2] : 0),
						dy =
							(myParts[4] ? +myParts[4] : 0) +
							(atParts[4] ? +atParts[4] : 0);

					opts = $.extend({}, opts, {
						// make a copy and overwrite
						my: myParts[1] + " " + myParts[3],
						at: atParts[1] + " " + atParts[3],
					});
					if (dx || dy) {
						opts.offset = "" + dx + " " + dy;
					}
				}
				return opts;
			},
			/** Return a {node: FancytreeNode, type: TYPE} object for a mouse event.
			 *
			 * @param {Event} event Mouse event, e.g. click, ...
			 * @returns {object} Return a {node: FancytreeNode, type: TYPE} object
			 *     TYPE: 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined
			 */
			getEventTarget: function(event) {
				var $target,
					tree,
					tcn = event && event.target ? event.target.className : "",
					res = { node: this.getNode(event.target), type: undefined };
				// We use a fast version of $(res.node).hasClass()
				// See http://jsperf.com/test-for-classname/2
				if (/\bfancytree-title\b/.test(tcn)) {
					res.type = "title";
				} else if (/\bfancytree-expander\b/.test(tcn)) {
					res.type =
						res.node.hasChildren() === false
							? "prefix"
							: "expander";
					// }else if( /\bfancytree-checkbox\b/.test(tcn) || /\bfancytree-radio\b/.test(tcn) ){
				} else if (/\bfancytree-checkbox\b/.test(tcn)) {
					res.type = "checkbox";
				} else if (/\bfancytree(-custom)?-icon\b/.test(tcn)) {
					res.type = "icon";
				} else if (/\bfancytree-node\b/.test(tcn)) {
					// Somewhere near the title
					res.type = "title";
				} else if (event && event.target) {
					$target = $(event.target);
					if ($target.is("ul[role=group]")) {
						// #nnn: Clicking right to a node may hit the surrounding UL
						tree = res.node && res.node.tree;
						(tree || FT).debug("Ignoring click on outer UL.");
						res.node = null;
					} else if ($target.closest(".fancytree-title").length) {
						// #228: clicking an embedded element inside a title
						res.type = "title";
					} else if ($target.closest(".fancytree-checkbox").length) {
						// E.g. <svg> inside checkbox span
						res.type = "checkbox";
					} else if ($target.closest(".fancytree-expander").length) {
						res.type = "expander";
					}
				}
				return res;
			},
			/** Return a string describing the affected node region for a mouse event.
			 *
			 * @param {Event} event Mouse event, e.g. click, mousemove, ...
			 * @returns {string} 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined
			 */
			getEventTargetType: function(event) {
				return this.getEventTarget(event).type;
			},
			/** Return a FancytreeNode instance from element, event, or jQuery object.
			 *
			 * @param {Element | jQueryObject | Event} el
			 * @returns {FancytreeNode} matching node or null
			 */
			getNode: function(el) {
				if (el instanceof FancytreeNode) {
					return el; // el already was a FancytreeNode
				} else if (el instanceof $) {
					el = el[0]; // el was a jQuery object: use the DOM element
				} else if (el.originalEvent !== undefined) {
					el = el.target; // el was an Event
				}
				while (el) {
					if (el.ftnode) {
						return el.ftnode;
					}
					el = el.parentNode;
				}
				return null;
			},
			/** Return a Fancytree instance, from element, index, event, or jQueryObject.
			 *
			 * @param {Element | jQueryObject | Event | integer | string} [el]
			 * @returns {Fancytree} matching tree or null
			 * @example
			 * $.ui.fancytree.getTree();  // Get first Fancytree instance on page
			 * $.ui.fancytree.getTree(1);  // Get second Fancytree instance on page
			 * $.ui.fancytree.getTree(event);  // Get tree for this mouse- or keyboard event
			 * $.ui.fancytree.getTree("foo");  // Get tree for this `opts.treeId`
			 * $.ui.fancytree.getTree("#tree");  // Get tree for this matching element
			 *
			 * @since 2.13
			 */
			getTree: function(el) {
				var widget,
					orgEl = el;

				if (el instanceof Fancytree) {
					return el; // el already was a Fancytree
				}
				if (el === undefined) {
					el = 0; // get first tree
				}
				if (typeof el === "number") {
					el = $(".fancytree-container").eq(el); // el was an integer: return nth instance
				} else if (typeof el === "string") {
					// `el` may be a treeId or a selector:
					el = $("#ft-id-" + orgEl).eq(0);
					if (!el.length) {
						el = $(orgEl).eq(0); // el was a selector: use first match
					}
				} else if (el instanceof $) {
					el = el.eq(0); // el was a jQuery object: use the first DOM element
				} else if (el.originalEvent !== undefined) {
					el = $(el.target); // el was an Event
				}
				el = el.closest(":ui-fancytree");
				widget = el.data("ui-fancytree") || el.data("fancytree"); // the latter is required by jQuery <= 1.8
				return widget ? widget.tree : null;
			},
			/** Return an option value that has a default, but may be overridden by a
			 * callback or a node instance attribute.
			 *
			 * Evaluation sequence:<br>
			 *
			 * If tree.options.<optionName> is a callback that returns something, use that.<br>
			 * Else if node.<optionName> is defined, use that.<br>
			 * Else if tree.options.<optionName> is a value, use that.<br>
			 * Else use `defaultValue`.
			 *
			 * @param {string} optionName name of the option property (on node and tree)
			 * @param {FancytreeNode} node passed to the callback
			 * @param {object} nodeObject where to look for the local option property, e.g. `node` or `node.data`
			 * @param {object} treeOption where to look for the tree option, e.g. `tree.options` or `tree.options.dnd5`
			 * @param {any} [defaultValue]
			 * @returns {any}
			 *
			 * @example
			 * // Check for node.foo, tree,options.foo(), and tree.options.foo:
			 * $.ui.fancytree.evalOption("foo", node, node, tree.options);
			 * // Check for node.data.bar, tree,options.qux.bar(), and tree.options.qux.bar:
			 * $.ui.fancytree.evalOption("bar", node, node.data, tree.options.qux);
			 *
			 * @since 2.22
			 */
			evalOption: function(
				optionName,
				node,
				nodeObject,
				treeOptions,
				defaultValue
			) {
				var ctx,
					res,
					tree = node.tree,
					treeOpt = treeOptions[optionName],
					nodeOpt = nodeObject[optionName];

				if ($.isFunction(treeOpt)) {
					ctx = {
						node: node,
						tree: tree,
						widget: tree.widget,
						options: tree.widget.options,
						typeInfo: tree.types[node.type] || {},
					};
					res = treeOpt.call(tree, { type: optionName }, ctx);
					if (res == null) {
						res = nodeOpt;
					}
				} else {
					res = nodeOpt == null ? treeOpt : nodeOpt;
				}
				if (res == null) {
					res = defaultValue; // no option set at all: return default
				}
				return res;
			},
			/** Set expander, checkbox, or node icon, supporting string and object format.
			 *
			 * @param {Element | jQueryObject} span
			 * @param {string} baseClass
			 * @param {string | object} icon
			 * @since 2.27
			 */
			setSpanIcon: function(span, baseClass, icon) {
				var $span = $(span);

				if (typeof icon === "string") {
					$span.attr("class", baseClass + " " + icon);
				} else {
					// support object syntax: { text: ligature, addClasse: classname }
					if (icon.text) {
						$span.text("" + icon.text);
					} else if (icon.html) {
						span.innerHTML = icon.html;
					}
					$span.attr(
						"class",
						baseClass + " " + (icon.addClass || "")
					);
				}
			},
			/** Convert a keydown or mouse event to a canonical string like 'ctrl+a',
			 * 'ctrl+shift+f2', 'shift+leftdblclick'.
			 *
			 * This is especially handy for switch-statements in event handlers.
			 *
			 * @param {event}
			 * @returns {string}
			 *
			 * @example

			switch( $.ui.fancytree.eventToString(event) ) {
				case "-":
					tree.nodeSetExpanded(ctx, false);
					break;
				case "shift+return":
					tree.nodeSetActive(ctx, true);
					break;
				case "down":
					res = node.navigate(event.which, activate);
					break;
				default:
					handled = false;
			}
			if( handled ){
				event.preventDefault();
			}
			*/
			eventToString: function(event) {
				// Poor-man's hotkeys. See here for a complete implementation:
				//   https://github.com/jeresig/jquery.hotkeys
				var which = event.which,
					et = event.type,
					s = [];

				if (event.altKey) {
					s.push("alt");
				}
				if (event.ctrlKey) {
					s.push("ctrl");
				}
				if (event.metaKey) {
					s.push("meta");
				}
				if (event.shiftKey) {
					s.push("shift");
				}

				if (et === "click" || et === "dblclick") {
					s.push(MOUSE_BUTTONS[event.button] + et);
				} else if (et === "wheel") {
					s.push(et);
				} else if (!IGNORE_KEYCODES[which]) {
					s.push(
						SPECIAL_KEYCODES[which] ||
							String.fromCharCode(which).toLowerCase()
					);
				}
				return s.join("+");
			},
			/** Write message to console if debugLevel >= 3
			 * @param {string} msg
			 */
			info: function(msg) {
				if ($.ui.fancytree.debugLevel >= 3) {
					consoleApply("info", arguments);
				}
			},
			/* @deprecated: use eventToString(event) instead.
			 */
			keyEventToString: function(event) {
				this.warn(
					"keyEventToString() is deprecated: use eventToString()"
				);
				return this.eventToString(event);
			},
			/** Return a wrapped handler method, that provides `this._super`.
			 *
			 * @example
				// Implement `opts.createNode` event to add the 'draggable' attribute
				$.ui.fancytree.overrideMethod(ctx.options, "createNode", function(event, data) {
					// Default processing if any
					this._super.apply(this, arguments);
					// Add 'draggable' attribute
					data.node.span.draggable = true;
				});
			 *
			 * @param {object} instance
			 * @param {string} methodName
			 * @param {function} handler
			 * @param {object} [context] optional context
			 */
			overrideMethod: function(instance, methodName, handler, context) {
				var prevSuper,
					_super = instance[methodName] || $.noop;

				instance[methodName] = function() {
					var self = context || this;

					try {
						prevSuper = self._super;
						self._super = _super;
						return handler.apply(self, arguments);
					} finally {
						self._super = prevSuper;
					}
				};
			},
			/**
			 * Parse tree data from HTML <ul> markup
			 *
			 * @param {jQueryObject} $ul
			 * @returns {NodeData[]}
			 */
			parseHtml: function($ul) {
				var classes,
					className,
					extraClasses,
					i,
					iPos,
					l,
					tmp,
					tmp2,
					$children = $ul.find(">li"),
					children = [];

				$children.each(function() {
					var allData,
						lowerCaseAttr,
						$li = $(this),
						$liSpan = $li.find(">span", this).first(),
						$liA = $liSpan.length ? null : $li.find(">a").first(),
						d = { tooltip: null, data: {} };

					if ($liSpan.length) {
						d.title = $liSpan.html();
					} else if ($liA && $liA.length) {
						// If a <li><a> tag is specified, use it literally and extract href/target.
						d.title = $liA.html();
						d.data.href = $liA.attr("href");
						d.data.target = $liA.attr("target");
						d.tooltip = $liA.attr("title");
					} else {
						// If only a <li> tag is specified, use the trimmed string up to
						// the next child <ul> tag.
						d.title = $li.html();
						iPos = d.title.search(/<ul/i);
						if (iPos >= 0) {
							d.title = d.title.substring(0, iPos);
						}
					}
					d.title = $.trim(d.title);

					// Make sure all fields exist
					for (i = 0, l = CLASS_ATTRS.length; i < l; i++) {
						d[CLASS_ATTRS[i]] = undefined;
					}
					// Initialize to `true`, if class is set and collect extraClasses
					classes = this.className.split(" ");
					extraClasses = [];
					for (i = 0, l = classes.length; i < l; i++) {
						className = classes[i];
						if (CLASS_ATTR_MAP[className]) {
							d[className] = true;
						} else {
							extraClasses.push(className);
						}
					}
					d.extraClasses = extraClasses.join(" ");

					// Parse node options from ID, title and class attributes
					tmp = $li.attr("title");
					if (tmp) {
						d.tooltip = tmp; // overrides <a title='...'>
					}
					tmp = $li.attr("id");
					if (tmp) {
						d.key = tmp;
					}
					// Translate hideCheckbox -> checkbox:false
					if ($li.attr("hideCheckbox")) {
						d.checkbox = false;
					}
					// Add <li data-NAME='...'> as node.data.NAME
					allData = _getElementDataAsDict($li);
					if (allData && !$.isEmptyObject(allData)) {
						// #507: convert data-hidecheckbox (lower case) to hideCheckbox
						for (lowerCaseAttr in NODE_ATTR_LOWERCASE_MAP) {
							if (allData.hasOwnProperty(lowerCaseAttr)) {
								allData[
									NODE_ATTR_LOWERCASE_MAP[lowerCaseAttr]
								] = allData[lowerCaseAttr];
								delete allData[lowerCaseAttr];
							}
						}
						// #56: Allow to set special node.attributes from data-...
						for (i = 0, l = NODE_ATTRS.length; i < l; i++) {
							tmp = NODE_ATTRS[i];
							tmp2 = allData[tmp];
							if (tmp2 != null) {
								delete allData[tmp];
								d[tmp] = tmp2;
							}
						}
						// All other data-... goes to node.data...
						$.extend(d.data, allData);
					}
					// Recursive reading of child nodes, if LI tag contains an UL tag
					$ul = $li.find(">ul").first();
					if ($ul.length) {
						d.children = $.ui.fancytree.parseHtml($ul);
					} else {
						d.children = d.lazy ? undefined : null;
					}
					children.push(d);
					// FT.debug("parse ", d, children);
				});
				return children;
			},
			/** Add Fancytree extension definition to the list of globally available extensions.
			 *
			 * @param {object} definition
			 */
			registerExtension: function(definition) {
				_assert(
					definition.name != null,
					"extensions must have a `name` property."
				);
				_assert(
					definition.version != null,
					"extensions must have a `version` property."
				);
				$.ui.fancytree._extensions[definition.name] = definition;
			},
			/** Inverse of escapeHtml().
			 *
			 * @param {string} s
			 * @returns {string}
			 */
			unescapeHtml: function(s) {
				var e = document.createElement("div");
				e.innerHTML = s;
				return e.childNodes.length === 0
					? ""
					: e.childNodes[0].nodeValue;
			},
			/** Write warning message to console if debugLevel >= 2.
			 * @param {string} msg
			 */
			warn: function(msg) {
				if ($.ui.fancytree.debugLevel >= 2) {
					consoleApply("warn", arguments);
				}
			},
		}
	);

	// Value returned by `require('jquery.fancytree')`
	return $.ui.fancytree;
}); // End of closure


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.ui-deps.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.ui-deps.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! jQuery UI - v1.12.1 - 2018-05-20
* http://jqueryui.com
* Includes: widget.js, position.js, keycode.js, scroll-parent.js, unique-id.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

;(function( factory ) {
	if ( true ) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = $.cleanData || ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = $.widget || function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = $.Widget || function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = $.position || {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};


/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );


}));


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css":
/*!******************************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var content = __webpack_require__(/*! !../../../css-loader!./ui.fancytree.min.css */ "./node_modules/css-loader/index.js!./node_modules/jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css");

if (typeof content === 'string') {
  content = [[module.i, content, '']];
}

var options = {}

options.insert = "head";
options.singleton = false;

var update = __webpack_require__(/*! ../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js")(content, options);

if (content.locals) {
  module.exports = content.locals;
}


/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/skin-awesome/vline-rtl.gif":
/*!***********************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/skin-awesome/vline-rtl.gif ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "b20d84096840ef2e2040401c7e7793af.gif";

/***/ }),

/***/ "./node_modules/jquery.fancytree/dist/skin-awesome/vline.gif":
/*!*******************************************************************!*\
  !*** ./node_modules/jquery.fancytree/dist/skin-awesome/vline.gif ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "61e881cb4cd1a47c0b8c112d9806d99e.gif";

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, main, scripts, repository, keywords, author, license, devDependencies, project, dependencies, default */
/***/ (function(module) {

module.exports = {"name":"fractal","version":"0.0.1","description":"Golden master for Fractal based projects.","main":"fractal.js","scripts":{"start":"cross-env APP_ENV=development npm-run-all webpack:build -p webpack:watch:nolint fractal:watch","start:nolint":"cross-env APP_ENV=development npm-run-all webpack:build -p webpack:watch:nolint fractal:watch","build":"cross-env APP_ENV=build npm-run-all webpack:clear webpack:build fractal:build","deploy":"cross-env APP_ENV=production npm-run-all webpack:clear webpack:build fractal:build","test":"npm-run-all test:lint:js test:lint:css","webpack:clear":"del-cli dist/*","webpack:build":"webpack --config webpack.config.js","webpack:watch":"webpack --config webpack.development.config.js --watch","webpack:watch:nolint":"webpack --config webpack.config.js --watch","fractal:build":"fractal build","fractal:watch":"fractal start --sync","test:lint:js":"eslint src/assets/scripts/","test:lint:css":"","test:lint:css:fix":"stylelint 'src/assets/styles/**/*.scss' --fix"},"repository":{"type":"git","url":"git@gitlab.cps-projects.de:DevOps/frontend/fractal.git"},"keywords":["fractal","goldenmaster","frontend"],"author":"eggman","license":"MIT","devDependencies":{"@babel/core":"^7.3.4","@babel/preset-env":"^7.3.4","@familieredlich/fr-toolbox":"^1.0.2","@frctl/fractal":"^1.1.7","@frctl/handlebars":"^1.1.5","@frctl/mandelbrot":"^1.2.0","@types/mini-css-extract-plugin":"^0.2.0","autoprefixer":"^9.4.10","babel-loader":"^8.0.5","cheerio":"^1.0.0-rc.3","clean-css":"^4.2.1","copy-webpack-plugin":"^5.0.4","cross-env":"^5.2.0","css-loader":"^1.0.1","del-cli":"^1.1.0","eslint":"^5.15.1","eslint-loader":"^2.1.2","faker":"^4.1.0","fibers":"^3.1.1","file-loader":"^2.0.0","handlebars-layouts":"^3.1.4","html-minifier":"^4.0.0","iconfont-webpack-plugin":"^3.1.0","mini-css-extract-plugin":"^0.4.5","npm-run-all":"^4.1.5","postcss-discard-comments":"^4.0.2","postcss-loader":"^3.0.0","request":"^2.88.0","resolve-url-loader":"^3.0.1","sass":"^1.17.2","sass-loader":"^7.1.0","split-html":"^1.0.3","stylelint":"^9.10.1","stylelint-config-standard":"^18.2.0","stylelint-order":"^2.1.0","stylelint-webpack-plugin":"^0.10.5","svgo":"^1.2.0","svgo-loader":"^2.2.0","uglify-js":"^3.6.0","webpack":"^4.29.6","webpack-cli":"^3.2.3","webpack-merge":"^4.2.1"},"project":{"title":"extension FE-builder","publicPath":"/resources","ajaxProxyPort":7835,"googleApiKey":"AIzaSyCjrAYq3VJobLuTeMa_3NsU_NpMwIYCvBA"},"dependencies":{"jquery":"^3.4.1","jquery.fancytree":"^2.33.0"}};

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-locationTypes.js":
/*!*********************************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-locationTypes.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fancytree-renderer */ "./src/assets/scripts/lib/fancytree-renderer.js");
/* harmony import */ var _ajaxMap_places__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ajaxMap-places */ "./src/assets/scripts/lib/ajaxMap-places.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);



var mapLocationTypes = {
  treeSelector: '#ajaxMapLocationTypesTree',
  ui: function ui(mapEntry) {
    var currLocationTypes = mapEntry.locationTypes,
        mapId = mapEntry.id; //remove empty option (since fluid doesn't build a select without option)

    for (var type in currLocationTypes) {
      jquery__WEBPACK_IMPORTED_MODULE_2___default()('<option/>').val(currLocationTypes[type].key).text(currLocationTypes[type].title).appendTo(jquery__WEBPACK_IMPORTED_MODULE_2___default()(mapLocationTypes.treeSelector + mapId));
    } // set on change function for location types treeSelector


    jquery__WEBPACK_IMPORTED_MODULE_2___default()(mapLocationTypes.treeSelector + mapId).change(function () {
      _ajaxMap_places__WEBPACK_IMPORTED_MODULE_1__["default"].updatePlaces(mapId);
    });
  },
  init: function init(mapEntry, locationTypes) {
    if (locationTypes) {
      mapEntry.locationTypes = locationTypes;
      mapLocationTypes.ui(mapEntry);
      _fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__["default"].locationTypes(mapEntry);
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (mapLocationTypes);

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-map.js":
/*!***********************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-map.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ajaxMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ajaxMap */ "./src/assets/scripts/lib/ajaxMap.js");
/* harmony import */ var _map_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-helpers */ "./src/assets/scripts/lib/map-helpers.js");



var _map = {
  getMapData: function getMapData(mapEntry) {
    var data = {
      'id': _ajaxMap__WEBPACK_IMPORTED_MODULE_1__["default"].configData.mapSettings.pageId,
      'api': "map",
      'action': 'buildMap',
      'mapId': mapEntry.id
    };
    return new Promise(function (resolve, reject) {
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.ajax({
        dataType: 'json',
        type: 'GET',
        url: _ajaxMap__WEBPACK_IMPORTED_MODULE_1__["default"].ajaxServerPath,
        data: data,
        success: resolve,
        error: reject
      });
    });
  },
  build: function build(mapEntry) {
    var settings = mapEntry.settings;
    return new Promise(function (resolve, reject) {
      _map.getMapData(mapEntry).then(function (response) {
        var $el = jquery__WEBPACK_IMPORTED_MODULE_0___default()('#ajaxMapContainer_Map' + mapEntry.id);
        var googleMap = _map_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].createGooglMap(response, $el);
        var infoWindow = _map_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].getInfoWindow();
        var markerClusterer = _map_helpers__WEBPACK_IMPORTED_MODULE_2__["default"].getMarkerClusterer(googleMap, mapEntry.markerClusterer);
        var regions = response.regions || [];
        var staticLayers = response.staticLayers || [];
        var key = settings.googleApiKey;
        Object.assign(mapEntry, {
          googleMap: googleMap,
          regions: regions,
          staticLayers: staticLayers,
          markerClusterer: markerClusterer,
          infoWindow: infoWindow,
          key: key
        });
        resolve(response);
      }, reject);
    });
  },
  panTo: function panTo(mapId) {
    "use strict"; //) console.log(mapCenter, '*****************')//http://jsfiddle.net/fqt7L/1/
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  build: _map.build
});

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-places-detail-view.js":
/*!**************************************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-places-detail-view.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function openDetailView(caller, placeId) {
  switch (caller) {
    case "infoWindow":
      placeId = $('#detailView').data('placeId');
      break;

    case "listView":
      break;

    default:
      break;
  }

  if (placeId) {
    //?@dirk
    var path = $(location).attr('href');

    if (path.indexOf('?') > -1) {
      path = path + '&type=1441916976';
    } else {
      path = path + '?type=1441916976';
    }

    $.ajax({
      url: path,
      context: $('#detailView .inner'),
      data: {
        tx_ajaxmap_map: {
          'controller': "Place",
          'action': 'ajaxShow',
          'placeId': placeId
        }
      }
    }).done(function (data) {
      this.html(data);
      $('#detailView').fadeIn('400');
      $('#overlayDetailHelper').height($(document).height()).fadeIn('400');
      $('#overlay-close').click(function () {
        $('#detailView').fadeOut('500');
        $('#overlayDetailHelper').fadeOut('500');
        $('#detailView .inner').contents().remove();
      });
    });
  }
}

/* harmony default export */ __webpack_exports__["default"] = (openDetailView);

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-places-filter.js":
/*!*********************************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-places-filter.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fancytree-renderer */ "./src/assets/scripts/lib/fancytree-renderer.js");
/* harmony import */ var _map_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-layers */ "./src/assets/scripts/lib/map-layers.js");
/* harmony import */ var _map_marker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map-marker */ "./src/assets/scripts/lib/map-marker.js");
/* harmony import */ var _map_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map-helpers */ "./src/assets/scripts/lib/map-helpers.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_4__);






/**
 * Updates all filter (trees)
 * Determines for all nodes in all filter trees whether
 * they should be shown.
 * A node in a filter tree should be visible if at least
 * one node in the result tree (placesTree) has the
 * according option (for instance if it belongs to a region)
 *
 * @param placesTree The places tree
 * @return void
 *
 * formals :updateFilter
 */

function update($rootNode, mapEntry) {
  var filters = mapEntry.settings.placesTree.updateFilters;
  jquery__WEBPACK_IMPORTED_MODULE_4___default.a.each(filters, function (filterName, filter) {
    var treeSelector = '#' + filter.treeName + mapEntry.id;

    try {
      var tree = jquery__WEBPACK_IMPORTED_MODULE_4___default()(treeSelector).fancytree('getTree');
      var children = $rootNode.children;
      var placeKeys = getKeysByAttribute(children, filterName);
      filterTree(tree, placeKeys);

      if (filterName === 'regions' && filter.updateLayers) {
        var selectedKeys = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_3__["getSelectedKeys"])(treeSelector);
        _map_layers__WEBPACK_IMPORTED_MODULE_1__["default"].update(mapEntry, selectedKeys);
      }
    } catch (err) {
      //todo filter not initalised eg location typd:88??@dirk--everytime locationTypes
      console.log('treeSelector---->', treeSelector);
      console.error(err);
    }
  });
}
/**
 * Searches all children for an attribute in their data property
 * and returns a unique array of keys for this attribute
 *
 * @param children
 * @param name
 * @return Array
 */


function getKeysByAttribute(children, name) {
  var keys = [];
  jquery__WEBPACK_IMPORTED_MODULE_4___default.a.each(children, function (index, child) {
    if (child.data.hasOwnProperty(name)) {
      var attribute = child.data[name];

      if (attribute !== undefined && attribute !== null && attribute.hasOwnProperty('key') && !keys[attribute.key]) {
        keys.push(attribute.key);
      } else {
        if (attribute instanceof Array) {
          for (var i = 0, k = attribute.length; i < k; i++) {
            if (attribute[i].hasOwnProperty('key') && keys.indexOf(attribute[i].key) < 0) {
              keys.push(attribute[i].key);
            }
          }
        }
      }
    }
  });
  return keys;
}
/**
 * Filters a tree by a unique array of keys
 * A node will be visible if its key is in the this array
 *
 * @param tree Fancy tree
 * @param keys Unique array of keys
 */


function filterTree(tree, keys) {
  var options = {
    autoExpand: true
  };
  tree.filterNodes(function (node) {
    return keys.indexOf(parseInt(node.key)) != -1;
  }, options);
}
/**
 * Shows places which match all constraints
 * defined by region, place group, location type or category selector
 *
 * @param mapEntry
 */


function showMatchingPlaces(mapEntry) {
  var map = mapEntry.googleMap,
      mapId = mapEntry.id,
      mapPlaces = mapEntry.places,
      selectedPlaces = [],
      clusterer = mapEntry.markerClusterer,
      mapMarkers = mapEntry.markers || [],
      selectedLocationTypeKeys = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_3__["getSelectedKeys"])(_fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__["fancytreeSelector"].locationType + mapId),
      selectedCategoryKeys = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_3__["getSelectedKeys"])(_fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__["fancytreeSelector"].category + mapId),
      selectedRegionKeys = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_3__["getSelectedKeys"])(_fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__["fancytreeSelector"].regions + mapId),
      selectedPlaceGroupKeys = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_3__["getSelectedKeys"])(_fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__["fancytreeSelector"].placeGroup + mapId),
      selectedLocationType = 0; // get selected location type. This should be one or none

  if (selectedLocationTypeKeys.length) {
    selectedLocationType = selectedLocationTypeKeys[0];
  }

  console.log('markerClusterer', clusterer, mapEntry);
  clusterer.removeMarkers(mapMarkers); // add markers for all places

  for (var i = 0, j = mapPlaces.length; i < j; i++) {
    var place = mapPlaces[i],
        marker = mapMarkers[i];

    if (!mapMarkers[i]) {
      // marker does not exist, create it
      mapMarkers[i] = _map_marker__WEBPACK_IMPORTED_MODULE_2__["default"].create(mapEntry, place);
    } else {
      var hasAnActiveCategory = 0,
          hasAnActiveRegion = 0,
          hasAnActivePlaceGroup = 0;

      if (selectedCategoryKeys && marker.place.categories) {
        jquery__WEBPACK_IMPORTED_MODULE_4___default.a.each(marker.place.categories, function () {
          hasAnActiveCategory = jquery__WEBPACK_IMPORTED_MODULE_4___default.a.inArray(parseInt(this.key), selectedCategoryKeys) > -1;
          return !hasAnActiveCategory;
        });
      }

      if (selectedRegionKeys.length && marker.place.regions) {
        jquery__WEBPACK_IMPORTED_MODULE_4___default.a.each(marker.place.regions, function () {
          hasAnActiveRegion = jquery__WEBPACK_IMPORTED_MODULE_4___default.a.inArray(parseInt(this.key), selectedRegionKeys) > -1;
          return !hasAnActiveRegion;
        });
      }

      if (selectedPlaceGroupKeys.length && marker.place.placeGroups) {
        jquery__WEBPACK_IMPORTED_MODULE_4___default.a.each(marker.place.placeGroups, function () {
          hasAnActivePlaceGroup = jquery__WEBPACK_IMPORTED_MODULE_4___default.a.inArray(parseInt(this.key), selectedPlaceGroupKeys) > -1;
          return !hasAnActivePlaceGroup;
        });
      } //----


      if ((place.locationType.key == selectedLocationType || !selectedLocationTypeKeys.length) && (hasAnActiveCategory || !selectedCategoryKeys.length) && (hasAnActiveRegion || !selectedRegionKeys.length) && (hasAnActivePlaceGroup || !selectedPlaceGroupKeys.length)) {
        marker.setMap(map);
        selectedPlaces[selectedPlaces.length] = place;
      } else {
        marker.setMap(null);
      }
    }
  } //   clusterer.addMarkers(mapMarkers);
  // update only if mapEntry is already initialized


  if (typeof mapEntry.markers !== 'undefined') {
    console.log('!!', selectedPlaces);
    _fancytree_renderer__WEBPACK_IMPORTED_MODULE_0__["updateTree"].places(mapEntry, selectedPlaces);
  }

  mapEntry.markers = mapMarkers;
}
/**
 * Shows places from a list of selected places
 *
 * @param mapEntry
 * @param selectedPlaceKeys
 * @returns {*}
 */


function showSelectedPlaces(mapEntry, selectedPlaceKeys) {
  var map = mapEntry.googleMap,
      mapPlaces = mapEntry.places,
      clusterer = mapEntry.markerClusterer,
      mapMarkers = mapEntry.markers || [];
  mapPlaces.forEach(function (place, i) {
    mapMarkers[i] = mapMarkers[i] ? mapMarkers[i] : _map_marker__WEBPACK_IMPORTED_MODULE_2__["default"].create(mapEntry, place);
    mapMarkers[i].setMap(null);
    clusterer.removeMarker(mapMarkers[i]);
  });
  clusterer.addMarkers(mapMarkers);
  mapMarkers.forEach(function (marker) {
    var isSelectedPlace = selectedPlaceKeys.some(function (key) {
      return marker.place.key === key;
    });

    if (isSelectedPlace) {
      marker.setMap(map);
    }
  });
}

var filterPlaces = {
  update: update,
  showMatchingPlaces: showMatchingPlaces,
  showSelectedPlaces: showSelectedPlaces
};
/* harmony default export */ __webpack_exports__["default"] = (filterPlaces);

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-places.js":
/*!**************************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-places.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_edit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery.fancytree/dist/modules/jquery.fancytree.edit */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.edit.js");
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_edit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_modules_jquery_fancytree_edit__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_glyph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery.fancytree/dist/modules/jquery.fancytree.glyph */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.glyph.js");
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_glyph__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_modules_jquery_fancytree_glyph__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jquery.fancytree/dist/modules/jquery.fancytree.filter */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.filter.js");
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_filter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_modules_jquery_fancytree_filter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _ajaxMap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ajaxMap */ "./src/assets/scripts/lib/ajaxMap.js");
/* harmony import */ var _ajaxMap_places_filter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ajaxMap-places-filter */ "./src/assets/scripts/lib/ajaxMap-places-filter.js");
/* harmony import */ var _fancytree_renderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fancytree-renderer */ "./src/assets/scripts/lib/fancytree-renderer.js");
/* harmony import */ var _map_marker_info_window__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./map-marker-info-window */ "./src/assets/scripts/lib/map-marker-info-window.js");
/* harmony import */ var _map_helpers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./map-helpers */ "./src/assets/scripts/lib/map-helpers.js");










var _ = {
  updatePlaces: function updatePlaces(mapEntry, clearSelected) {
    var treeSelector = _fancytree_renderer__WEBPACK_IMPORTED_MODULE_6__["fancytreeSelector"].places + mapEntry.id;

    if (clearSelected) {
      var tree = jquery__WEBPACK_IMPORTED_MODULE_0___default()(treeSelector).fancytree('getTree');
      tree.clearFilter();
      tree.visit(function (node) {
        node.setSelected(false);
      });
    }

    var selectedPlaceKeys = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_8__["getSelectedKeys"])(treeSelector);

    if (selectedPlaceKeys.length) {
      _ajaxMap_places_filter__WEBPACK_IMPORTED_MODULE_5__["default"].showSelectedPlaces(mapEntry, selectedPlaceKeys);
    } else {
      _ajaxMap_places_filter__WEBPACK_IMPORTED_MODULE_5__["default"].showMatchingPlaces(mapEntry);
    }
  },
  showSoloPlace: function showSoloPlace(mapEntry) {
    return function (event, data) {
      var mapMarkers = mapEntry.markers || [],
          infoWindow = mapEntry.infoWindow;

      if (!data.node.selected) {
        data.node.setSelected(true);

        if (mapEntry.settings.placesTree.toggleInfoWindowOnSelect) {
          for (var i = 0, j = mapMarkers.length; i < j; i++) {
            var marker = mapMarkers[i];

            if (marker.place.key === data.node.key) {
              _map_marker_info_window__WEBPACK_IMPORTED_MODULE_7__["default"].getInfoWindowContent(marker.place).then(function (content) {
                infoWindow.setContent(content);
                infoWindow.open(mapEntry.map, marker);
              });
            }
          }
        }
      } else {
        data.node.setSelected(false);
        infoWindow.close();
      }

      data.node.setActive(false);

      _.updatePlaces(mapEntry);
    };
  },
  setEvents: function setEvents(placesTree) {
    var resetFilterButtonSelector = "button#btnResetPlacesFilter";
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(resetFilterButtonSelector).click(function (e) {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()("input[name=filterPlaces]").val('');
      jquery__WEBPACK_IMPORTED_MODULE_0___default()("span#matches").text("");
      placesTree.clearFilter();
    }).attr("disabled", true);
    jquery__WEBPACK_IMPORTED_MODULE_0___default()("input[name=filterPlaces]").keyup(function (e) {
      var n,
          opts = {},
          match = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).val();

      if (e && e.which === jquery__WEBPACK_IMPORTED_MODULE_0___default.a.ui.keyCode.ESCAPE || jquery__WEBPACK_IMPORTED_MODULE_0___default.a.trim(match) === "") {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(resetFilterButtonSelector).click();
        return;
      } // Pass a string to perform case insensitive matching


      n = placesTree.filterNodes(match, opts);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(resetFilterButtonSelector).attr("disabled", false);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()("span#matches").text(n);
    }).focus();
  },
  init: function init(mapEntry) {
    return new Promise(function (resolve, reject) {
      jquery__WEBPACK_IMPORTED_MODULE_0___default.a.ajax({
        url: _ajaxMap__WEBPACK_IMPORTED_MODULE_4__["default"].ajaxServerPath,
        type: 'GET',
        data: {
          'id': _ajaxMap__WEBPACK_IMPORTED_MODULE_4__["default"].configData.mapSettings.pageId,
          'api': 'map',
          'action': 'listPlaces',
          'mapId': mapEntry.id
        },
        dataType: "json",
        success: function success(result) {
          // store places
          mapEntry.places = result;

          if (result.length) {
            var placesTree = _fancytree_renderer__WEBPACK_IMPORTED_MODULE_6__["default"].places(mapEntry, result);

            _.setEvents(placesTree);

            _.updatePlaces(mapEntry);
          }
        }
      });
    });
  }
};
var places = {
  init: _.init,
  showSoloPlace: _.showSoloPlace
};
/* harmony default export */ __webpack_exports__["default"] = (places);

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-regions.js":
/*!***************************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-regions.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fancytree_renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fancytree-renderer.js */ "./src/assets/scripts/lib/fancytree-renderer.js");
/* harmony import */ var _map_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-layers */ "./src/assets/scripts/lib/map-layers.js");



function init(mapEntry) {
  var regions = mapEntry.regions;

  if (regions) {
    regions.forEach(function (region) {
      _map_layers__WEBPACK_IMPORTED_MODULE_1__["default"].add(region, mapEntry);

      if (region.children.length) {
        region.children.forEach(function (childRegion) {
          _map_layers__WEBPACK_IMPORTED_MODULE_1__["default"].add(childRegion, mapEntry);
        });
      }
    });
    _fancytree_renderer_js__WEBPACK_IMPORTED_MODULE_0__["default"].regions(mapEntry);
  }
}

/* harmony default export */ __webpack_exports__["default"] = ({
  init: init
});

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap-ui.js":
/*!**********************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap-ui.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);

var _ = {
  cache: {
    $filterPlaces: null
  },
  init: function init() {
    _.cache.$filterPlaces = jquery__WEBPACK_IMPORTED_MODULE_0___default()('input[name=filterPlaces]');
    jquery__WEBPACK_IMPORTED_MODULE_0___default()('body').append('<div id="overlayDetailHelper">');

    _.reset();
  },
  reset: function reset() {
    _.cache.$filterPlaces.val('');
  }
};
/* harmony default export */ __webpack_exports__["default"] = ({
  init: _.init,
  reset: _.reset
});

/***/ }),

/***/ "./src/assets/scripts/lib/ajaxMap.js":
/*!*******************************************!*\
  !*** ./src/assets/scripts/lib/ajaxMap.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ajaxMap_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ajaxMap-map */ "./src/assets/scripts/lib/ajaxMap-map.js");
/* harmony import */ var _map_layers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-layers */ "./src/assets/scripts/lib/map-layers.js");
/* harmony import */ var _ajaxMap_regions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ajaxMap-regions */ "./src/assets/scripts/lib/ajaxMap-regions.js");
/* harmony import */ var _ajaxMap_places__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ajaxMap-places */ "./src/assets/scripts/lib/ajaxMap-places.js");
/* harmony import */ var _ajaxMap_locationTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ajaxMap-locationTypes */ "./src/assets/scripts/lib/ajaxMap-locationTypes.js");
/* harmony import */ var _fancytree_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fancytree-renderer */ "./src/assets/scripts/lib/fancytree-renderer.js");
/* harmony import */ var _utilitys__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utilitys */ "./src/assets/scripts/lib/utilitys.js");
/* harmony import */ var _lib_ajaxMap_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/ajaxMap-ui */ "./src/assets/scripts/lib/ajaxMap-ui.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ajaxProxyPort = __webpack_require__(/*! ../../../../package.json */ "./package.json").project.ajaxProxyPort;










var AjaxMap =
/*#__PURE__*/
function () {
  function AjaxMap(mapEntry) {
    _classCallCheck(this, AjaxMap);

    this.mapEntry = mapEntry;
    mapEntry.instance = this;
    mapEntry.layers = []; //88 maybe whle init?

    this.$mapEl = null;
  }

  _createClass(AjaxMap, [{
    key: "panTo",
    value: function panTo(lat, long) {}
  }]);

  return AjaxMap;
}();

var ajaxMap;
var _ = {
  panTo: function panTo(mapId) {
    "use strict"; //) console.log(mapCenter, '*****************')//http://jsfiddle.net/fqt7L/1/
  },
  initAllMaps: function initAllMaps() {
    return new Promise(function (resolve, reject) {
      var mapStore = ajaxMap.configData.mapStore;
      ajaxMap.maps = mapStore.map(function (mapEntry) {
        var ajaxMapInstance = new AjaxMap(mapEntry);
        _ajaxMap_map__WEBPACK_IMPORTED_MODULE_0__["default"].build(mapEntry).then(function (response) {
          _ajaxMap_locationTypes__WEBPACK_IMPORTED_MODULE_4__["default"].init(mapEntry, response.locationTypes);
          _map_layers__WEBPACK_IMPORTED_MODULE_1__["default"].buildStatic(mapEntry);
          _ajaxMap_regions__WEBPACK_IMPORTED_MODULE_2__["default"].init(mapEntry);
          _ajaxMap_places__WEBPACK_IMPORTED_MODULE_3__["default"].init(mapEntry);
          _fancytree_renderer__WEBPACK_IMPORTED_MODULE_5__["default"].category(mapEntry);
          _fancytree_renderer__WEBPACK_IMPORTED_MODULE_5__["default"].placeGroup(mapEntry);
        }); //same as mapstore!!no mpastore is [mapEntra] not instance

        ajaxMap.lookUp[mapEntry.id] = ajaxMapInstance;
        return ajaxMapInstance;
      });
    });
  }
};
ajaxMap = {
  //    TODO:
  //set public methods and vars.
  //eg:config data :settings.placeTree.renderItemFunction
  basePath: '',
  lookUp: {},
  //object of instances
  maps: [],
  //array of ajax-map object
  ajaxServerPath: 'http://localhost:' + ajaxProxyPort,
  //this path will be replaced bei build script: see readme.txt
  configData: null,
  init: function init(configData) {
    var url = 'https://maps.googleapis.com/maps/api/js?key=' + configData.mapSettings.keys.googleMap;
    ajaxMap.configData = configData;
    Object(_utilitys__WEBPACK_IMPORTED_MODULE_6__["inserScriptTag"])(url).then(function () {
      ajaxMap.configData = configData;

      _.initAllMaps();

      _lib_ajaxMap_ui__WEBPACK_IMPORTED_MODULE_7__["default"].init(); //Promise.all(ajaxMap.maps)
    }, console.error);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (ajaxMap);

/***/ }),

/***/ "./src/assets/scripts/lib/fancytree-renderer.js":
/*!******************************************************!*\
  !*** ./src/assets/scripts/lib/fancytree-renderer.js ***!
  \******************************************************/
/*! exports provided: updateTree, fancytreeSelector, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateTree", function() { return updateTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fancytreeSelector", function() { return fancytreeSelector; });
/* harmony import */ var _ajaxMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ajaxMap */ "./src/assets/scripts/lib/ajaxMap.js");
/* harmony import */ var _ajaxMap_places__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ajaxMap-places */ "./src/assets/scripts/lib/ajaxMap-places.js");
/* harmony import */ var _ajaxMap_locationTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ajaxMap-locationTypes */ "./src/assets/scripts/lib/ajaxMap-locationTypes.js");
/* harmony import */ var _ajaxMap_places_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ajaxMap-places-filter */ "./src/assets/scripts/lib/ajaxMap-places-filter.js");
/* harmony import */ var _utilitys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilitys */ "./src/assets/scripts/lib/utilitys.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_edit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jquery.fancytree/dist/modules/jquery.fancytree.edit */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.edit.js");
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_edit__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_modules_jquery_fancytree_edit__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_glyph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! jquery.fancytree/dist/modules/jquery.fancytree.glyph */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.glyph.js");
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_glyph__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_modules_jquery_fancytree_glyph__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_filter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! jquery.fancytree/dist/modules/jquery.fancytree.filter */ "./node_modules/jquery.fancytree/dist/modules/jquery.fancytree.filter.js");
/* harmony import */ var jquery_fancytree_dist_modules_jquery_fancytree_filter__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_modules_jquery_fancytree_filter__WEBPACK_IMPORTED_MODULE_8__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }










/**
 * Renders a fancyTree
 * fetches json data by ajax call
 *
 * @param select Selector for node
 * @param action Ajax eID action name
 * @param mapId
 * @param settings Optional settings
 */

function renderTreeAjax(select, action, mapId, settings) {
  var localSettings = {
    checkbox: true,
    cookieId: "fancyTree" + action + mapId,
    selectMode: 3,
    select: function select(event, data) {
      var mapEntry = _ajaxMap__WEBPACK_IMPORTED_MODULE_0__["default"].lookUp[mapId].mapEntry;
      _ajaxMap_places__WEBPACK_IMPORTED_MODULE_1__["default"].update(mapEntry, true);
    }
    /*   source: {
     url: "index.php",
     type: "GET",
     dataType: "json",
     data: {
     'id': mapSettings.pageId,
     'api': "map",
     'action': action,
     'mapId': mapId
     }
     }*/

  };

  if (_typeof(settings) === 'object') {
    for (var property in settings) {
      if (settings.hasOwnProperty(property)) {
        localSettings[property] = settings[property];
      }
    }
  }

  console.dir(localSettings);
  jquery__WEBPACK_IMPORTED_MODULE_5___default()(select).fancytree(localSettings).data('mapId', mapId);
}

var _ = {
  getPlaceTreeSettings: function getPlaceTreeSettings(mapEntry) {
    var placesTreeConfig = mapEntry.settings.placesTree ? mapEntry.settings.placesTree : _ajaxMap__WEBPACK_IMPORTED_MODULE_0__["default"].configData.mapSettings.settings.placesTree;
    return {
      cookieId: 'fancyTreePlaces' + mapEntry.id,
      selectMode: placesTreeConfig.selectMode,
      source: {
        mapNumber: mapEntry.id,
        //88??
        mapId: mapEntry.id,
        map: mapEntry.googleMap,
        children: []
      },
      icon: placesTreeConfig.icon,
      extensions: placesTreeConfig.extensions,
      quicksearch: placesTreeConfig.quicksearch,
      filter: placesTreeConfig.filter,
      activate: _ajaxMap_places__WEBPACK_IMPORTED_MODULE_1__["default"].showSoloPlace(mapEntry),
      autoScroll: true,
      renderTitle: function renderTitle(event, data) {
        if (placesTreeConfig.renderItem) {
          return placesTreeConfig.renderItem(event, data);
        }

        return null; //return markup;//('<span>maus</span>')
      }
    };
  }
};
var updateTree = {
  places: function places(mapEntry, children) {
    var selector = fancytreeSelector.places + mapEntry.id;
    var $rootNode = jquery__WEBPACK_IMPORTED_MODULE_5___default()(selector).fancytree('getRootNode');
    $rootNode.removeChildren();
    console.log('children', children, '+++++');
    $rootNode.addChildren(children);
    $rootNode.sortChildren(_utilitys__WEBPACK_IMPORTED_MODULE_4__["sort"].aplhabetic.asc, false);
    _ajaxMap_places_filter__WEBPACK_IMPORTED_MODULE_3__["default"].update($rootNode, mapEntry);
  }
};
var fancytreeSelector = {
  locationType: '#ajaxMapLocationTypesTree',
  category: '#ajaxMapCategoryTree',
  regions: '#ajaxMapRegionsTree',
  placeGroup: '#ajaxMapPlaceGroupTree',
  places: '#ajaxMapPlacesTree'
};
var renderTree = {
  places: function places(mapEntry, children) {
    var $placeTree = jquery__WEBPACK_IMPORTED_MODULE_5___default()(fancytreeSelector.places + mapEntry.id);

    var settings = _.getPlaceTreeSettings(mapEntry);

    $placeTree.fancytree(settings);

    $placeTree.renderNode = function (event, data) {
      alert('dffdffsaf');
      var node = data.node,
          $tdList = jquery__WEBPACK_IMPORTED_MODULE_5___default()(node.tr).find(">td");
      $tdList.eq(1).text(node.key);
    };

    updateTree.places(mapEntry, children);
    var placesTree = $placeTree.fancytree('getTree');
    return placesTree;
  },
  category: function category(mapEntry) {
    renderTreeAjax('#ajaxMapCategoryTree' + mapEntry.id, "listCategories", mapEntry.id, mapEntry.settings.categoryTree);
  },
  placeGroup: function placeGroup(mapEntry) {
    renderTreeAjax('#ajaxMapPlaceGroupTree' + mapEntry.id, "listPlaceGroups", mapEntry.id, mapEntry.settings.placeGroupTree);
  },
  regions: function regions(mapEntry) {
    var options = mapEntry.settings.regionTree;
    jquery__WEBPACK_IMPORTED_MODULE_5___default()('#ajaxMapRegionsTree' + mapEntry.id).fancytree({
      checkbox: options.checkbox,
      cookieId: 'fancyTreeRegions' + mapEntry.id,
      minExpandLevel: options.minExpandLevel,
      selectMode: options.selectMode,
      source: mapEntry.regions,
      filter: options.filter,
      extensions: options.extensions,
      glyph: options.glyph,
      icon: options.icons,
      select: function select(event, data) {
        var mapNumber = getMapNumber(data.tree.options.cookieId.split('fancyTreeRegions')[1]);
        var selectedNodes = data.tree.getSelectedNodes();
        var selectedKeys = jquery__WEBPACK_IMPORTED_MODULE_5___default.a.map(selectedNodes, function (node) {
          return node.key;
        });
        _ajaxMap__WEBPACK_IMPORTED_MODULE_0__["default"].updateLayers(mapNumber, selectedKeys);
        updatePlaces(mapNumber, true);
      }
    });
  },
  locationTypes: function locationTypes(mapEntry) {
    var options = mapEntry.settings.locationTypeTree;
    var settings = {
      checkbox: options.checkbox,
      cookieId: "fancyTreeLocationTypes" + mapEntry.id,
      selectMode: options.selectMode,
      extensions: options.extensions,
      glyph: options.glyph,
      filter: options.filter,
      source: mapEntry.locationTypes,
      select: function select(flag, node) {
        var mapNumber = getMapNumber(node.tree.options.cookieId.split('fancyTreeLocationTypes')[1]);
        updatePlaces(mapNumber, true);
      }
    };
    var selector = _ajaxMap_locationTypes__WEBPACK_IMPORTED_MODULE_2__["default"].treeSelector + mapEntry.id;
    jquery__WEBPACK_IMPORTED_MODULE_5___default()(selector).fancytree(settings);
  }
};
/* harmony default export */ __webpack_exports__["default"] = (renderTree);

/***/ }),

/***/ "./src/assets/scripts/lib/map-helpers.js":
/*!***********************************************!*\
  !*** ./src/assets/scripts/lib/map-helpers.js ***!
  \***********************************************/
/*! exports provided: getLocationType, getSelectedKeys, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocationType", function() { return getLocationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSelectedKeys", function() { return getSelectedKeys; });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _google_markerclusterer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @google/markerclusterer */ "../node_modules/@google/markerclusterer/src/markerclusterer.js");
/* harmony import */ var _google_markerclusterer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_google_markerclusterer__WEBPACK_IMPORTED_MODULE_1__);
/**
 * Created by d.eggermann on 30.10.19.
 */


var helpers = {
  getLocationType: function getLocationType(mapEntry, typeId) {
    return mapEntry.locationTypes.filter(function (item) {
      return item.key === typeId;
    });
  },
  getSelectedKeys: function getSelectedKeys(selector) {
    var tree = jquery__WEBPACK_IMPORTED_MODULE_0___default()(selector).fancytree('getTree');
    return typeof tree.getSelectedNodes === 'function' ? tree.getSelectedNodes().map(function (node) {
      return parseInt(node.key);
    }) : [];
  },
  setDimension: function setDimension($mapEl, response) {
    $mapEl.height(response.height).width(response.width);
  },
  getLatLong: function getLatLong(coordsStr) {
    if (!coordsStr) {
      throw new Error('no map [lat,long]');
    }

    var coords = coordsStr.split(',').map(function (part) {
      return parseFloat(part);
    });
    return new google.maps.LatLng(coords[0], coords[1]);
  },
  getMapType: function getMapType(type) {
    switch (type) {
      case '2':
        return google.maps.MapTypeId.SATELLITE;

      case '3':
        return google.maps.MapTypeId.HYBRID;

      case '4':
        return google.maps.MapTypeId.TERRAIN;

      default:
        // 0 - 'Styled Map' and 1 - 'Road Map' will become ROADMAP
        return google.maps.MapTypeId.ROADMAP;
    }
  },
  getMapStyle: function getMapStyle(response) {
    if (response.type === '0' && response.mapStyle) {
      return jquery__WEBPACK_IMPORTED_MODULE_0___default.a.parseJSON('[' + response.mapStyle + ']');
    }

    return '';
  },
  getInfoWindow: function getInfoWindow() {
    return new google.maps.InfoWindow({
      maxWidth: 370
    });
  },
  getMarkerClusterer: function getMarkerClusterer(map, markerClusterer) {
    return new _google_markerclusterer__WEBPACK_IMPORTED_MODULE_1___default.a(map, [], markerClusterer);
  },
  createGooglMap: function createGooglMap(response, $el) {
    helpers.setDimension($el, response);
    var mapType = helpers.getMapType(response.type);
    var mapStyle = helpers.getMapStyle(response.type);
    var mapCenter = helpers.getLatLong(response.mapCenter); //build map

    return new google.maps.Map($el[0], {
      zoom: response.initialZoom,
      center: mapCenter,
      mapTypeId: mapType,
      styles: mapStyle,
      disableDefaultUI: response.disableDefaultUI
    });
  }
};
var getLocationType = helpers.getLocationType;
var getSelectedKeys = helpers.getSelectedKeys;
/* harmony default export */ __webpack_exports__["default"] = (helpers);

/***/ }),

/***/ "./src/assets/scripts/lib/map-layers.js":
/*!**********************************************!*\
  !*** ./src/assets/scripts/lib/map-layers.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _ = {
  getBasePath: function getBasePath() {
    if (_.basePath) {
      return _.basePath;
    }

    var basePath = window.location.protocol + "//" + window.location.host + "/";
    var webkitPath = window.location.origin + "/";
    _.basePath = !window.location.origin ? basePath : webkitPath;
    return _.basePath;
  }
};
var layers = {
  update: function update(mapEntry, layerIds) {
    var existingLayers = mapEntry.layers;

    if (typeof existingLayers !== 'undefined') {
      var existingKeys = Object.keys(existingLayers);

      for (var i = 0; i < existingKeys.length; i++) {
        var key = existingKeys[i];

        if (layerIds.indexOf(parseInt(key)) > -1) {
          mapEntry.layers[key].setMap(mapEntry.map);
        } else {
          mapEntry.layers[key].setMap(null);
        }
      }
    }
  },
  add: function add(newLayerData, mapEntry) {
    //        88
    if (!mapEntry.layers[newLayerData.key]) {
      var layerUrl = _.getBasePath() + newLayerData.file,
          layerOptions = {
        clickable: newLayerData.clickable,
        preserveViewport: newLayerData.preserveViewport,
        suppressInfoWindows: newLayerData.suppressInfoWindows
      },
          newLayer = new google.maps.KmlLayer(layerUrl, layerOptions);

      if (typeof newLayer !== 'undefined') {
        mapEntry.layers[newLayerData.key] = newLayer;
      }
    }
  },
  addStatic: function addStatic(layerData, mapEntry) {
    var layerUrl = _.getBasePath() + layerData.file;
    var layerOptions = {
      clickable: layerData.clickable,
      preserveViewport: layerData.preserveViewport,
      suppressInfoWindows: layerData.suppressInfoWindows
    };
    var newLayer = new google.maps.KmlLayer(layerUrl, layerOptions);
    newLayer.setMap(mapEntry.map);
  },
  buildStatic: function buildStatic(mapEntry) {
    var staticLayers = mapEntry.settings.staticLayers;

    if (staticLayers) {
      staticLayers.forEach(function (staticLayer) {
        layers.addStatic(staticLayer, mapEntry);

        if (staticLayer.children.length) {
          staticLayer.children.forEach(function (childRegion) {
            layers.addStatic(childRegion, mapEntry);
          });
        }
      });
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (layers);

/***/ }),

/***/ "./src/assets/scripts/lib/map-marker-info-window.js":
/*!**********************************************************!*\
  !*** ./src/assets/scripts/lib/map-marker-info-window.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ajaxMap_places_detail_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ajaxMap-places-detail-view */ "./src/assets/scripts/lib/ajaxMap-places-detail-view.js");
/* harmony import */ var _utilitys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utilitys */ "./src/assets/scripts/lib/utilitys.js");
/* harmony import */ var _map_marker_info_window__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./map-marker-info-window */ "./src/assets/scripts/lib/map-marker-info-window.js");




var _ = {
  cache: {},
  markup: {
    address: function address(addressJson) {
      var address = '<div class="infoWindowAddress"><div class="infoWindowStreet">' + addressJson.address + '</div>' + '<div class="infoWindowZip">' + addressJson.zip + '</div><div class="infoWindowCity">' + addressJson.city + '</div>' + '</div>';
    },
    categoryList: function categoryList(categories) {
      var list;

      if (categories) {
        list = '<div><ul class="placeCategories">';
        jquery__WEBPACK_IMPORTED_MODULE_0___default.a.each(categories, function () {
          list += '<li>' + this.title + '</li>';
        });
        list += '</ul></div>';
      }

      return list;
    },
    content: function content(data) {
      var place = data.place,
          categoryList = data.categoryList,
          address = data.address;
      var content = '';
      content += place.title ? '<h4 class="infoWindowTitle">' + place.title + '</h4>' : "";
      content += place.icon ? '<img width="120px" class="infoWindowImage" src="' + place.icon + '"/>' : ""; //'<p class="infoWindowDescription">' + place.description + '</p>';

      content += categoryList ? categoryList : '';
      content += address ? address : '';
      /*
       *  special for ext. browser see below - should be changed to use own content
       */

      content += '<div class="browserHelper"><a class="more detail-view" href="#">mehr</a></div>';
      return content;
    }
  },
  getAddress: function getAddress(place) {
    return new Promise(function (resolve, reject) {
      var markup = _.markup.address;

      if (place.address) {
        return resolve(markup(place.address));
      }

      return Object(_utilitys__WEBPACK_IMPORTED_MODULE_2__["getAddress"])(place.uid).then(function (address) {
        place.address = address;
        return resolve(markup(address));
      });
    });
  },
  initCache: function initCache() {
    _.cache.$body = jquery__WEBPACK_IMPORTED_MODULE_0___default()('body');
    _.cache.$moreDetailView = jquery__WEBPACK_IMPORTED_MODULE_0___default()('.more.detail-view');
  },
  checkCache: function checkCache() {
    if (_.cache.$body) {
      return;
    }

    _.initCache();
  }
};
var infoWindow = {
  /**
   * Renders the info window content for a place
   *
   * @param place
   * @returns {string|*}
   */
  getInfoWindowContent: function getInfoWindowContent(place) {
    return new Promise(function (resolve, reject) {
      return _.getAddress(place).then(function (addressMarkup) {
        /**
         * @todo make content rendering configurable, add link for overlay with additional info
         */
        // build a list of place's categories
        var listMarkup = _.markup.categoryList(place.categories);

        var data = {
          addressMarkup: addressMarkup,
          listMarkup: listMarkup,
          place: place
        };
        return resolve(_.markup.content(data));
      });
    });
  },
  createOnClick: function createOnClick(mapEntry, place) {
    return function () {
      _.checkCache();

      var map = mapEntry.googleMap,
          infoWindow = mapEntry.infoWindow;
      _map_marker_info_window__WEBPACK_IMPORTED_MODULE_3__["default"].getInfoWindowContent(place).then(function (content) {
        infoWindow.setContent(content); //888 should be multiple?

        _.cache.$body.append('<div id="detailView"><a id="overlay-close" style="display: inline;"></a><div class="inner"></div></div>');

        jquery__WEBPACK_IMPORTED_MODULE_0___default()('#detailView').data('placeId', place.key);
        infoWindow.open(map, this);
      });
      google.maps.event.addListener(infoWindow, 'domready', function () {
        _.cache.$moreDetailView.unbind("click").bind('click', function (event) {
          event.preventDefault(); //TODO: refactor without data-attribute

          _ajaxMap_places_detail_view__WEBPACK_IMPORTED_MODULE_1__["default"].open("infoWindow", -1);
          event.stopPropagation();
          return false;
        });
      });
    };
  }
};
/* harmony default export */ __webpack_exports__["default"] = (infoWindow);

/***/ }),

/***/ "./src/assets/scripts/lib/map-marker.js":
/*!**********************************************!*\
  !*** ./src/assets/scripts/lib/map-marker.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _map_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-helpers */ "./src/assets/scripts/lib/map-helpers.js");
/* harmony import */ var _map_marker_info_window__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-marker-info-window */ "./src/assets/scripts/lib/map-marker-info-window.js");




function addMarkerClickFunction(mapEntry, place) {
  return function () {
    if (window.ajaxMapConfig && ajaxMapConfig.onMarkerClick) {
      ajaxMapConfig.onMarkerClick(mapEntry, place);
    }

    _map_marker_info_window__WEBPACK_IMPORTED_MODULE_1__["default"].createOnClick();
  };
}

function create(mapEntry, place) {
  var map = mapEntry.googleMap,
      currType = place.locationType && place.locationType.key,
      currLatlng = _map_helpers__WEBPACK_IMPORTED_MODULE_0__["default"].getLatLong(place.geoCoordinates);
  var mapMarker = new google.maps.Marker({
    position: currLatlng,
    map: map,
    title: place.title
  });

  if (currType) {
    var locationTyp = Object(_map_helpers__WEBPACK_IMPORTED_MODULE_0__["getLocationType"])(mapEntry, currType);
    mapMarker.setIcon(locationTyp.icon);
  }

  mapMarker.mapNumber = mapEntry.id;
  mapMarker.place = place; // add click function

  var clickFunction = addMarkerClickFunction(mapEntry, place);
  google.maps.event.addListener(mapMarker, 'click', clickFunction);
  return mapMarker;
}

var marker = {
  create: create
};
/* harmony default export */ __webpack_exports__["default"] = (marker);

/***/ }),

/***/ "./src/assets/scripts/lib/utilitys.js":
/*!********************************************!*\
  !*** ./src/assets/scripts/lib/utilitys.js ***!
  \********************************************/
/*! exports provided: sort, inserScriptTag, getAddress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sort", function() { return sort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inserScriptTag", function() { return inserScriptTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAddress", function() { return getAddress; });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ajaxMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ajaxMap */ "./src/assets/scripts/lib/ajaxMap.js");
/**
 * Created by d.eggermann on 30.10.19.
 */


var sort = {
  aplhabetic: {
    asc: function asc(a, b) {
      a = a.title.toLowerCase();
      b = b.title.toLowerCase();
      return a > b ? 1 : a < b ? -1 : 0;
    }
  },
  nummeric: {
    asc: function asc(a, b) {
      //Todo Postleitzahl
      a = a.title.toLowerCase();
      b = b.title.toLowerCase();
      return a > b ? 1 : a < b ? -1 : 0;
    }
  }
};
var inserScriptTag = function inserScriptTag(src) {
  return new Promise(function (resolve, reject) {
    var script = document.createElement('script');
    script.src = src;
    script.async = true;
    script.onload = resolve;
    script.onerror = reject;
    var entry = document.getElementsByTagName('script')[0];
    entry.parentNode.insertBefore(script, entry);
  });
};
/**
 * get address for a single place
 * @param placeId
 * @return json
 */

var getAddress = function getAddress(placeId) {
  return new Promise(function (resolve, reject) {
    jquery__WEBPACK_IMPORTED_MODULE_0___default.a.ajax({
      url: _ajaxMap__WEBPACK_IMPORTED_MODULE_1__["default"].ajaxServerPath,
      type: GET,
      data: {
        'id': _ajaxMap__WEBPACK_IMPORTED_MODULE_1__["default"].configData.mapSettings.pageId,
        'api': 'map',
        'action': "getAddress",
        'placeId': placeId
      },
      dataType: 'json',
      success: resolve,
      error: reject
    });
  });
};

/***/ }),

/***/ "./src/assets/scripts/main.js":
/*!************************************!*\
  !*** ./src/assets/scripts/main.js ***!
  \************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_ajaxMap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/ajaxMap */ "./src/assets/scripts/lib/ajaxMap.js");
/* harmony import */ var _dist_css_main_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../dist/css/main.css */ "./dist/css/main.css");
/* harmony import */ var _dist_css_main_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_dist_css_main_css__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var jquery_fancytree_dist_skin_awesome_ui_fancytree_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css */ "./node_modules/jquery.fancytree/dist/skin-awesome/ui.fancytree.min.css");
/* harmony import */ var jquery_fancytree_dist_skin_awesome_ui_fancytree_min_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jquery_fancytree_dist_skin_awesome_ui_fancytree_min_css__WEBPACK_IMPORTED_MODULE_3__);




jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).ready(function () {
  if (!mapStore || !(mapStore instanceof Array)) {
    console.log(' no mapstore', mapStore);
    return;
  }

  var configData = {
    mapSettings: window.mapSettings,
    mapStore: window.mapStore
  };
  _lib_ajaxMap__WEBPACK_IMPORTED_MODULE_1__["default"].init(configData); //initialize all maps
});

/***/ }),

/***/ "./src/assets/styles/main.scss":
/*!*************************************!*\
  !*** ./src/assets/styles/main.scss ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 0:
/*!************************************************************************!*\
  !*** multi ./src/assets/scripts/main.js ./src/assets/styles/main.scss ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! /Users/d.eggermann/Projekte/ajaxmap-ssh/FE-Development/src/assets/scripts/main.js */"./src/assets/scripts/main.js");
module.exports = __webpack_require__(/*! /Users/d.eggermann/Projekte/ajaxmap-ssh/FE-Development/src/assets/styles/main.scss */"./src/assets/styles/main.scss");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9AZ29vZ2xlL21hcmtlcmNsdXN0ZXJlci9zcmMvbWFya2VyY2x1c3RlcmVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzdC9jc3MvbWFpbi5jc3M/MjIyYiIsIndlYnBhY2s6Ly8vLi9kaXN0L2Nzcy9tYWluLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LmZhbmN5dHJlZS9kaXN0L3NraW4tYXdlc29tZS91aS5mYW5jeXRyZWUubWluLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUuZWRpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LmZhbmN5dHJlZS9kaXN0L21vZHVsZXMvanF1ZXJ5LmZhbmN5dHJlZS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUuZ2x5cGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUudWktZGVwcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LmZhbmN5dHJlZS9kaXN0L3NraW4tYXdlc29tZS91aS5mYW5jeXRyZWUubWluLmNzcz8wOThjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkuZmFuY3l0cmVlL2Rpc3Qvc2tpbi1hd2Vzb21lL3ZsaW5lLXJ0bC5naWYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9za2luLWF3ZXNvbWUvdmxpbmUuZ2lmIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2xpYi9hamF4TWFwLWxvY2F0aW9uVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2xpYi9hamF4TWFwLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3NjcmlwdHMvbGliL2FqYXhNYXAtcGxhY2VzLWRldGFpbC12aWV3LmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2NyaXB0cy9saWIvYWpheE1hcC1wbGFjZXMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2NyaXB0cy9saWIvYWpheE1hcC1wbGFjZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2xpYi9hamF4TWFwLXJlZ2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2xpYi9hamF4TWFwLXVpLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2NyaXB0cy9saWIvYWpheE1hcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3NjcmlwdHMvbGliL2ZhbmN5dHJlZS1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3NjcmlwdHMvbGliL21hcC1oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2NyaXB0cy9saWIvbWFwLWxheWVycy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXNzZXRzL3NjcmlwdHMvbGliL21hcC1tYXJrZXItaW5mby13aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL2xpYi9tYXAtbWFya2VyLmpzIiwid2VicGFjazovLy8uL3NyYy9hc3NldHMvc2NyaXB0cy9saWIvdXRpbGl0eXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zY3JpcHRzL21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9zdHlsZXMvbWFpbi5zY3NzIl0sIm5hbWVzIjpbIm1hcExvY2F0aW9uVHlwZXMiLCJ0cmVlU2VsZWN0b3IiLCJ1aSIsIm1hcEVudHJ5IiwiY3VyckxvY2F0aW9uVHlwZXMiLCJsb2NhdGlvblR5cGVzIiwibWFwSWQiLCJpZCIsInR5cGUiLCIkIiwidmFsIiwia2V5IiwidGV4dCIsInRpdGxlIiwiYXBwZW5kVG8iLCJjaGFuZ2UiLCJwbGFjZXMiLCJ1cGRhdGVQbGFjZXMiLCJpbml0IiwidHJlZVJlbmRlcmVyIiwiX21hcCIsImdldE1hcERhdGEiLCJkYXRhIiwiYWpheE1hcCIsImNvbmZpZ0RhdGEiLCJtYXBTZXR0aW5ncyIsInBhZ2VJZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiYWpheCIsImRhdGFUeXBlIiwidXJsIiwiYWpheFNlcnZlclBhdGgiLCJzdWNjZXNzIiwiZXJyb3IiLCJidWlsZCIsInNldHRpbmdzIiwidGhlbiIsInJlc3BvbnNlIiwiJGVsIiwiZ29vZ2xlTWFwIiwibWFwSGVscGVycyIsImNyZWF0ZUdvb2dsTWFwIiwiaW5mb1dpbmRvdyIsImdldEluZm9XaW5kb3ciLCJtYXJrZXJDbHVzdGVyZXIiLCJnZXRNYXJrZXJDbHVzdGVyZXIiLCJyZWdpb25zIiwic3RhdGljTGF5ZXJzIiwiZ29vZ2xlQXBpS2V5IiwiT2JqZWN0IiwiYXNzaWduIiwicGFuVG8iLCJvcGVuRGV0YWlsVmlldyIsImNhbGxlciIsInBsYWNlSWQiLCJwYXRoIiwibG9jYXRpb24iLCJhdHRyIiwiaW5kZXhPZiIsImNvbnRleHQiLCJ0eF9hamF4bWFwX21hcCIsImRvbmUiLCJodG1sIiwiZmFkZUluIiwiaGVpZ2h0IiwiZG9jdW1lbnQiLCJjbGljayIsImZhZGVPdXQiLCJjb250ZW50cyIsInJlbW92ZSIsInVwZGF0ZSIsIiRyb290Tm9kZSIsImZpbHRlcnMiLCJwbGFjZXNUcmVlIiwidXBkYXRlRmlsdGVycyIsImVhY2giLCJmaWx0ZXJOYW1lIiwiZmlsdGVyIiwidHJlZU5hbWUiLCJ0cmVlIiwiZmFuY3l0cmVlIiwiY2hpbGRyZW4iLCJwbGFjZUtleXMiLCJnZXRLZXlzQnlBdHRyaWJ1dGUiLCJmaWx0ZXJUcmVlIiwidXBkYXRlTGF5ZXJzIiwic2VsZWN0ZWRLZXlzIiwiZ2V0U2VsZWN0ZWRLZXlzIiwibGF5ZXJzIiwiZXJyIiwiY29uc29sZSIsImxvZyIsIm5hbWUiLCJrZXlzIiwiaW5kZXgiLCJjaGlsZCIsImhhc093blByb3BlcnR5IiwiYXR0cmlidXRlIiwidW5kZWZpbmVkIiwicHVzaCIsIkFycmF5IiwiaSIsImsiLCJsZW5ndGgiLCJvcHRpb25zIiwiYXV0b0V4cGFuZCIsImZpbHRlck5vZGVzIiwibm9kZSIsInBhcnNlSW50Iiwic2hvd01hdGNoaW5nUGxhY2VzIiwibWFwIiwibWFwUGxhY2VzIiwic2VsZWN0ZWRQbGFjZXMiLCJjbHVzdGVyZXIiLCJtYXBNYXJrZXJzIiwibWFya2VycyIsInNlbGVjdGVkTG9jYXRpb25UeXBlS2V5cyIsImZhbmN5dHJlZVNlbGVjdG9yIiwibG9jYXRpb25UeXBlIiwic2VsZWN0ZWRDYXRlZ29yeUtleXMiLCJjYXRlZ29yeSIsInNlbGVjdGVkUmVnaW9uS2V5cyIsInNlbGVjdGVkUGxhY2VHcm91cEtleXMiLCJwbGFjZUdyb3VwIiwic2VsZWN0ZWRMb2NhdGlvblR5cGUiLCJyZW1vdmVNYXJrZXJzIiwiaiIsInBsYWNlIiwibWFya2VyIiwiY3JlYXRlIiwiaGFzQW5BY3RpdmVDYXRlZ29yeSIsImhhc0FuQWN0aXZlUmVnaW9uIiwiaGFzQW5BY3RpdmVQbGFjZUdyb3VwIiwiY2F0ZWdvcmllcyIsImluQXJyYXkiLCJwbGFjZUdyb3VwcyIsInNldE1hcCIsInVwZGF0ZVRyZWUiLCJzaG93U2VsZWN0ZWRQbGFjZXMiLCJzZWxlY3RlZFBsYWNlS2V5cyIsImZvckVhY2giLCJyZW1vdmVNYXJrZXIiLCJhZGRNYXJrZXJzIiwiaXNTZWxlY3RlZFBsYWNlIiwic29tZSIsImZpbHRlclBsYWNlcyIsIl8iLCJjbGVhclNlbGVjdGVkIiwiY2xlYXJGaWx0ZXIiLCJ2aXNpdCIsInNldFNlbGVjdGVkIiwicGxhY2VzRmlsdGVyIiwic2hvd1NvbG9QbGFjZSIsImV2ZW50Iiwic2VsZWN0ZWQiLCJ0b2dnbGVJbmZvV2luZG93T25TZWxlY3QiLCJtYXJrZXJJbmZvV2luZG93IiwiZ2V0SW5mb1dpbmRvd0NvbnRlbnQiLCJjb250ZW50Iiwic2V0Q29udGVudCIsIm9wZW4iLCJjbG9zZSIsInNldEFjdGl2ZSIsInNldEV2ZW50cyIsInJlc2V0RmlsdGVyQnV0dG9uU2VsZWN0b3IiLCJlIiwia2V5dXAiLCJuIiwib3B0cyIsIm1hdGNoIiwid2hpY2giLCJrZXlDb2RlIiwiRVNDQVBFIiwidHJpbSIsImZvY3VzIiwicmVzdWx0IiwicmVnaW9uIiwiYWRkIiwiY2hpbGRSZWdpb24iLCJjYWNoZSIsIiRmaWx0ZXJQbGFjZXMiLCJhcHBlbmQiLCJyZXNldCIsImFqYXhQcm94eVBvcnQiLCJyZXF1aXJlIiwicHJvamVjdCIsIkFqYXhNYXAiLCJpbnN0YW5jZSIsIiRtYXBFbCIsImxhdCIsImxvbmciLCJpbml0QWxsTWFwcyIsIm1hcFN0b3JlIiwibWFwcyIsImFqYXhNYXBJbnN0YW5jZSIsIm1hcExheWVycyIsImJ1aWxkU3RhdGljIiwiZmFuY3lUcmVlUmVuZGVyZXIiLCJsb29rVXAiLCJiYXNlUGF0aCIsImluc2VyU2NyaXB0VGFnIiwicmVuZGVyVHJlZUFqYXgiLCJzZWxlY3QiLCJhY3Rpb24iLCJsb2NhbFNldHRpbmdzIiwiY2hlY2tib3giLCJjb29raWVJZCIsInNlbGVjdE1vZGUiLCJwcm9wZXJ0eSIsImRpciIsImdldFBsYWNlVHJlZVNldHRpbmdzIiwicGxhY2VzVHJlZUNvbmZpZyIsInNvdXJjZSIsIm1hcE51bWJlciIsImljb24iLCJleHRlbnNpb25zIiwicXVpY2tzZWFyY2giLCJhY3RpdmF0ZSIsImF1dG9TY3JvbGwiLCJyZW5kZXJUaXRsZSIsInJlbmRlckl0ZW0iLCJzZWxlY3RvciIsInJlbW92ZUNoaWxkcmVuIiwiYWRkQ2hpbGRyZW4iLCJzb3J0Q2hpbGRyZW4iLCJzb3J0IiwiYXBsaGFiZXRpYyIsImFzYyIsInJlbmRlclRyZWUiLCIkcGxhY2VUcmVlIiwicmVuZGVyTm9kZSIsImFsZXJ0IiwiJHRkTGlzdCIsInRyIiwiZmluZCIsImVxIiwiY2F0ZWdvcnlUcmVlIiwicGxhY2VHcm91cFRyZWUiLCJyZWdpb25UcmVlIiwibWluRXhwYW5kTGV2ZWwiLCJnbHlwaCIsImljb25zIiwiZ2V0TWFwTnVtYmVyIiwic3BsaXQiLCJzZWxlY3RlZE5vZGVzIiwiZ2V0U2VsZWN0ZWROb2RlcyIsImxvY2F0aW9uVHlwZVRyZWUiLCJmbGFnIiwiaGVscGVycyIsImdldExvY2F0aW9uVHlwZSIsInR5cGVJZCIsIml0ZW0iLCJzZXREaW1lbnNpb24iLCJ3aWR0aCIsImdldExhdExvbmciLCJjb29yZHNTdHIiLCJFcnJvciIsImNvb3JkcyIsInBhcnQiLCJwYXJzZUZsb2F0IiwiZ29vZ2xlIiwiTGF0TG5nIiwiZ2V0TWFwVHlwZSIsIk1hcFR5cGVJZCIsIlNBVEVMTElURSIsIkhZQlJJRCIsIlRFUlJBSU4iLCJST0FETUFQIiwiZ2V0TWFwU3R5bGUiLCJtYXBTdHlsZSIsInBhcnNlSlNPTiIsIkluZm9XaW5kb3ciLCJtYXhXaWR0aCIsIk1hcmtlckNsdXN0ZXJlciIsIm1hcFR5cGUiLCJtYXBDZW50ZXIiLCJNYXAiLCJ6b29tIiwiaW5pdGlhbFpvb20iLCJjZW50ZXIiLCJtYXBUeXBlSWQiLCJzdHlsZXMiLCJkaXNhYmxlRGVmYXVsdFVJIiwiZ2V0QmFzZVBhdGgiLCJ3aW5kb3ciLCJwcm90b2NvbCIsImhvc3QiLCJ3ZWJraXRQYXRoIiwib3JpZ2luIiwibGF5ZXJJZHMiLCJleGlzdGluZ0xheWVycyIsImV4aXN0aW5nS2V5cyIsIm5ld0xheWVyRGF0YSIsImxheWVyVXJsIiwiZmlsZSIsImxheWVyT3B0aW9ucyIsImNsaWNrYWJsZSIsInByZXNlcnZlVmlld3BvcnQiLCJzdXBwcmVzc0luZm9XaW5kb3dzIiwibmV3TGF5ZXIiLCJLbWxMYXllciIsImFkZFN0YXRpYyIsImxheWVyRGF0YSIsInN0YXRpY0xheWVyIiwibWFya3VwIiwiYWRkcmVzcyIsImFkZHJlc3NKc29uIiwiemlwIiwiY2l0eSIsImNhdGVnb3J5TGlzdCIsImxpc3QiLCJnZXRBZGRyZXNzIiwidWlkIiwiaW5pdENhY2hlIiwiJGJvZHkiLCIkbW9yZURldGFpbFZpZXciLCJjaGVja0NhY2hlIiwiYWRkcmVzc01hcmt1cCIsImxpc3RNYXJrdXAiLCJjcmVhdGVPbkNsaWNrIiwiYWRkTGlzdGVuZXIiLCJ1bmJpbmQiLCJiaW5kIiwicHJldmVudERlZmF1bHQiLCJkZXRhaWxWaWV3Iiwic3RvcFByb3BhZ2F0aW9uIiwiYWRkTWFya2VyQ2xpY2tGdW5jdGlvbiIsImFqYXhNYXBDb25maWciLCJvbk1hcmtlckNsaWNrIiwiY3VyclR5cGUiLCJjdXJyTGF0bG5nIiwiZ2VvQ29vcmRpbmF0ZXMiLCJtYXBNYXJrZXIiLCJNYXJrZXIiLCJwb3NpdGlvbiIsImxvY2F0aW9uVHlwIiwic2V0SWNvbiIsImNsaWNrRnVuY3Rpb24iLCJhIiwiYiIsInRvTG93ZXJDYXNlIiwibnVtbWVyaWMiLCJzcmMiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwiYXN5bmMiLCJvbmxvYWQiLCJvbmVycm9yIiwiZW50cnkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJHRVQiLCJyZWFkeSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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RztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUJBQXVCO0FBQzlCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLENBQUMsRUFBRTs7Ozs7Ozs7Ozs7O0FDeGNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLElBQTBDO0FBQy9D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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLHFCQUFxQjtBQUNyQix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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Q0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0MsS0FBSyxhQUFhO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDLE1BQU07QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsaUNBQWlDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyxhQUFhLE9BQU8saUJBQWlCLHlDQUF5QztBQUM5RTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTyx5Q0FBeUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU8seUNBQXlDO0FBQzdELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQjtBQUN4RTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsY0FBYztBQUM3QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLGNBQWM7QUFDN0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRCxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsa0NBQWtDO0FBQy9DLGFBQWEsSUFBSTtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU8seUNBQXlDO0FBQzdELGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGNBQWM7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx3Q0FBd0M7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixhQUFhLGNBQWM7QUFDM0IsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxPQUFPLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxjQUFjO0FBQzNCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQiw4RUFBOEUsdUNBQXVDO0FBQ3JILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2QkFBNkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0Esd0JBQXdCLDJEQUEyRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsVUFBVTtBQUNWLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYywwQ0FBMEM7QUFDeEQsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVEsa0JBQWtCO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QywyQkFBMkIsUUFBUSxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNCQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsZUFBZTtBQUNuRCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRCxDQUFDOzs7Ozs7Ozs7Ozs7QUMvekNELGNBQWMsbUJBQU8sQ0FBQyw4SkFBdUQ7O0FBRTdFO0FBQ0EsY0FBYyxRQUFTO0FBQ3ZCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLGdLQUFvRjs7QUFFekc7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNmQSxpQkFBaUIscUJBQXVCLDBDOzs7Ozs7Ozs7OztBQ0F4QyxpQkFBaUIscUJBQXVCLDBDOzs7Ozs7Ozs7OztBQ0F4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sS0FBMEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsZUFBZTs7QUFFZixTQUFTOztBQUVUO0FBQ0EsUUFBUSxpQ0FBaUM7QUFDekMsUUFBUSxvQkFBb0I7QUFDNUIsUUFBUSxzQ0FBc0M7QUFDOUMsUUFBUTtBQUNSLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVTtBQUMzRSxzQ0FBc0MsMkJBQTJCO0FBQ2pFO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjLHFDQUFxQztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw4QkFBOEI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFF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QSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNI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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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Q05BLHVDIiwiZmlsZSI6ImpzL21haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9yZXNvdXJjZXNcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQGNvbXBpbGF0aW9uX2xldmVsIEFEVkFOQ0VEX09QVElNSVpBVElPTlNcbi8vIEBleHRlcm5zX3VybCBodHRwOi8vY2xvc3VyZS1jb21waWxlci5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvY29udHJpYi9leHRlcm5zL21hcHMvZ29vZ2xlX21hcHNfYXBpX3YzXzMuanNcbi8vID09L0Nsb3N1cmVDb21waWxlcj09XG5cbi8qKlxuICogQG5hbWUgTWFya2VyQ2x1c3RlcmVyIGZvciBHb29nbGUgTWFwcyB2M1xuICogQHZlcnNpb24gdmVyc2lvbiAxLjAuM1xuICogQGF1dGhvciBMdWtlIE1haGVcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoZSBsaWJyYXJ5IGNyZWF0ZXMgYW5kIG1hbmFnZXMgcGVyLXpvb20tbGV2ZWwgY2x1c3RlcnMgZm9yIGxhcmdlIGFtb3VudHMgb2ZcbiAqIG1hcmtlcnMuXG4gKi9cblxuLyoqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG4vKipcbiAqIEEgTWFya2VyIENsdXN0ZXJlciB0aGF0IGNsdXN0ZXJzIG1hcmtlcnMuXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5NYXB9IG1hcCBUaGUgR29vZ2xlIG1hcCB0byBhdHRhY2ggdG8uXG4gKiBAcGFyYW0ge0FycmF5Ljxnb29nbGUubWFwcy5NYXJrZXI+PX0gb3B0X21hcmtlcnMgT3B0aW9uYWwgbWFya2VycyB0byBhZGQgdG9cbiAqICAgdGhlIGNsdXN0ZXIuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICogICAgICdncmlkU2l6ZSc6IChudW1iZXIpIFRoZSBncmlkIHNpemUgb2YgYSBjbHVzdGVyIGluIHBpeGVscy5cbiAqICAgICAnbWF4Wm9vbSc6IChudW1iZXIpIFRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgdGhhdCBhIG1hcmtlciBjYW4gYmUgcGFydCBvZiBhXG4gKiAgICAgICAgICAgICAgICBjbHVzdGVyLlxuICogICAgICd6b29tT25DbGljayc6IChib29sZWFuKSBXaGV0aGVyIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBjbGlja2luZyBvbiBhXG4gKiAgICAgICAgICAgICAgICAgICAgY2x1c3RlciBpcyB0byB6b29tIGludG8gaXQuXG4gKiAgICAgJ2ltYWdlUGF0aCc6IChzdHJpbmcpIFRoZSBiYXNlIFVSTCB3aGVyZSB0aGUgaW1hZ2VzIHJlcHJlc2VudGluZ1xuICogICAgICAgICAgICAgICAgICBjbHVzdGVycyB3aWxsIGJlIGZvdW5kLiBUaGUgZnVsbCBVUkwgd2lsbCBiZTpcbiAqICAgICAgICAgICAgICAgICAge2ltYWdlUGF0aH1bMS01XS57aW1hZ2VFeHRlbnNpb259XG4gKiAgICAgICAgICAgICAgICAgIERlZmF1bHQ6ICcuLi9pbWFnZXMvbScuXG4gKiAgICAgJ2ltYWdlRXh0ZW5zaW9uJzogKHN0cmluZykgVGhlIHN1ZmZpeCBmb3IgaW1hZ2VzIFVSTCByZXByZXNlbnRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVycyB3aWxsIGJlIGZvdW5kLiBTZWUgX2ltYWdlUGF0aF8gZm9yIGRldGFpbHMuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdDogJ3BuZycuXG4gKiAgICAgJ2F2ZXJhZ2VDZW50ZXInOiAoYm9vbGVhbikgV2hldGhlciB0aGUgY2VudGVyIG9mIGVhY2ggY2x1c3RlciBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgIHRoZSBhdmVyYWdlIG9mIGFsbCBtYXJrZXJzIGluIHRoZSBjbHVzdGVyLlxuICogICAgICdtaW5pbXVtQ2x1c3RlclNpemUnOiAobnVtYmVyKSBUaGUgbWluaW11bSBudW1iZXIgb2YgbWFya2VycyB0byBiZSBpbiBhXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIgYmVmb3JlIHRoZSBtYXJrZXJzIGFyZSBoaWRkZW4gYW5kIGEgY291bnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgc2hvd24uXG4gKiAgICAgJ3N0eWxlcyc6IChvYmplY3QpIEFuIG9iamVjdCB0aGF0IGhhcyBzdHlsZSBwcm9wZXJ0aWVzOlxuICogICAgICAgJ3VybCc6IChzdHJpbmcpIFRoZSBpbWFnZSB1cmwuXG4gKiAgICAgICAnaGVpZ2h0JzogKG51bWJlcikgVGhlIGltYWdlIGhlaWdodC5cbiAqICAgICAgICd3aWR0aCc6IChudW1iZXIpIFRoZSBpbWFnZSB3aWR0aC5cbiAqICAgICAgICdhbmNob3InOiAoQXJyYXkpIFRoZSBhbmNob3IgcG9zaXRpb24gb2YgdGhlIGxhYmVsIHRleHQuXG4gKiAgICAgICAndGV4dENvbG9yJzogKHN0cmluZykgVGhlIHRleHQgY29sb3IuXG4gKiAgICAgICAndGV4dFNpemUnOiAobnVtYmVyKSBUaGUgdGV4dCBzaXplLlxuICogICAgICAgJ2JhY2tncm91bmRQb3NpdGlvbic6IChzdHJpbmcpIFRoZSBwb3NpdGlvbiBvZiB0aGUgYmFja2dvdW5kIHgsIHkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3XG4gKi9cbmZ1bmN0aW9uIE1hcmtlckNsdXN0ZXJlcihtYXAsIG9wdF9tYXJrZXJzLCBvcHRfb3B0aW9ucykge1xuICAvLyBNYXJrZXJDbHVzdGVyZXIgaW1wbGVtZW50cyBnb29nbGUubWFwcy5PdmVybGF5VmlldyBpbnRlcmZhY2UuIFdlIHVzZSB0aGVcbiAgLy8gZXh0ZW5kIGZ1bmN0aW9uIHRvIGV4dGVuZCBNYXJrZXJDbHVzdGVyZXIgd2l0aCBnb29nbGUubWFwcy5PdmVybGF5Vmlld1xuICAvLyBiZWNhdXNlIGl0IG1pZ2h0IG5vdCBhbHdheXMgYmUgYXZhaWxhYmxlIHdoZW4gdGhlIGNvZGUgaXMgZGVmaW5lZCBzbyB3ZVxuICAvLyBsb29rIGZvciBpdCBhdCB0aGUgbGFzdCBwb3NzaWJsZSBtb21lbnQuIElmIGl0IGRvZXNuJ3QgZXhpc3Qgbm93IHRoZW5cbiAgLy8gdGhlcmUgaXMgbm8gcG9pbnQgZ29pbmcgYWhlYWQgOilcbiAgdGhpcy5leHRlbmQoTWFya2VyQ2x1c3RlcmVyLCBnb29nbGUubWFwcy5PdmVybGF5Vmlldyk7XG4gIHRoaXMubWFwXyA9IG1hcDtcblxuICAvKipcbiAgICogQHR5cGUge0FycmF5Ljxnb29nbGUubWFwcy5NYXJrZXI+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tYXJrZXJzXyA9IFtdO1xuXG4gIC8qKlxuICAgKiAgQHR5cGUge0FycmF5LjxDbHVzdGVyPn1cbiAgICovXG4gIHRoaXMuY2x1c3RlcnNfID0gW107XG5cbiAgdGhpcy5zaXplcyA9IFs1MywgNTYsIDY2LCA3OCwgOTBdO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zdHlsZXNfID0gW107XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yZWFkeV8gPSBmYWxzZTtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5ncmlkU2l6ZV8gPSBvcHRpb25zWydncmlkU2l6ZSddIHx8IDYwO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5taW5DbHVzdGVyU2l6ZV8gPSBvcHRpb25zWydtaW5pbXVtQ2x1c3RlclNpemUnXSB8fCAyO1xuXG5cbiAgLyoqXG4gICAqIEB0eXBlIHs/bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5tYXhab29tXyA9IG9wdGlvbnNbJ21heFpvb20nXSB8fCBudWxsO1xuXG4gIHRoaXMuc3R5bGVzXyA9IG9wdGlvbnNbJ3N0eWxlcyddIHx8IFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pbWFnZVBhdGhfID0gb3B0aW9uc1snaW1hZ2VQYXRoJ10gfHxcbiAgICAgIHRoaXMuTUFSS0VSX0NMVVNURVJfSU1BR0VfUEFUSF87XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmltYWdlRXh0ZW5zaW9uXyA9IG9wdGlvbnNbJ2ltYWdlRXh0ZW5zaW9uJ10gfHxcbiAgICAgIHRoaXMuTUFSS0VSX0NMVVNURVJfSU1BR0VfRVhURU5TSU9OXztcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnpvb21PbkNsaWNrXyA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnNbJ3pvb21PbkNsaWNrJ10gIT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy56b29tT25DbGlja18gPSBvcHRpb25zWyd6b29tT25DbGljayddO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5hdmVyYWdlQ2VudGVyXyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zWydhdmVyYWdlQ2VudGVyJ10gIT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5hdmVyYWdlQ2VudGVyXyA9IG9wdGlvbnNbJ2F2ZXJhZ2VDZW50ZXInXTtcbiAgfVxuXG4gIHRoaXMuc2V0dXBTdHlsZXNfKCk7XG5cbiAgdGhpcy5zZXRNYXAobWFwKTtcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucHJldlpvb21fID0gdGhpcy5tYXBfLmdldFpvb20oKTtcblxuICAvLyBBZGQgdGhlIG1hcCBldmVudCBsaXN0ZW5lcnNcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLm1hcF8sICd6b29tX2NoYW5nZWQnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBEZXRlcm1pbmVzIG1hcCB0eXBlIGFuZCBwcmV2ZW50IGlsbGVnYWwgem9vbSBsZXZlbHNcbiAgICB2YXIgem9vbSA9IHRoYXQubWFwXy5nZXRab29tKCk7XG4gICAgdmFyIG1pblpvb20gPSB0aGF0Lm1hcF8ubWluWm9vbSB8fCAwO1xuICAgIHZhciBtYXhab29tID0gTWF0aC5taW4odGhhdC5tYXBfLm1heFpvb20gfHwgMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQubWFwXy5tYXBUeXBlc1t0aGF0Lm1hcF8uZ2V0TWFwVHlwZUlkKCldLm1heFpvb20pO1xuICAgIHpvb20gPSBNYXRoLm1pbihNYXRoLm1heCh6b29tLG1pblpvb20pLG1heFpvb20pO1xuXG4gICAgaWYgKHRoYXQucHJldlpvb21fICE9IHpvb20pIHtcbiAgICAgIHRoYXQucHJldlpvb21fID0gem9vbTtcbiAgICAgIHRoYXQucmVzZXRWaWV3cG9ydCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5tYXBfLCAnaWRsZScsIGZ1bmN0aW9uKCkge1xuICAgIHRoYXQucmVkcmF3KCk7XG4gIH0pO1xuXG4gIC8vIEZpbmFsbHksIGFkZCB0aGUgbWFya2Vyc1xuICBpZiAob3B0X21hcmtlcnMgJiYgKG9wdF9tYXJrZXJzLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhvcHRfbWFya2VycykubGVuZ3RoKSkge1xuICAgIHRoaXMuYWRkTWFya2VycyhvcHRfbWFya2VycywgZmFsc2UpO1xuICB9XG59XG5cblxuLyoqXG4gKiBUaGUgbWFya2VyIGNsdXN0ZXIgaW1hZ2UgcGF0aC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5NQVJLRVJfQ0xVU1RFUl9JTUFHRV9QQVRIXyA9ICcuLi9pbWFnZXMvbSc7XG5cblxuLyoqXG4gKiBUaGUgbWFya2VyIGNsdXN0ZXIgaW1hZ2UgcGF0aC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5NQVJLRVJfQ0xVU1RFUl9JTUFHRV9FWFRFTlNJT05fID0gJ3BuZyc7XG5cblxuLyoqXG4gKiBFeHRlbmRzIGEgb2JqZWN0cyBwcm90b3R5cGUgYnkgYW5vdGhlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoyIFRoZSBvYmplY3QgdG8gZXh0ZW5kIHdpdGguXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgZXh0ZW5kZWQgb2JqZWN0LlxuICogQGlnbm9yZVxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIChmdW5jdGlvbihvYmplY3QpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QucHJvdG90eXBlKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBvYmplY3QucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLmFwcGx5KG9iajEsIFtvYmoyXSk7XG59O1xuXG5cbi8qKlxuICogSW1wbGVtZW50YWlvbiBvZiB0aGUgaW50ZXJmYWNlIG1ldGhvZC5cbiAqIEBpZ25vcmVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNldFJlYWR5Xyh0cnVlKTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50YWlvbiBvZiB0aGUgaW50ZXJmYWNlIG1ldGhvZC5cbiAqIEBpZ25vcmVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBzdHlsZXMgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuc2V0dXBTdHlsZXNfID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN0eWxlc18ubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIHNpemU7IHNpemUgPSB0aGlzLnNpemVzW2ldOyBpKyspIHtcbiAgICB0aGlzLnN0eWxlc18ucHVzaCh7XG4gICAgICB1cmw6IHRoaXMuaW1hZ2VQYXRoXyArIChpICsgMSkgKyAnLicgKyB0aGlzLmltYWdlRXh0ZW5zaW9uXyxcbiAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgIHdpZHRoOiBzaXplXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogIEZpdCB0aGUgbWFwIHRvIHRoZSBib3VuZHMgb2YgdGhlIG1hcmtlcnMgaW4gdGhlIGNsdXN0ZXJlci5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5maXRNYXBUb01hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgdmFyIGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoKTtcbiAgZm9yICh2YXIgaSA9IDAsIG1hcmtlcjsgbWFya2VyID0gbWFya2Vyc1tpXTsgaSsrKSB7XG4gICAgYm91bmRzLmV4dGVuZChtYXJrZXIuZ2V0UG9zaXRpb24oKSk7XG4gIH1cblxuICB0aGlzLm1hcF8uZml0Qm91bmRzKGJvdW5kcyk7XG59O1xuXG5cbi8qKlxuICogIFNldHMgdGhlIHN0eWxlcy5cbiAqXG4gKiAgQHBhcmFtIHtPYmplY3R9IHN0eWxlcyBUaGUgc3R5bGUgdG8gc2V0LlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnNldFN0eWxlcyA9IGZ1bmN0aW9uKHN0eWxlcykge1xuICB0aGlzLnN0eWxlc18gPSBzdHlsZXM7XG59O1xuXG5cbi8qKlxuICogIEdldHMgdGhlIHN0eWxlcy5cbiAqXG4gKiAgQHJldHVybiB7T2JqZWN0fSBUaGUgc3R5bGVzIG9iamVjdC5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3R5bGVzXztcbn07XG5cblxuLyoqXG4gKiBXaGV0aGVyIHpvb20gb24gY2xpY2sgaXMgc2V0LlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgem9vbU9uQ2xpY2tfIGlzIHNldC5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5pc1pvb21PbkNsaWNrID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnpvb21PbkNsaWNrXztcbn07XG5cbi8qKlxuICogV2hldGhlciBhdmVyYWdlIGNlbnRlciBpcyBzZXQuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhdmVyYWdlQ2VudGVyXyBpcyBzZXQuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuaXNBdmVyYWdlQ2VudGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmF2ZXJhZ2VDZW50ZXJfO1xufTtcblxuXG4vKipcbiAqICBSZXR1cm5zIHRoZSBhcnJheSBvZiBtYXJrZXJzIGluIHRoZSBjbHVzdGVyZXIuXG4gKlxuICogIEByZXR1cm4ge0FycmF5Ljxnb29nbGUubWFwcy5NYXJrZXI+fSBUaGUgbWFya2Vycy5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1hcmtlcnNfO1xufTtcblxuXG4vKipcbiAqICBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbWFya2VycyBpbiB0aGUgY2x1c3RlcmVyXG4gKlxuICogIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBtYXJrZXJzLlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldFRvdGFsTWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5tYXJrZXJzXy5sZW5ndGg7XG59O1xuXG5cbi8qKlxuICogIFNldHMgdGhlIG1heCB6b29tIGZvciB0aGUgY2x1c3RlcmVyLlxuICpcbiAqICBAcGFyYW0ge251bWJlcn0gbWF4Wm9vbSBUaGUgbWF4IHpvb20gbGV2ZWwuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWF4Wm9vbSA9IGZ1bmN0aW9uKG1heFpvb20pIHtcbiAgdGhpcy5tYXhab29tXyA9IG1heFpvb207XG59O1xuXG5cbi8qKlxuICogIEdldHMgdGhlIG1heCB6b29tIGZvciB0aGUgY2x1c3RlcmVyLlxuICpcbiAqICBAcmV0dXJuIHtudW1iZXJ9IFRoZSBtYXggem9vbSBsZXZlbC5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNYXhab29tID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1heFpvb21fO1xufTtcblxuXG4vKipcbiAqICBUaGUgZnVuY3Rpb24gZm9yIGNhbGN1bGF0aW5nIHRoZSBjbHVzdGVyIGljb24gaW1hZ2UuXG4gKlxuICogIEBwYXJhbSB7QXJyYXkuPGdvb2dsZS5tYXBzLk1hcmtlcj59IG1hcmtlcnMgVGhlIG1hcmtlcnMgaW4gdGhlIGNsdXN0ZXJlci5cbiAqICBAcGFyYW0ge251bWJlcn0gbnVtU3R5bGVzIFRoZSBudW1iZXIgb2Ygc3R5bGVzIGF2YWlsYWJsZS5cbiAqICBAcmV0dXJuIHtPYmplY3R9IEEgb2JqZWN0IHByb3BlcnRpZXM6ICd0ZXh0JyAoc3RyaW5nKSBhbmQgJ2luZGV4JyAobnVtYmVyKS5cbiAqICBAcHJpdmF0ZVxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmNhbGN1bGF0b3JfID0gZnVuY3Rpb24obWFya2VycywgbnVtU3R5bGVzKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBjb3VudCA9IG1hcmtlcnMubGVuZ3RoO1xuICB2YXIgZHYgPSBjb3VudDtcbiAgd2hpbGUgKGR2ICE9PSAwKSB7XG4gICAgZHYgPSBwYXJzZUludChkdiAvIDEwLCAxMCk7XG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIGluZGV4ID0gTWF0aC5taW4oaW5kZXgsIG51bVN0eWxlcyk7XG4gIHJldHVybiB7XG4gICAgdGV4dDogY291bnQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59O1xuXG5cbi8qKlxuICogU2V0IHRoZSBjYWxjdWxhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXksIG51bWJlcil9IGNhbGN1bGF0b3IgVGhlIGZ1bmN0aW9uIHRvIHNldCBhcyB0aGVcbiAqICAgICBjYWxjdWxhdG9yLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIG9iamVjdCBwcm9wZXJ0aWVzOlxuICogICAgICd0ZXh0JyAoc3RyaW5nKSBhbmQgJ2luZGV4JyAobnVtYmVyKS5cbiAqXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuc2V0Q2FsY3VsYXRvciA9IGZ1bmN0aW9uKGNhbGN1bGF0b3IpIHtcbiAgdGhpcy5jYWxjdWxhdG9yXyA9IGNhbGN1bGF0b3I7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBjYWxjdWxhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKEFycmF5LCBudW1iZXIpfSB0aGUgY2FsY3VsYXRvciBmdW5jdGlvbi5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRDYWxjdWxhdG9yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNhbGN1bGF0b3JfO1xufTtcblxuXG4vKipcbiAqIEFkZCBhbiBhcnJheSBvZiBtYXJrZXJzIHRvIHRoZSBjbHVzdGVyZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheS48Z29vZ2xlLm1hcHMuTWFya2VyPn0gbWFya2VycyBUaGUgbWFya2VycyB0byBhZGQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9kcmF3IFdoZXRoZXIgdG8gcmVkcmF3IHRoZSBjbHVzdGVycy5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRNYXJrZXJzID0gZnVuY3Rpb24obWFya2Vycywgb3B0X25vZHJhdykge1xuICBpZiAobWFya2Vycy5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbWFya2VyOyBtYXJrZXIgPSBtYXJrZXJzW2ldOyBpKyspIHtcbiAgICAgIHRoaXMucHVzaE1hcmtlclRvXyhtYXJrZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhtYXJrZXJzKS5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBtYXJrZXIgaW4gbWFya2Vycykge1xuICAgICAgdGhpcy5wdXNoTWFya2VyVG9fKG1hcmtlcnNbbWFya2VyXSk7XG4gICAgfVxuICB9XG4gIGlmICghb3B0X25vZHJhdykge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBQdXNoZXMgYSBtYXJrZXIgdG8gdGhlIGNsdXN0ZXJlci5cbiAqXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcmtlcn0gbWFya2VyIFRoZSBtYXJrZXIgdG8gYWRkLlxuICogQHByaXZhdGVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5wdXNoTWFya2VyVG9fID0gZnVuY3Rpb24obWFya2VyKSB7XG4gIG1hcmtlci5pc0FkZGVkID0gZmFsc2U7XG4gIGlmIChtYXJrZXJbJ2RyYWdnYWJsZSddKSB7XG4gICAgLy8gSWYgdGhlIG1hcmtlciBpcyBkcmFnZ2FibGUgYWRkIGEgbGlzdGVuZXIgc28gd2UgdXBkYXRlIHRoZSBjbHVzdGVycyBvblxuICAgIC8vIHRoZSBkcmFnIGVuZC5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZHJhZ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcbiAgICAgIHRoYXQucmVwYWludCgpO1xuICAgIH0pO1xuICB9XG4gIHRoaXMubWFya2Vyc18ucHVzaChtYXJrZXIpO1xufTtcblxuXG4vKipcbiAqIEFkZHMgYSBtYXJrZXIgdG8gdGhlIGNsdXN0ZXJlciBhbmQgcmVkcmF3cyBpZiBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5NYXJrZXJ9IG1hcmtlciBUaGUgbWFya2VyIHRvIGFkZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub2RyYXcgV2hldGhlciB0byByZWRyYXcgdGhlIGNsdXN0ZXJzLlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlciwgb3B0X25vZHJhdykge1xuICB0aGlzLnB1c2hNYXJrZXJUb18obWFya2VyKTtcbiAgaWYgKCFvcHRfbm9kcmF3KSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBtYXJrZXIgYW5kIHJldHVybnMgdHJ1ZSBpZiByZW1vdmVkLCBmYWxzZSBpZiBub3RcbiAqXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcmtlcn0gbWFya2VyIFRoZSBtYXJrZXIgdG8gcmVtb3ZlXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBtYXJrZXIgd2FzIHJlbW92ZWQgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnJlbW92ZU1hcmtlcl8gPSBmdW5jdGlvbihtYXJrZXIpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGlmICh0aGlzLm1hcmtlcnNfLmluZGV4T2YpIHtcbiAgICBpbmRleCA9IHRoaXMubWFya2Vyc18uaW5kZXhPZihtYXJrZXIpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBtOyBtID0gdGhpcy5tYXJrZXJzX1tpXTsgaSsrKSB7XG4gICAgICBpZiAobSA9PSBtYXJrZXIpIHtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAvLyBNYXJrZXIgaXMgbm90IGluIG91ciBsaXN0IG9mIG1hcmtlcnMuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWFya2VyLnNldE1hcChudWxsKTtcblxuICB0aGlzLm1hcmtlcnNfLnNwbGljZShpbmRleCwgMSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlIGEgbWFya2VyIGZyb20gdGhlIGNsdXN0ZXIuXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5NYXJrZXJ9IG1hcmtlciBUaGUgbWFya2VyIHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub2RyYXcgT3B0aW9uYWwgYm9vbGVhbiB0byBmb3JjZSBubyByZWRyYXcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBtYXJrZXIgd2FzIHJlbW92ZWQuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24obWFya2VyLCBvcHRfbm9kcmF3KSB7XG4gIHZhciByZW1vdmVkID0gdGhpcy5yZW1vdmVNYXJrZXJfKG1hcmtlcik7XG5cbiAgaWYgKCFvcHRfbm9kcmF3ICYmIHJlbW92ZWQpIHtcbiAgICB0aGlzLnJlc2V0Vmlld3BvcnQoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGZyb20gdGhlIGNsdXN0ZXIuXG4gKlxuICogQHBhcmFtIHtBcnJheS48Z29vZ2xlLm1hcHMuTWFya2VyPn0gbWFya2VycyBUaGUgbWFya2VycyB0byByZW1vdmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9kcmF3IE9wdGlvbmFsIGJvb2xlYW4gdG8gZm9yY2Ugbm8gcmVkcmF3LlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnJlbW92ZU1hcmtlcnMgPSBmdW5jdGlvbihtYXJrZXJzLCBvcHRfbm9kcmF3KSB7XG4gIC8vIGNyZWF0ZSBhIGxvY2FsIGNvcHkgb2YgbWFya2VycyBpZiByZXF1aXJlZFxuICAvLyAocmVtb3ZlTWFya2VyXyBtb2RpZmllcyB0aGUgZ2V0TWFya2VycygpIGFycmF5IGluIHBsYWNlKVxuICB2YXIgbWFya2Vyc0NvcHkgPSBtYXJrZXJzID09PSB0aGlzLmdldE1hcmtlcnMoKSA/IG1hcmtlcnMuc2xpY2UoKSA6IG1hcmtlcnM7XG4gIHZhciByZW1vdmVkID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG1hcmtlcjsgbWFya2VyID0gbWFya2Vyc0NvcHlbaV07IGkrKykge1xuICAgIHZhciByID0gdGhpcy5yZW1vdmVNYXJrZXJfKG1hcmtlcik7XG4gICAgcmVtb3ZlZCA9IHJlbW92ZWQgfHwgcjtcbiAgfVxuXG4gIGlmICghb3B0X25vZHJhdyAmJiByZW1vdmVkKSB7XG4gICAgdGhpcy5yZXNldFZpZXdwb3J0KCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGNsdXN0ZXJlcidzIHJlYWR5IHN0YXRlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVhZHkgVGhlIHN0YXRlLlxuICogQHByaXZhdGVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRSZWFkeV8gPSBmdW5jdGlvbihyZWFkeSkge1xuICBpZiAoIXRoaXMucmVhZHlfKSB7XG4gICAgdGhpcy5yZWFkeV8gPSByZWFkeTtcbiAgICB0aGlzLmNyZWF0ZUNsdXN0ZXJzXygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNsdXN0ZXJzIGluIHRoZSBjbHVzdGVyZXIuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNsdXN0ZXJzLlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldFRvdGFsQ2x1c3RlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcnNfLmxlbmd0aDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnb29nbGUgbWFwIHRoYXQgdGhlIGNsdXN0ZXJlciBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogQHJldHVybiB7Z29vZ2xlLm1hcHMuTWFwfSBUaGUgbWFwLlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5tYXBfO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGdvb2dsZSBtYXAgdGhhdCB0aGUgY2x1c3RlcmVyIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcH0gbWFwIFRoZSBtYXAuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24obWFwKSB7XG4gIHRoaXMubWFwXyA9IG1hcDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBncmlkLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdyaWQgc2l6ZS5cbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ncmlkU2l6ZV87XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgZ3JpZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGUgZ3JpZCBzaXplLlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnNldEdyaWRTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICB0aGlzLmdyaWRTaXplXyA9IHNpemU7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluIGNsdXN0ZXIgc2l6ZS5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBncmlkIHNpemUuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWluQ2x1c3RlclNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWluQ2x1c3RlclNpemVfO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtaW4gY2x1c3RlciBzaXplLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIFRoZSBncmlkIHNpemUuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWluQ2x1c3RlclNpemUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHRoaXMubWluQ2x1c3RlclNpemVfID0gc2l6ZTtcbn07XG5cblxuLyoqXG4gKiBFeHRlbmRzIGEgYm91bmRzIG9iamVjdCBieSB0aGUgZ3JpZCBzaXplLlxuICpcbiAqIEBwYXJhbSB7Z29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzfSBib3VuZHMgVGhlIGJvdW5kcyB0byBleHRlbmQuXG4gKiBAcmV0dXJuIHtnb29nbGUubWFwcy5MYXRMbmdCb3VuZHN9IFRoZSBleHRlbmRlZCBib3VuZHMuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuZ2V0RXh0ZW5kZWRCb3VuZHMgPSBmdW5jdGlvbihib3VuZHMpIHtcbiAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcblxuICAvLyBUdXJuIHRoZSBib3VuZHMgaW50byBsYXRsbmcuXG4gIHZhciB0ciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLmdldE5vcnRoRWFzdCgpLmxhdCgpLFxuICAgICAgYm91bmRzLmdldE5vcnRoRWFzdCgpLmxuZygpKTtcbiAgdmFyIGJsID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuZ2V0U291dGhXZXN0KCkubGF0KCksXG4gICAgICBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKCkpO1xuXG4gIC8vIENvbnZlcnQgdGhlIHBvaW50cyB0byBwaXhlbHMgYW5kIHRoZSBleHRlbmQgb3V0IGJ5IHRoZSBncmlkIHNpemUuXG4gIHZhciB0clBpeCA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwodHIpO1xuICB0clBpeC54ICs9IHRoaXMuZ3JpZFNpemVfO1xuICB0clBpeC55IC09IHRoaXMuZ3JpZFNpemVfO1xuXG4gIHZhciBibFBpeCA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYmwpO1xuICBibFBpeC54IC09IHRoaXMuZ3JpZFNpemVfO1xuICBibFBpeC55ICs9IHRoaXMuZ3JpZFNpemVfO1xuXG4gIC8vIENvbnZlcnQgdGhlIHBpeGVsIHBvaW50cyBiYWNrIHRvIExhdExuZ1xuICB2YXIgbmUgPSBwcm9qZWN0aW9uLmZyb21EaXZQaXhlbFRvTGF0TG5nKHRyUGl4KTtcbiAgdmFyIHN3ID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhibFBpeCk7XG5cbiAgLy8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgbmV3IGJvdW5kcy5cbiAgYm91bmRzLmV4dGVuZChuZSk7XG4gIGJvdW5kcy5leHRlbmQoc3cpO1xuXG4gIHJldHVybiBib3VuZHM7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5zIGlmIGEgbWFya2VyIGlzIGNvbnRhaW5lZCBpbiBhIGJvdW5kcy5cbiAqXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcmtlcn0gbWFya2VyIFRoZSBtYXJrZXIgdG8gY2hlY2suXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLkxhdExuZ0JvdW5kc30gYm91bmRzIFRoZSBib3VuZHMgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1hcmtlciBpcyBpbiB0aGUgYm91bmRzLlxuICogQHByaXZhdGVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5pc01hcmtlckluQm91bmRzXyA9IGZ1bmN0aW9uKG1hcmtlciwgYm91bmRzKSB7XG4gIHJldHVybiBib3VuZHMuY29udGFpbnMobWFya2VyLmdldFBvc2l0aW9uKCkpO1xufTtcblxuXG4vKipcbiAqIENsZWFycyBhbGwgY2x1c3RlcnMgYW5kIG1hcmtlcnMgZnJvbSB0aGUgY2x1c3RlcmVyLlxuICovXG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmNsZWFyTWFya2VycyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlc2V0Vmlld3BvcnQodHJ1ZSk7XG5cbiAgLy8gU2V0IHRoZSBtYXJrZXJzIGEgZW1wdHkgYXJyYXkuXG4gIHRoaXMubWFya2Vyc18gPSBbXTtcbn07XG5cblxuLyoqXG4gKiBDbGVhcnMgYWxsIGV4aXN0aW5nIGNsdXN0ZXJzIGFuZCByZWNyZWF0ZXMgdGhlbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2hpZGUgVG8gYWxzbyBoaWRlIHRoZSBtYXJrZXIuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUucmVzZXRWaWV3cG9ydCA9IGZ1bmN0aW9uKG9wdF9oaWRlKSB7XG4gIC8vIFJlbW92ZSBhbGwgdGhlIGNsdXN0ZXJzXG4gIGZvciAodmFyIGkgPSAwLCBjbHVzdGVyOyBjbHVzdGVyID0gdGhpcy5jbHVzdGVyc19baV07IGkrKykge1xuICAgIGNsdXN0ZXIucmVtb3ZlKCk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgbWFya2VycyB0byBub3QgYmUgYWRkZWQgYW5kIHRvIGJlIGludmlzaWJsZS5cbiAgZm9yICh2YXIgaSA9IDAsIG1hcmtlcjsgbWFya2VyID0gdGhpcy5tYXJrZXJzX1tpXTsgaSsrKSB7XG4gICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcbiAgICBpZiAob3B0X2hpZGUpIHtcbiAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5jbHVzdGVyc18gPSBbXTtcbn07XG5cbi8qKlxuICpcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5yZXBhaW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvbGRDbHVzdGVycyA9IHRoaXMuY2x1c3RlcnNfLnNsaWNlKCk7XG4gIHRoaXMuY2x1c3RlcnNfLmxlbmd0aCA9IDA7XG4gIHRoaXMucmVzZXRWaWV3cG9ydCgpO1xuICB0aGlzLnJlZHJhdygpO1xuXG4gIC8vIFJlbW92ZSB0aGUgb2xkIGNsdXN0ZXJzLlxuICAvLyBEbyBpdCBpbiBhIHRpbWVvdXQgc28gdGhlIG90aGVyIGNsdXN0ZXJzIGhhdmUgYmVlbiBkcmF3biBmaXJzdC5cbiAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGNsdXN0ZXI7IGNsdXN0ZXIgPSBvbGRDbHVzdGVyc1tpXTsgaSsrKSB7XG4gICAgICBjbHVzdGVyLnJlbW92ZSgpO1xuICAgIH1cbiAgfSwgMCk7XG59O1xuXG5cbi8qKlxuICogUmVkcmF3cyB0aGUgY2x1c3RlcnMuXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlQ2x1c3RlcnNfKCk7XG59O1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gbGF0bG5nIGxvY2F0aW9ucyBpbiBrbS5cbiAqIEBzZWUgaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbiAqXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLkxhdExuZ30gcDEgVGhlIGZpcnN0IGxhdCBsbmcgcG9pbnQuXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLkxhdExuZ30gcDIgVGhlIHNlY29uZCBsYXQgbG5nIHBvaW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIHBvaW50cyBpbiBrbS5cbiAqIEBwcml2YXRlXG4qL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5kaXN0YW5jZUJldHdlZW5Qb2ludHNfID0gZnVuY3Rpb24ocDEsIHAyKSB7XG4gIGlmICghcDEgfHwgIXAyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgUiA9IDYzNzE7IC8vIFJhZGl1cyBvZiB0aGUgRWFydGggaW4ga21cbiAgdmFyIGRMYXQgPSAocDIubGF0KCkgLSBwMS5sYXQoKSkgKiBNYXRoLlBJIC8gMTgwO1xuICB2YXIgZExvbiA9IChwMi5sbmcoKSAtIHAxLmxuZygpKSAqIE1hdGguUEkgLyAxODA7XG4gIHZhciBhID0gTWF0aC5zaW4oZExhdCAvIDIpICogTWF0aC5zaW4oZExhdCAvIDIpICtcbiAgICBNYXRoLmNvcyhwMS5sYXQoKSAqIE1hdGguUEkgLyAxODApICogTWF0aC5jb3MocDIubGF0KCkgKiBNYXRoLlBJIC8gMTgwKSAqXG4gICAgTWF0aC5zaW4oZExvbiAvIDIpICogTWF0aC5zaW4oZExvbiAvIDIpO1xuICB2YXIgYyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XG4gIHZhciBkID0gUiAqIGM7XG4gIHJldHVybiBkO1xufTtcblxuXG4vKipcbiAqIEFkZCBhIG1hcmtlciB0byBhIGNsdXN0ZXIsIG9yIGNyZWF0ZXMgYSBuZXcgY2x1c3Rlci5cbiAqXG4gKiBAcGFyYW0ge2dvb2dsZS5tYXBzLk1hcmtlcn0gbWFya2VyIFRoZSBtYXJrZXIgdG8gYWRkLlxuICogQHByaXZhdGVcbiAqL1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRUb0Nsb3Nlc3RDbHVzdGVyXyA9IGZ1bmN0aW9uKG1hcmtlcikge1xuICB2YXIgZGlzdGFuY2UgPSA0MDAwMDsgLy8gU29tZSBsYXJnZSBudW1iZXJcbiAgdmFyIGNsdXN0ZXJUb0FkZFRvID0gbnVsbDtcbiAgdmFyIHBvcyA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICBmb3IgKHZhciBpID0gMCwgY2x1c3RlcjsgY2x1c3RlciA9IHRoaXMuY2x1c3RlcnNfW2ldOyBpKyspIHtcbiAgICB2YXIgY2VudGVyID0gY2x1c3Rlci5nZXRDZW50ZXIoKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzXyhjZW50ZXIsIG1hcmtlci5nZXRQb3NpdGlvbigpKTtcbiAgICAgIGlmIChkIDwgZGlzdGFuY2UpIHtcbiAgICAgICAgZGlzdGFuY2UgPSBkO1xuICAgICAgICBjbHVzdGVyVG9BZGRUbyA9IGNsdXN0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsdXN0ZXJUb0FkZFRvICYmIGNsdXN0ZXJUb0FkZFRvLmlzTWFya2VySW5DbHVzdGVyQm91bmRzKG1hcmtlcikpIHtcbiAgICBjbHVzdGVyVG9BZGRUby5hZGRNYXJrZXIobWFya2VyKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2x1c3RlciA9IG5ldyBDbHVzdGVyKHRoaXMpO1xuICAgIGNsdXN0ZXIuYWRkTWFya2VyKG1hcmtlcik7XG4gICAgdGhpcy5jbHVzdGVyc18ucHVzaChjbHVzdGVyKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGNsdXN0ZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuY3JlYXRlQ2x1c3RlcnNfID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5yZWFkeV8pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZXQgb3VyIGN1cnJlbnQgbWFwIHZpZXcgYm91bmRzLlxuICAvLyBDcmVhdGUgYSBuZXcgYm91bmRzIG9iamVjdCBzbyB3ZSBkb24ndCBhZmZlY3QgdGhlIG1hcC5cbiAgdmFyIG1hcEJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5tYXBfLmdldEJvdW5kcygpLmdldFNvdXRoV2VzdCgpLFxuICAgICAgdGhpcy5tYXBfLmdldEJvdW5kcygpLmdldE5vcnRoRWFzdCgpKTtcbiAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0RXh0ZW5kZWRCb3VuZHMobWFwQm91bmRzKTtcblxuICBmb3IgKHZhciBpID0gMCwgbWFya2VyOyBtYXJrZXIgPSB0aGlzLm1hcmtlcnNfW2ldOyBpKyspIHtcbiAgICBpZiAoIW1hcmtlci5pc0FkZGVkICYmIHRoaXMuaXNNYXJrZXJJbkJvdW5kc18obWFya2VyLCBib3VuZHMpKSB7XG4gICAgICB0aGlzLmFkZFRvQ2xvc2VzdENsdXN0ZXJfKG1hcmtlcik7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogQSBjbHVzdGVyIHRoYXQgY29udGFpbnMgbWFya2Vycy5cbiAqXG4gKiBAcGFyYW0ge01hcmtlckNsdXN0ZXJlcn0gbWFya2VyQ2x1c3RlcmVyIFRoZSBtYXJrZXJjbHVzdGVyZXIgdGhhdCB0aGlzXG4gKiAgICAgY2x1c3RlciBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gQ2x1c3RlcihtYXJrZXJDbHVzdGVyZXIpIHtcbiAgdGhpcy5tYXJrZXJDbHVzdGVyZXJfID0gbWFya2VyQ2x1c3RlcmVyO1xuICB0aGlzLm1hcF8gPSBtYXJrZXJDbHVzdGVyZXIuZ2V0TWFwKCk7XG4gIHRoaXMuZ3JpZFNpemVfID0gbWFya2VyQ2x1c3RlcmVyLmdldEdyaWRTaXplKCk7XG4gIHRoaXMubWluQ2x1c3RlclNpemVfID0gbWFya2VyQ2x1c3RlcmVyLmdldE1pbkNsdXN0ZXJTaXplKCk7XG4gIHRoaXMuYXZlcmFnZUNlbnRlcl8gPSBtYXJrZXJDbHVzdGVyZXIuaXNBdmVyYWdlQ2VudGVyKCk7XG4gIHRoaXMuY2VudGVyXyA9IG51bGw7XG4gIHRoaXMubWFya2Vyc18gPSBbXTtcbiAgdGhpcy5ib3VuZHNfID0gbnVsbDtcbiAgdGhpcy5jbHVzdGVySWNvbl8gPSBuZXcgQ2x1c3Rlckljb24odGhpcywgbWFya2VyQ2x1c3RlcmVyLmdldFN0eWxlcygpLFxuICAgICAgbWFya2VyQ2x1c3RlcmVyLmdldEdyaWRTaXplKCkpO1xufVxuXG4vKipcbiAqIERldGVybWlucyBpZiBhIG1hcmtlciBpcyBhbHJlYWR5IGFkZGVkIHRvIHRoZSBjbHVzdGVyLlxuICpcbiAqIEBwYXJhbSB7Z29vZ2xlLm1hcHMuTWFya2VyfSBtYXJrZXIgVGhlIG1hcmtlciB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1hcmtlciBpcyBhbHJlYWR5IGFkZGVkLlxuICovXG5DbHVzdGVyLnByb3RvdHlwZS5pc01hcmtlckFscmVhZHlBZGRlZCA9IGZ1bmN0aW9uKG1hcmtlcikge1xuICBpZiAodGhpcy5tYXJrZXJzXy5pbmRleE9mKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2Vyc18uaW5kZXhPZihtYXJrZXIpICE9IC0xO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBtOyBtID0gdGhpcy5tYXJrZXJzX1tpXTsgaSsrKSB7XG4gICAgICBpZiAobSA9PSBtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqXG4gKiBBZGQgYSBtYXJrZXIgdGhlIGNsdXN0ZXIuXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5NYXJrZXJ9IG1hcmtlciBUaGUgbWFya2VyIHRvIGFkZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1hcmtlciB3YXMgYWRkZWQuXG4gKi9cbkNsdXN0ZXIucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uKG1hcmtlcikge1xuICBpZiAodGhpcy5pc01hcmtlckFscmVhZHlBZGRlZChtYXJrZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCF0aGlzLmNlbnRlcl8pIHtcbiAgICB0aGlzLmNlbnRlcl8gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kc18oKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5hdmVyYWdlQ2VudGVyXykge1xuICAgICAgdmFyIGwgPSB0aGlzLm1hcmtlcnNfLmxlbmd0aCArIDE7XG4gICAgICB2YXIgbGF0ID0gKHRoaXMuY2VudGVyXy5sYXQoKSAqIChsLTEpICsgbWFya2VyLmdldFBvc2l0aW9uKCkubGF0KCkpIC8gbDtcbiAgICAgIHZhciBsbmcgPSAodGhpcy5jZW50ZXJfLmxuZygpICogKGwtMSkgKyBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sbmcoKSkgLyBsO1xuICAgICAgdGhpcy5jZW50ZXJfID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXQsIGxuZyk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kc18oKTtcbiAgICB9XG4gIH1cblxuICBtYXJrZXIuaXNBZGRlZCA9IHRydWU7XG4gIHRoaXMubWFya2Vyc18ucHVzaChtYXJrZXIpO1xuXG4gIHZhciBsZW4gPSB0aGlzLm1hcmtlcnNfLmxlbmd0aDtcbiAgaWYgKGxlbiA8IHRoaXMubWluQ2x1c3RlclNpemVfICYmIG1hcmtlci5nZXRNYXAoKSAhPSB0aGlzLm1hcF8pIHtcbiAgICAvLyBNaW4gY2x1c3RlciBzaXplIG5vdCByZWFjaGVkIHNvIHNob3cgdGhlIG1hcmtlci5cbiAgICBtYXJrZXIuc2V0TWFwKHRoaXMubWFwXyk7XG4gIH1cblxuICBpZiAobGVuID09IHRoaXMubWluQ2x1c3RlclNpemVfKSB7XG4gICAgLy8gSGlkZSB0aGUgbWFya2VycyB0aGF0IHdlcmUgc2hvd2luZy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLm1hcmtlcnNfW2ldLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cblxuICBpZiAobGVuID49IHRoaXMubWluQ2x1c3RlclNpemVfKSB7XG4gICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlSWNvbigpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXJrZXIgY2x1c3RlcmVyIHRoYXQgdGhlIGNsdXN0ZXIgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEByZXR1cm4ge01hcmtlckNsdXN0ZXJlcn0gVGhlIGFzc29jaWF0ZWQgbWFya2VyIGNsdXN0ZXJlci5cbiAqL1xuQ2x1c3Rlci5wcm90b3R5cGUuZ2V0TWFya2VyQ2x1c3RlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1hcmtlckNsdXN0ZXJlcl87XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRzIG9mIHRoZSBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm4ge2dvb2dsZS5tYXBzLkxhdExuZ0JvdW5kc30gdGhlIGNsdXN0ZXIgYm91bmRzLlxuICovXG5DbHVzdGVyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5jZW50ZXJfLCB0aGlzLmNlbnRlcl8pO1xuICB2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xuICBmb3IgKHZhciBpID0gMCwgbWFya2VyOyBtYXJrZXIgPSBtYXJrZXJzW2ldOyBpKyspIHtcbiAgICBib3VuZHMuZXh0ZW5kKG1hcmtlci5nZXRQb3NpdGlvbigpKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGNsdXN0ZXJcbiAqL1xuQ2x1c3Rlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY2x1c3Rlckljb25fLnJlbW92ZSgpO1xuICB0aGlzLm1hcmtlcnNfLmxlbmd0aCA9IDA7XG4gIGRlbGV0ZSB0aGlzLm1hcmtlcnNfO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBtYXJrZXJzIGluIHRoZSBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBtYXJrZXJzIGluIHRoZSBjbHVzdGVyLlxuICovXG5DbHVzdGVyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1hcmtlcnNfLmxlbmd0aDtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgbWFya2VycyBpbiB0aGUgY2x1c3Rlci5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheS48Z29vZ2xlLm1hcHMuTWFya2VyPn0gVGhlIG1hcmtlcnMgaW4gdGhlIGNsdXN0ZXIuXG4gKi9cbkNsdXN0ZXIucHJvdG90eXBlLmdldE1hcmtlcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWFya2Vyc187XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm4ge2dvb2dsZS5tYXBzLkxhdExuZ30gVGhlIGNsdXN0ZXIgY2VudGVyLlxuICovXG5DbHVzdGVyLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2VudGVyXztcbn07XG5cblxuLyoqXG4gKiBDYWxjdWxhdGVkIHRoZSBleHRlbmRlZCBib3VuZHMgb2YgdGhlIGNsdXN0ZXIgd2l0aCB0aGUgZ3JpZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5DbHVzdGVyLnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZHNfID0gZnVuY3Rpb24oKSB7XG4gIHZhciBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHRoaXMuY2VudGVyXywgdGhpcy5jZW50ZXJfKTtcbiAgdGhpcy5ib3VuZHNfID0gdGhpcy5tYXJrZXJDbHVzdGVyZXJfLmdldEV4dGVuZGVkQm91bmRzKGJvdW5kcyk7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIG1hcmtlciBsaWVzIGluIHRoZSBjbHVzdGVycyBib3VuZHMuXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5NYXJrZXJ9IG1hcmtlciBUaGUgbWFya2VyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWFya2VyIGxpZXMgaW4gdGhlIGJvdW5kcy5cbiAqL1xuQ2x1c3Rlci5wcm90b3R5cGUuaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMgPSBmdW5jdGlvbihtYXJrZXIpIHtcbiAgcmV0dXJuIHRoaXMuYm91bmRzXy5jb250YWlucyhtYXJrZXIuZ2V0UG9zaXRpb24oKSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWFwIHRoYXQgdGhlIGNsdXN0ZXIgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEByZXR1cm4ge2dvb2dsZS5tYXBzLk1hcH0gVGhlIG1hcC5cbiAqL1xuQ2x1c3Rlci5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1hcF87XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgY2x1c3RlciBpY29uXG4gKi9cbkNsdXN0ZXIucHJvdG90eXBlLnVwZGF0ZUljb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHpvb20gPSB0aGlzLm1hcF8uZ2V0Wm9vbSgpO1xuICB2YXIgbXogPSB0aGlzLm1hcmtlckNsdXN0ZXJlcl8uZ2V0TWF4Wm9vbSgpO1xuXG4gIGlmIChteiAmJiB6b29tID4gbXopIHtcbiAgICAvLyBUaGUgem9vbSBpcyBncmVhdGVyIHRoYW4gb3VyIG1heCB6b29tIHNvIHNob3cgYWxsIHRoZSBtYXJrZXJzIGluIGNsdXN0ZXIuXG4gICAgZm9yICh2YXIgaSA9IDAsIG1hcmtlcjsgbWFya2VyID0gdGhpcy5tYXJrZXJzX1tpXTsgaSsrKSB7XG4gICAgICBtYXJrZXIuc2V0TWFwKHRoaXMubWFwXyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLm1hcmtlcnNfLmxlbmd0aCA8IHRoaXMubWluQ2x1c3RlclNpemVfKSB7XG4gICAgLy8gTWluIGNsdXN0ZXIgc2l6ZSBub3QgeWV0IHJlYWNoZWQuXG4gICAgdGhpcy5jbHVzdGVySWNvbl8uaGlkZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBudW1TdHlsZXMgPSB0aGlzLm1hcmtlckNsdXN0ZXJlcl8uZ2V0U3R5bGVzKCkubGVuZ3RoO1xuICB2YXIgc3VtcyA9IHRoaXMubWFya2VyQ2x1c3RlcmVyXy5nZXRDYWxjdWxhdG9yKCkodGhpcy5tYXJrZXJzXywgbnVtU3R5bGVzKTtcbiAgdGhpcy5jbHVzdGVySWNvbl8uc2V0Q2VudGVyKHRoaXMuY2VudGVyXyk7XG4gIHRoaXMuY2x1c3Rlckljb25fLnNldFN1bXMoc3Vtcyk7XG4gIHRoaXMuY2x1c3Rlckljb25fLnNob3coKTtcbn07XG5cblxuLyoqXG4gKiBBIGNsdXN0ZXIgaWNvblxuICpcbiAqIEBwYXJhbSB7Q2x1c3Rlcn0gY2x1c3RlciBUaGUgY2x1c3RlciB0byBiZSBhc3NvY2lhdGVkIHdpdGguXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzIEFuIG9iamVjdCB0aGF0IGhhcyBzdHlsZSBwcm9wZXJ0aWVzOlxuICogICAgICd1cmwnOiAoc3RyaW5nKSBUaGUgaW1hZ2UgdXJsLlxuICogICAgICdoZWlnaHQnOiAobnVtYmVyKSBUaGUgaW1hZ2UgaGVpZ2h0LlxuICogICAgICd3aWR0aCc6IChudW1iZXIpIFRoZSBpbWFnZSB3aWR0aC5cbiAqICAgICAnYW5jaG9yJzogKEFycmF5KSBUaGUgYW5jaG9yIHBvc2l0aW9uIG9mIHRoZSBsYWJlbCB0ZXh0LlxuICogICAgICd0ZXh0Q29sb3InOiAoc3RyaW5nKSBUaGUgdGV4dCBjb2xvci5cbiAqICAgICAndGV4dFNpemUnOiAobnVtYmVyKSBUaGUgdGV4dCBzaXplLlxuICogICAgICdiYWNrZ3JvdW5kUG9zaXRpb246IChzdHJpbmcpIFRoZSBiYWNrZ3JvdW5kIHBvc3RpdGlvbiB4LCB5LlxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfcGFkZGluZyBPcHRpb25hbCBwYWRkaW5nIHRvIGFwcGx5IHRvIHRoZSBjbHVzdGVyIGljb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3XG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIENsdXN0ZXJJY29uKGNsdXN0ZXIsIHN0eWxlcywgb3B0X3BhZGRpbmcpIHtcbiAgY2x1c3Rlci5nZXRNYXJrZXJDbHVzdGVyZXIoKS5leHRlbmQoQ2x1c3Rlckljb24sIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KTtcblxuICB0aGlzLnN0eWxlc18gPSBzdHlsZXM7XG4gIHRoaXMucGFkZGluZ18gPSBvcHRfcGFkZGluZyB8fCAwO1xuICB0aGlzLmNsdXN0ZXJfID0gY2x1c3RlcjtcbiAgdGhpcy5jZW50ZXJfID0gbnVsbDtcbiAgdGhpcy5tYXBfID0gY2x1c3Rlci5nZXRNYXAoKTtcbiAgdGhpcy5kaXZfID0gbnVsbDtcbiAgdGhpcy5zdW1zXyA9IG51bGw7XG4gIHRoaXMudmlzaWJsZV8gPSBmYWxzZTtcblxuICB0aGlzLnNldE1hcCh0aGlzLm1hcF8pO1xufVxuXG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlIGNsdXN0ZXJjbGljayBldmVudCBhbmQgem9vbSdzIGlmIHRoZSBvcHRpb24gaXMgc2V0LlxuICovXG5DbHVzdGVySWNvbi5wcm90b3R5cGUudHJpZ2dlckNsdXN0ZXJDbGljayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbWFya2VyQ2x1c3RlcmVyID0gdGhpcy5jbHVzdGVyXy5nZXRNYXJrZXJDbHVzdGVyZXIoKTtcblxuICAvLyBUcmlnZ2VyIHRoZSBjbHVzdGVyY2xpY2sgZXZlbnQuXG4gIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWFya2VyQ2x1c3RlcmVyLm1hcF8sICdjbHVzdGVyY2xpY2snLCB0aGlzLmNsdXN0ZXJfKTtcblxuICBpZiAobWFya2VyQ2x1c3RlcmVyLmlzWm9vbU9uQ2xpY2soKSkge1xuICAgIC8vIFpvb20gaW50byB0aGUgY2x1c3Rlci5cbiAgICB0aGlzLm1hcF8uZml0Qm91bmRzKHRoaXMuY2x1c3Rlcl8uZ2V0Qm91bmRzKCkpO1xuICB9XG59O1xuXG5cbi8qKlxuICogQWRkaW5nIHRoZSBjbHVzdGVyIGljb24gdG8gdGhlIGRvbS5cbiAqIEBpZ25vcmVcbiAqL1xuQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGl2XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICBpZiAodGhpcy52aXNpYmxlXykge1xuICAgIHZhciBwb3MgPSB0aGlzLmdldFBvc0Zyb21MYXRMbmdfKHRoaXMuY2VudGVyXyk7XG4gICAgdGhpcy5kaXZfLnN0eWxlLmNzc1RleHQgPSB0aGlzLmNyZWF0ZUNzcyhwb3MpO1xuICAgIHRoaXMuZGl2Xy5pbm5lckhUTUwgPSB0aGlzLnN1bXNfLnRleHQ7XG4gIH1cblxuICB2YXIgcGFuZXMgPSB0aGlzLmdldFBhbmVzKCk7XG4gIHBhbmVzLm92ZXJsYXlNb3VzZVRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmRpdl8pO1xuXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkRG9tTGlzdGVuZXIodGhpcy5kaXZfLCAnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICB0aGF0LnRyaWdnZXJDbHVzdGVyQ2xpY2soKTtcbiAgfSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gdG8gcGxhY2UgdGhlIGRpdiBkZW5kaW5nIG9uIHRoZSBsYXRsbmcuXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5MYXRMbmd9IGxhdGxuZyBUaGUgcG9zaXRpb24gaW4gbGF0bG5nLlxuICogQHJldHVybiB7Z29vZ2xlLm1hcHMuUG9pbnR9IFRoZSBwb3NpdGlvbiBpbiBwaXhlbHMuXG4gKiBAcHJpdmF0ZVxuICovXG5DbHVzdGVySWNvbi5wcm90b3R5cGUuZ2V0UG9zRnJvbUxhdExuZ18gPSBmdW5jdGlvbihsYXRsbmcpIHtcbiAgdmFyIHBvcyA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdGxuZyk7XG4gIHBvcy54IC09IHBhcnNlSW50KHRoaXMud2lkdGhfIC8gMiwgMTApO1xuICBwb3MueSAtPSBwYXJzZUludCh0aGlzLmhlaWdodF8gLyAyLCAxMCk7XG4gIHJldHVybiBwb3M7XG59O1xuXG5cbi8qKlxuICogRHJhdyB0aGUgaWNvbi5cbiAqIEBpZ25vcmVcbiAqL1xuQ2x1c3Rlckljb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudmlzaWJsZV8pIHtcbiAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NGcm9tTGF0TG5nXyh0aGlzLmNlbnRlcl8pO1xuICAgIHRoaXMuZGl2Xy5zdHlsZS50b3AgPSBwb3MueSArICdweCc7XG4gICAgdGhpcy5kaXZfLnN0eWxlLmxlZnQgPSBwb3MueCArICdweCc7XG4gICAgdGhpcy5kaXZfLnN0eWxlLnpJbmRleCA9IGdvb2dsZS5tYXBzLk1hcmtlci5NQVhfWklOREVYICsgMTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEhpZGUgdGhlIGljb24uXG4gKi9cbkNsdXN0ZXJJY29uLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpdl8pIHtcbiAgICB0aGlzLmRpdl8uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfVxuICB0aGlzLnZpc2libGVfID0gZmFsc2U7XG59O1xuXG5cbi8qKlxuICogUG9zaXRpb24gYW5kIHNob3cgdGhlIGljb24uXG4gKi9cbkNsdXN0ZXJJY29uLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmRpdl8pIHtcbiAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NGcm9tTGF0TG5nXyh0aGlzLmNlbnRlcl8pO1xuICAgIHRoaXMuZGl2Xy5zdHlsZS5jc3NUZXh0ID0gdGhpcy5jcmVhdGVDc3MocG9zKTtcbiAgICB0aGlzLmRpdl8uc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9XG4gIHRoaXMudmlzaWJsZV8gPSB0cnVlO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZSB0aGUgaWNvbiBmcm9tIHRoZSBtYXBcbiAqL1xuQ2x1c3Rlckljb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNldE1hcChudWxsKTtcbn07XG5cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgb25SZW1vdmUgaW50ZXJmYWNlLlxuICogQGlnbm9yZVxuICovXG5DbHVzdGVySWNvbi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZGl2XyAmJiB0aGlzLmRpdl8ucGFyZW50Tm9kZSkge1xuICAgIHRoaXMuaGlkZSgpO1xuICAgIHRoaXMuZGl2Xy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2Xyk7XG4gICAgdGhpcy5kaXZfID0gbnVsbDtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldCB0aGUgc3VtcyBvZiB0aGUgaWNvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3VtcyBUaGUgc3VtcyBjb250YWluaW5nOlxuICogICAndGV4dCc6IChzdHJpbmcpIFRoZSB0ZXh0IHRvIGRpc3BsYXkgaW4gdGhlIGljb24uXG4gKiAgICdpbmRleCc6IChudW1iZXIpIFRoZSBzdHlsZSBpbmRleCBvZiB0aGUgaWNvbi5cbiAqL1xuQ2x1c3Rlckljb24ucHJvdG90eXBlLnNldFN1bXMgPSBmdW5jdGlvbihzdW1zKSB7XG4gIHRoaXMuc3Vtc18gPSBzdW1zO1xuICB0aGlzLnRleHRfID0gc3Vtcy50ZXh0O1xuICB0aGlzLmluZGV4XyA9IHN1bXMuaW5kZXg7XG4gIGlmICh0aGlzLmRpdl8pIHtcbiAgICB0aGlzLmRpdl8uaW5uZXJIVE1MID0gc3Vtcy50ZXh0O1xuICB9XG5cbiAgdGhpcy51c2VTdHlsZSgpO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGljb24gdG8gdGhlIHRoZSBzdHlsZXMuXG4gKi9cbkNsdXN0ZXJJY29uLnByb3RvdHlwZS51c2VTdHlsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXggPSBNYXRoLm1heCgwLCB0aGlzLnN1bXNfLmluZGV4IC0gMSk7XG4gIGluZGV4ID0gTWF0aC5taW4odGhpcy5zdHlsZXNfLmxlbmd0aCAtIDEsIGluZGV4KTtcbiAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZXNfW2luZGV4XTtcbiAgdGhpcy51cmxfID0gc3R5bGVbJ3VybCddO1xuICB0aGlzLmhlaWdodF8gPSBzdHlsZVsnaGVpZ2h0J107XG4gIHRoaXMud2lkdGhfID0gc3R5bGVbJ3dpZHRoJ107XG4gIHRoaXMudGV4dENvbG9yXyA9IHN0eWxlWyd0ZXh0Q29sb3InXTtcbiAgdGhpcy5hbmNob3JfID0gc3R5bGVbJ2FuY2hvciddO1xuICB0aGlzLnRleHRTaXplXyA9IHN0eWxlWyd0ZXh0U2l6ZSddO1xuICB0aGlzLmJhY2tncm91bmRQb3NpdGlvbl8gPSBzdHlsZVsnYmFja2dyb3VuZFBvc2l0aW9uJ107XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgY2VudGVyIG9mIHRoZSBpY29uLlxuICpcbiAqIEBwYXJhbSB7Z29vZ2xlLm1hcHMuTGF0TG5nfSBjZW50ZXIgVGhlIGxhdGxuZyB0byBzZXQgYXMgdGhlIGNlbnRlci5cbiAqL1xuQ2x1c3Rlckljb24ucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uKGNlbnRlcikge1xuICB0aGlzLmNlbnRlcl8gPSBjZW50ZXI7XG59O1xuXG5cbi8qKlxuICogQ3JlYXRlIHRoZSBjc3MgdGV4dCBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIGljb24uXG4gKlxuICogQHBhcmFtIHtnb29nbGUubWFwcy5Qb2ludH0gcG9zIFRoZSBwb3NpdGlvbi5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNzcyBzdHlsZSB0ZXh0LlxuICovXG5DbHVzdGVySWNvbi5wcm90b3R5cGUuY3JlYXRlQ3NzID0gZnVuY3Rpb24ocG9zKSB7XG4gIHZhciBzdHlsZSA9IFtdO1xuICBzdHlsZS5wdXNoKCdiYWNrZ3JvdW5kLWltYWdlOnVybCgnICsgdGhpcy51cmxfICsgJyk7Jyk7XG4gIHZhciBiYWNrZ3JvdW5kUG9zaXRpb24gPSB0aGlzLmJhY2tncm91bmRQb3NpdGlvbl8gPyB0aGlzLmJhY2tncm91bmRQb3NpdGlvbl8gOiAnMCAwJztcbiAgc3R5bGUucHVzaCgnYmFja2dyb3VuZC1wb3NpdGlvbjonICsgYmFja2dyb3VuZFBvc2l0aW9uICsgJzsnKTtcblxuICBpZiAodHlwZW9mIHRoaXMuYW5jaG9yXyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuYW5jaG9yX1swXSA9PT0gJ251bWJlcicgJiYgdGhpcy5hbmNob3JfWzBdID4gMCAmJlxuICAgICAgICB0aGlzLmFuY2hvcl9bMF0gPCB0aGlzLmhlaWdodF8pIHtcbiAgICAgIHN0eWxlLnB1c2goJ2hlaWdodDonICsgKHRoaXMuaGVpZ2h0XyAtIHRoaXMuYW5jaG9yX1swXSkgK1xuICAgICAgICAgICdweDsgcGFkZGluZy10b3A6JyArIHRoaXMuYW5jaG9yX1swXSArICdweDsnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUucHVzaCgnaGVpZ2h0OicgKyB0aGlzLmhlaWdodF8gKyAncHg7IGxpbmUtaGVpZ2h0OicgKyB0aGlzLmhlaWdodF8gK1xuICAgICAgICAgICdweDsnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmFuY2hvcl9bMV0gPT09ICdudW1iZXInICYmIHRoaXMuYW5jaG9yX1sxXSA+IDAgJiZcbiAgICAgICAgdGhpcy5hbmNob3JfWzFdIDwgdGhpcy53aWR0aF8pIHtcbiAgICAgIHN0eWxlLnB1c2goJ3dpZHRoOicgKyAodGhpcy53aWR0aF8gLSB0aGlzLmFuY2hvcl9bMV0pICtcbiAgICAgICAgICAncHg7IHBhZGRpbmctbGVmdDonICsgdGhpcy5hbmNob3JfWzFdICsgJ3B4OycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5wdXNoKCd3aWR0aDonICsgdGhpcy53aWR0aF8gKyAncHg7IHRleHQtYWxpZ246Y2VudGVyOycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5wdXNoKCdoZWlnaHQ6JyArIHRoaXMuaGVpZ2h0XyArICdweDsgbGluZS1oZWlnaHQ6JyArXG4gICAgICAgIHRoaXMuaGVpZ2h0XyArICdweDsgd2lkdGg6JyArIHRoaXMud2lkdGhfICsgJ3B4OyB0ZXh0LWFsaWduOmNlbnRlcjsnKTtcbiAgfVxuXG4gIHZhciB0eHRDb2xvciA9IHRoaXMudGV4dENvbG9yXyA/IHRoaXMudGV4dENvbG9yXyA6ICdibGFjayc7XG4gIHZhciB0eHRTaXplID0gdGhpcy50ZXh0U2l6ZV8gPyB0aGlzLnRleHRTaXplXyA6IDExO1xuXG4gIHN0eWxlLnB1c2goJ2N1cnNvcjpwb2ludGVyOyB0b3A6JyArIHBvcy55ICsgJ3B4OyBsZWZ0OicgK1xuICAgICAgcG9zLnggKyAncHg7IGNvbG9yOicgKyB0eHRDb2xvciArICc7IHBvc2l0aW9uOmFic29sdXRlOyBmb250LXNpemU6JyArXG4gICAgICB0eHRTaXplICsgJ3B4OyBmb250LWZhbWlseTpBcmlhbCxzYW5zLXNlcmlmOyBmb250LXdlaWdodDpib2xkJyk7XG4gIHJldHVybiBzdHlsZS5qb2luKCcnKTtcbn07XG5cblxuLy8gRXhwb3J0IFN5bWJvbHMgZm9yIENsb3N1cmVcbi8vIElmIHlvdSBhcmUgbm90IGdvaW5nIHRvIGNvbXBpbGUgd2l0aCBjbG9zdXJlIHRoZW4geW91IGNhbiByZW1vdmUgdGhlXG4vLyBjb2RlIGJlbG93LlxudmFyIHdpbmRvdyA9IHdpbmRvdyB8fCB7fTtcbndpbmRvd1snTWFya2VyQ2x1c3RlcmVyJ10gPSBNYXJrZXJDbHVzdGVyZXI7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydhZGRNYXJrZXInXSA9IE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuYWRkTWFya2VyO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnYWRkTWFya2VycyddID0gTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRNYXJrZXJzO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnY2xlYXJNYXJrZXJzJ10gPVxuICAgIE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuY2xlYXJNYXJrZXJzO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnZml0TWFwVG9NYXJrZXJzJ10gPVxuICAgIE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuZml0TWFwVG9NYXJrZXJzO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnZ2V0Q2FsY3VsYXRvciddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldENhbGN1bGF0b3I7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydnZXRHcmlkU2l6ZSddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldEdyaWRTaXplO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnZ2V0RXh0ZW5kZWRCb3VuZHMnXSA9XG4gICAgTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRFeHRlbmRlZEJvdW5kcztcbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGVbJ2dldE1hcCddID0gTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNYXA7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydnZXRNYXJrZXJzJ10gPSBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldE1hcmtlcnM7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydnZXRNYXhab29tJ10gPSBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldE1heFpvb207XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydnZXRTdHlsZXMnXSA9IE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuZ2V0U3R5bGVzO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnZ2V0VG90YWxDbHVzdGVycyddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLmdldFRvdGFsQ2x1c3RlcnM7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydnZXRUb3RhbE1hcmtlcnMnXSA9XG4gICAgTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRUb3RhbE1hcmtlcnM7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydyZWRyYXcnXSA9IE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUucmVkcmF3O1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsncmVtb3ZlTWFya2VyJ10gPVxuICAgIE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsncmVtb3ZlTWFya2VycyddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnJlbW92ZU1hcmtlcnM7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydyZXNldFZpZXdwb3J0J10gPVxuICAgIE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUucmVzZXRWaWV3cG9ydDtcbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGVbJ3JlcGFpbnQnXSA9XG4gICAgTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5yZXBhaW50O1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnc2V0Q2FsY3VsYXRvciddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnNldENhbGN1bGF0b3I7XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydzZXRHcmlkU2l6ZSddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnNldEdyaWRTaXplO1xuTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZVsnc2V0TWF4Wm9vbSddID1cbiAgICBNYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlLnNldE1heFpvb207XG5NYXJrZXJDbHVzdGVyZXIucHJvdG90eXBlWydvbkFkZCddID0gTWFya2VyQ2x1c3RlcmVyLnByb3RvdHlwZS5vbkFkZDtcbk1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGVbJ2RyYXcnXSA9IE1hcmtlckNsdXN0ZXJlci5wcm90b3R5cGUuZHJhdztcblxuQ2x1c3Rlci5wcm90b3R5cGVbJ2dldENlbnRlciddID0gQ2x1c3Rlci5wcm90b3R5cGUuZ2V0Q2VudGVyO1xuQ2x1c3Rlci5wcm90b3R5cGVbJ2dldFNpemUnXSA9IENsdXN0ZXIucHJvdG90eXBlLmdldFNpemU7XG5DbHVzdGVyLnByb3RvdHlwZVsnZ2V0TWFya2VycyddID0gQ2x1c3Rlci5wcm90b3R5cGUuZ2V0TWFya2VycztcblxuQ2x1c3Rlckljb24ucHJvdG90eXBlWydvbkFkZCddID0gQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uQWRkO1xuQ2x1c3Rlckljb24ucHJvdG90eXBlWydkcmF3J10gPSBDbHVzdGVySWNvbi5wcm90b3R5cGUuZHJhdztcbkNsdXN0ZXJJY29uLnByb3RvdHlwZVsnb25SZW1vdmUnXSA9IENsdXN0ZXJJY29uLnByb3RvdHlwZS5vblJlbW92ZTtcblxuT2JqZWN0LmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvcih2YXIgbmFtZSBpbiBvKSB7XG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBNYXJrZXJDbHVzdGVyZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucykge1xuICB2YXIgc3R5bGVzID0gW107XG4gIHZhciBuZXdTdHlsZXMgPSB7fTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNzcyA9IGl0ZW1bMV07XG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXTtcbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXTtcbiAgICB2YXIgcGFydCA9IHtcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9O1xuXG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHBhcnRzOiBbcGFydF1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG4gICAgdmFyIGogPSAwO1xuXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKys7XG5cbiAgICAgIGZvciAoOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW107XG5cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7XG4gICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICByZWZzOiAxLFxuICAgICAgICBwYXJ0czogcGFydHNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMob3B0aW9ucy5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gdHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcyA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmF0dHJpYnV0ZXMgOiB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV07XG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuICAgICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICAgIGRvbVN0eWxlLnJlZnMtLTtcbiAgICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICB2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgICAgYWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbWF5UmVtb3ZlLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kb21TdHlsZSA9IG1heVJlbW92ZVtfaV07XG5cbiAgICAgIGlmIChfZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9kb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIF9kb21TdHlsZS5wYXJ0c1tqXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW19kb21TdHlsZS5pZF07XG4gICAgICB9XG4gICAgfVxuICB9O1xufTsiLCJ2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbWFpbi5jc3NcIik7XG5cbmlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xufVxuXG52YXIgb3B0aW9ucyA9IHt9XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmIChjb250ZW50LmxvY2Fscykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xufVxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZHluYVRyZWV7XFxuICBib3JkZXI6MXB4IHNvbGlkIHJlZDtcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuIiwidmFyIGVzY2FwZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzXCIpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIEZhbmN5dHJlZSBcXFwiYXdlc29tZVxcXCIgc2tpbi5cXG4gKlxcbiAqIERPTidUIEVESVQgVEhFIENTUyBGSUxFIERJUkVDVExZLCBzaW5jZSBpdCBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tXFxuICogdGhlIExFU1MgdGVtcGxhdGVzLlxcbiAqLy5mYW5jeXRyZWUtaGVscGVyLWhpZGRlbntkaXNwbGF5Om5vbmV9LmZhbmN5dHJlZS1oZWxwZXItaW5kZXRlcm1pbmF0ZS1jYntjb2xvcjojNzc3fS5mYW5jeXRyZWUtaGVscGVyLWRpc2FibGVke2NvbG9yOnNpbHZlcn0uZmFuY3l0cmVlLWhlbHBlci1zcGluey13ZWJraXQtYW5pbWF0aW9uOnNwaW4gMXMgaW5maW5pdGUgbGluZWFyO2FuaW1hdGlvbjpzcGluIDFzIGluZmluaXRlIGxpbmVhcn1ALXdlYmtpdC1rZXlmcmFtZXMgc3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMCk7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNTlkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzU5ZGVnKX19QGtleWZyYW1lcyBzcGluezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwKTt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM1OWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNTlkZWcpfX11bC5mYW5jeXRyZWUtY29udGFpbmVye2ZvbnQtZmFtaWx5OnRhaG9tYSxhcmlhbCxoZWx2ZXRpY2E7Zm9udC1zaXplOjEwcHQ7d2hpdGUtc3BhY2U6bm93cmFwO3BhZGRpbmc6M3B4O21hcmdpbjowO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6MXB4IGRvdHRlZCBncmF5O21pbi1oZWlnaHQ6MDtwb3NpdGlvbjpyZWxhdGl2ZX11bC5mYW5jeXRyZWUtY29udGFpbmVyIHVse3BhZGRpbmc6MCAwIDAgMTBwdDttYXJnaW46MH11bC5mYW5jeXRyZWUtY29udGFpbmVyIHVsPmxpOmJlZm9yZXtjb250ZW50Om5vbmV9dWwuZmFuY3l0cmVlLWNvbnRhaW5lciBsaXtsaXN0LXN0eWxlLWltYWdlOm5vbmU7bGlzdC1zdHlsZS1wb3NpdGlvbjpvdXRzaWRlO2xpc3Qtc3R5bGUtdHlwZTpub25lOy1tb3otYmFja2dyb3VuZC1jbGlwOmJvcmRlcjstbW96LWJhY2tncm91bmQtaW5saW5lLXBvbGljeTpjb250aW51b3VzOy1tb3otYmFja2dyb3VuZC1vcmlnaW46cGFkZGluZztiYWNrZ3JvdW5kLWF0dGFjaG1lbnQ6c2Nyb2xsO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnQ7YmFja2dyb3VuZC1wb3NpdGlvbjowIDA7YmFja2dyb3VuZC1yZXBlYXQ6cmVwZWF0LXk7YmFja2dyb3VuZC1pbWFnZTpub25lO21hcmdpbjowfXVsLmZhbmN5dHJlZS1jb250YWluZXIgbGkuZmFuY3l0cmVlLWxhc3RzaWJ7YmFja2dyb3VuZC1pbWFnZTpub25lfS51aS1mYW5jeXRyZWUtZGlzYWJsZWQgdWwuZmFuY3l0cmVlLWNvbnRhaW5lcntvcGFjaXR5Oi41O2JhY2tncm91bmQtY29sb3I6c2lsdmVyfXVsLmZhbmN5dHJlZS1jb25uZWN0b3JzLmZhbmN5dHJlZS1jb250YWluZXIgbGl7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL3NraW4tYXdlc29tZS92bGluZS5naWZcIikpICsgXCIpO2JhY2tncm91bmQtcG9zaXRpb246MCAwfXVsLmZhbmN5dHJlZS1jb250YWluZXIgbGkuZmFuY3l0cmVlLWxhc3RzaWIsdWwuZmFuY3l0cmVlLW5vLWNvbm5lY3Rvcj5saXtiYWNrZ3JvdW5kLWltYWdlOm5vbmV9bGkuZmFuY3l0cmVlLWFuaW1hdGluZ3twb3NpdGlvbjpyZWxhdGl2ZX0jZmFuY3l0cmVlLWRyb3AtbWFya2VyLHNwYW4uZmFuY3l0cmVlLWNoZWNrYm94LHNwYW4uZmFuY3l0cmVlLWRyYWctaGVscGVyLWltZyxzcGFuLmZhbmN5dHJlZS1lbXB0eSxzcGFuLmZhbmN5dHJlZS1leHBhbmRlcixzcGFuLmZhbmN5dHJlZS1pY29uLHNwYW4uZmFuY3l0cmVlLXZsaW5le3dpZHRoOjEwcHQ7aGVpZ2h0OjEwcHQ7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMH1zcGFuLmZhbmN5dHJlZS1jaGVja2JveCxzcGFuLmZhbmN5dHJlZS1jdXN0b20taWNvbixzcGFuLmZhbmN5dHJlZS1leHBhbmRlcixzcGFuLmZhbmN5dHJlZS1pY29ue21hcmdpbi10b3A6MH1zcGFuLmZhbmN5dHJlZS1jdXN0b20taWNvbnt3aWR0aDoxMHB0O2hlaWdodDoxMHB0O2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0OjNweDtiYWNrZ3JvdW5kLXBvc2l0aW9uOjAgMH1pbWcuZmFuY3l0cmVlLWljb257d2lkdGg6MTBwdDtoZWlnaHQ6MTBwdDttYXJnaW4tbGVmdDozcHg7bWFyZ2luLXRvcDowO3ZlcnRpY2FsLWFsaWduOnRvcDtib3JkZXItc3R5bGU6bm9uZX1zcGFuLmZhbmN5dHJlZS1leHBhbmRlcntjdXJzb3I6cG9pbnRlcn0uZmFuY3l0cmVlLWV4cC1uIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVyLC5mYW5jeXRyZWUtZXhwLW5sIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVye2JhY2tncm91bmQtaW1hZ2U6bm9uZTtjdXJzb3I6ZGVmYXVsdH0uZmFuY3l0cmVlLWNvbm5lY3RvcnMgLmZhbmN5dHJlZS1leHAtbiBzcGFuLmZhbmN5dHJlZS1leHBhbmRlciwuZmFuY3l0cmVlLWNvbm5lY3RvcnMgLmZhbmN5dHJlZS1leHAtbmwgc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXJ7bWFyZ2luLXRvcDowfS5mYW5jeXRyZWUtZmFkZS1leHBhbmRlciBzcGFuLmZhbmN5dHJlZS1leHBhbmRlcnt0cmFuc2l0aW9uOm9wYWNpdHkgMS41cztvcGFjaXR5OjB9LmZhbmN5dHJlZS1mYWRlLWV4cGFuZGVyIC5mYW5jeXRyZWUtdHJlZWZvY3VzIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVyLC5mYW5jeXRyZWUtZmFkZS1leHBhbmRlciBbY2xhc3MqPWZhbmN5dHJlZS1zdGF0dXNub2RlLV0gc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXIsLmZhbmN5dHJlZS1mYWRlLWV4cGFuZGVyLmZhbmN5dHJlZS10cmVlZm9jdXMgc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXIsLmZhbmN5dHJlZS1mYWRlLWV4cGFuZGVyOmhvdmVyIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVye3RyYW5zaXRpb246b3BhY2l0eSAuNnM7b3BhY2l0eToxfXNwYW4uZmFuY3l0cmVlLWNoZWNrYm94e21hcmdpbi1sZWZ0OjNweH0uZmFuY3l0cmVlLXVuc2VsZWN0YWJsZSBzcGFuLmZhbmN5dHJlZS1jaGVja2JveHtvcGFjaXR5Oi40fS5mYW5jeXRyZWUtY29udGFpbmVyLmZhbmN5dHJlZS1jaGVja2JveC1hdXRvLWhpZGUgc3Bhbi5mYW5jeXRyZWUtY2hlY2tib3h7dmlzaWJpbGl0eTpoaWRkZW59LmZhbmN5dHJlZS1jb250YWluZXIuZmFuY3l0cmVlLWNoZWNrYm94LWF1dG8taGlkZSAuZmFuY3l0cmVlLW5vZGUuZmFuY3l0cmVlLXNlbGVjdGVkIHNwYW4uZmFuY3l0cmVlLWNoZWNrYm94LC5mYW5jeXRyZWUtY29udGFpbmVyLmZhbmN5dHJlZS1jaGVja2JveC1hdXRvLWhpZGUgLmZhbmN5dHJlZS1ub2RlOmhvdmVyIHNwYW4uZmFuY3l0cmVlLWNoZWNrYm94LC5mYW5jeXRyZWUtY29udGFpbmVyLmZhbmN5dHJlZS1jaGVja2JveC1hdXRvLWhpZGUgdHIuZmFuY3l0cmVlLXNlbGVjdGVkIHRkIHNwYW4uZmFuY3l0cmVlLWNoZWNrYm94LC5mYW5jeXRyZWUtY29udGFpbmVyLmZhbmN5dHJlZS1jaGVja2JveC1hdXRvLWhpZGUgdHI6aG92ZXIgdGQgc3Bhbi5mYW5jeXRyZWUtY2hlY2tib3h7dmlzaWJpbGl0eTp1bnNldH0uZmFuY3l0cmVlLWNvbnRhaW5lci5mYW5jeXRyZWUtY2hlY2tib3gtYXV0by1oaWRlLmZhbmN5dHJlZS10cmVlZm9jdXMgLmZhbmN5dHJlZS1ub2RlLmZhbmN5dHJlZS1hY3RpdmUgc3Bhbi5mYW5jeXRyZWUtY2hlY2tib3gsLmZhbmN5dHJlZS1jb250YWluZXIuZmFuY3l0cmVlLWNoZWNrYm94LWF1dG8taGlkZS5mYW5jeXRyZWUtdHJlZWZvY3VzIHRyLmZhbmN5dHJlZS1hY3RpdmUgdGQgc3Bhbi5mYW5jeXRyZWUtY2hlY2tib3h7dmlzaWJpbGl0eTp1bnNldH1zcGFuLmZhbmN5dHJlZS1pY29ue21hcmdpbi1sZWZ0OjNweH0uZmFuY3l0cmVlLWxvYWRpbmcgc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXIsLmZhbmN5dHJlZS1sb2FkaW5nIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVyOmhvdmVyLC5mYW5jeXRyZWUtc3RhdHVzbm9kZS1sb2FkaW5nIHNwYW4uZmFuY3l0cmVlLWljb24sLmZhbmN5dHJlZS1zdGF0dXNub2RlLWxvYWRpbmcgc3Bhbi5mYW5jeXRyZWUtaWNvbjpob3ZlcixzcGFuLmZhbmN5dHJlZS1pY29uLmZhbmN5dHJlZS1pY29uLWxvYWRpbmd7YmFja2dyb3VuZC1pbWFnZTpub25lfXNwYW4uZmFuY3l0cmVlLW5vZGV7ZGlzcGxheTppbmhlcml0O3dpZHRoOjEwMCU7bWFyZ2luLXRvcDoxcHg7bWluLWhlaWdodDoxMHB0fXNwYW4uZmFuY3l0cmVlLXRpdGxle2NvbG9yOiMwMDA7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wO21pbi1oZWlnaHQ6MTBwdDtwYWRkaW5nOjAgM3B4IDAgM3B4O21hcmdpbjowIDAgMCAzcHg7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDstd2Via2l0LWJvcmRlci1yYWRpdXM6MDstbW96LWJvcmRlci1yYWRpdXM6MDstbXMtYm9yZGVyLXJhZGl1czowOy1vLWJvcmRlci1yYWRpdXM6MDtib3JkZXItcmFkaXVzOjB9c3Bhbi5mYW5jeXRyZWUtbm9kZS5mYW5jeXRyZWUtZXJyb3Igc3Bhbi5mYW5jeXRyZWUtdGl0bGV7Y29sb3I6cmVkfXNwYW4uZmFuY3l0cmVlLWNoaWxkY291bnRlcntjb2xvcjojZmZmO2JhY2tncm91bmQ6IzMzN2FiNztib3JkZXI6MXB4IHNvbGlkIGdyYXk7Ym9yZGVyLXJhZGl1czoxMHB4O3BhZGRpbmc6MnB4O3RleHQtYWxpZ246Y2VudGVyfWRpdi5mYW5jeXRyZWUtZHJhZy1oZWxwZXIgc3Bhbi5mYW5jeXRyZWUtY2hpbGRjb3VudGVyLGRpdi5mYW5jeXRyZWUtZHJhZy1oZWxwZXIgc3Bhbi5mYW5jeXRyZWUtZG5kLW1vZGlmaWVye2Rpc3BsYXk6aW5saW5lLWJsb2NrO2NvbG9yOiNmZmY7YmFja2dyb3VuZDojMzM3YWI3O2JvcmRlcjoxcHggc29saWQgZ3JheTttaW4td2lkdGg6MTBweDtoZWlnaHQ6MTBweDtsaW5lLWhlaWdodDoxO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2JvcmRlci1yYWRpdXM6MTBweDtwYWRkaW5nOjJweDt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXNpemU6OXB4fWRpdi5mYW5jeXRyZWUtZHJhZy1oZWxwZXIgc3Bhbi5mYW5jeXRyZWUtY2hpbGRjb3VudGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDotNnB4O3JpZ2h0Oi02cHh9ZGl2LmZhbmN5dHJlZS1kcmFnLWhlbHBlciBzcGFuLmZhbmN5dHJlZS1kbmQtbW9kaWZpZXJ7YmFja2dyb3VuZDojNWNiODVjO2JvcmRlcjpub25lO2ZvbnQtd2VpZ2h0OmJvbGRlcn0jZmFuY3l0cmVlLWRyb3AtbWFya2Vye3dpZHRoOjIwcHQ7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjB9I2ZhbmN5dHJlZS1kcm9wLW1hcmtlci5mYW5jeXRyZWUtZHJvcC1hZnRlciwjZmFuY3l0cmVlLWRyb3AtbWFya2VyLmZhbmN5dHJlZS1kcm9wLWJlZm9yZXt3aWR0aDo0MHB0fXNwYW4uZmFuY3l0cmVlLWRyYWctc291cmNlLmZhbmN5dHJlZS1kcmFnLXJlbW92ZXtvcGFjaXR5Oi4xNX0uZmFuY3l0cmVlLWNvbnRhaW5lci5mYW5jeXRyZWUtcnRsIC5mYW5jeXRyZWUtZXhwLW4gc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXIsLmZhbmN5dHJlZS1jb250YWluZXIuZmFuY3l0cmVlLXJ0bCAuZmFuY3l0cmVlLWV4cC1ubCBzcGFuLmZhbmN5dHJlZS1leHBhbmRlcntiYWNrZ3JvdW5kLWltYWdlOm5vbmV9dWwuZmFuY3l0cmVlLWNvbnRhaW5lci5mYW5jeXRyZWUtcnRsIHVse3BhZGRpbmc6MCAxNnB4IDAgMH11bC5mYW5jeXRyZWUtY29udGFpbmVyLmZhbmN5dHJlZS1ydGwuZmFuY3l0cmVlLWNvbm5lY3RvcnMgbGl7YmFja2dyb3VuZC1wb3NpdGlvbjpyaWdodCAwO2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9za2luLWF3ZXNvbWUvdmxpbmUtcnRsLmdpZlwiKSkgKyBcIil9dWwuZmFuY3l0cmVlLWNvbnRhaW5lci5mYW5jeXRyZWUtcnRsIGxpLmZhbmN5dHJlZS1sYXN0c2liLHVsLmZhbmN5dHJlZS1jb250YWluZXIuZmFuY3l0cmVlLXJ0bC5mYW5jeXRyZWUtbm8tY29ubmVjdG9yPmxpe2JhY2tncm91bmQtaW1hZ2U6bm9uZX10YWJsZS5mYW5jeXRyZWUtZXh0LXRhYmxle2ZvbnQtZmFtaWx5OnRhaG9tYSxhcmlhbCxoZWx2ZXRpY2E7Zm9udC1zaXplOjEwcHQ7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlfXRhYmxlLmZhbmN5dHJlZS1leHQtdGFibGUgc3Bhbi5mYW5jeXRyZWUtbm9kZXtkaXNwbGF5OmlubGluZS1ibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9dGFibGUuZmFuY3l0cmVlLWV4dC10YWJsZSB0ZC5mYW5jeXRyZWUtc3RhdHVzLW1lcmdlZHt0ZXh0LWFsaWduOmNlbnRlcjtmb250LXN0eWxlOml0YWxpYztjb2xvcjpzaWx2ZXJ9dGFibGUuZmFuY3l0cmVlLWV4dC10YWJsZSB0ci5mYW5jeXRyZWUtc3RhdHVzbm9kZS1lcnJvciB0ZC5mYW5jeXRyZWUtc3RhdHVzLW1lcmdlZHtjb2xvcjpyZWR9dGFibGUuZmFuY3l0cmVlLWV4dC10YWJsZS5mYW5jeXRyZWUtZXh0LWFyaWFncmlkLmZhbmN5dHJlZS1jZWxsLW1vZGU+dGJvZHk+dHIuZmFuY3l0cmVlLWFjdGl2ZT50ZHtiYWNrZ3JvdW5kLWNvbG9yOiNlZWV9dGFibGUuZmFuY3l0cmVlLWV4dC10YWJsZS5mYW5jeXRyZWUtZXh0LWFyaWFncmlkLmZhbmN5dHJlZS1jZWxsLW1vZGU+dGJvZHk+dHI+dGQuZmFuY3l0cmVlLWFjdGl2ZS1jZWxse2JhY2tncm91bmQtY29sb3I6I2NiZThmNn10YWJsZS5mYW5jeXRyZWUtZXh0LXRhYmxlLmZhbmN5dHJlZS1leHQtYXJpYWdyaWQuZmFuY3l0cmVlLWNlbGwtbW9kZS5mYW5jeXRyZWUtY2VsbC1uYXYtbW9kZT50Ym9keT50cj50ZC5mYW5jeXRyZWUtYWN0aXZlLWNlbGx7YmFja2dyb3VuZC1jb2xvcjojMzg3NWQ3fXRhYmxlLmZhbmN5dHJlZS1leHQtY29sdW1udmlldyB0Ym9keSB0ciB0ZHtwb3NpdGlvbjpyZWxhdGl2ZTtib3JkZXI6MXB4IHNvbGlkIGdyYXk7dmVydGljYWwtYWxpZ246dG9wO292ZXJmbG93OmF1dG99dGFibGUuZmFuY3l0cmVlLWV4dC1jb2x1bW52aWV3IHRib2R5IHRyIHRkPnVse3BhZGRpbmc6MH10YWJsZS5mYW5jeXRyZWUtZXh0LWNvbHVtbnZpZXcgdGJvZHkgdHIgdGQ+dWwgbGl7bGlzdC1zdHlsZS1pbWFnZTpub25lO2xpc3Qtc3R5bGUtcG9zaXRpb246b3V0c2lkZTtsaXN0LXN0eWxlLXR5cGU6bm9uZTstbW96LWJhY2tncm91bmQtY2xpcDpib3JkZXI7LW1vei1iYWNrZ3JvdW5kLWlubGluZS1wb2xpY3k6Y29udGludW91czstbW96LWJhY2tncm91bmQtb3JpZ2luOnBhZGRpbmc7YmFja2dyb3VuZC1hdHRhY2htZW50OnNjcm9sbDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQtcG9zaXRpb246MCAwO2JhY2tncm91bmQtcmVwZWF0OnJlcGVhdC15O2JhY2tncm91bmQtaW1hZ2U6bm9uZTttYXJnaW46MH10YWJsZS5mYW5jeXRyZWUtZXh0LWNvbHVtbnZpZXcgc3Bhbi5mYW5jeXRyZWUtbm9kZXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1ibG9ja310YWJsZS5mYW5jeXRyZWUtZXh0LWNvbHVtbnZpZXcgc3Bhbi5mYW5jeXRyZWUtbm9kZS5mYW5jeXRyZWUtZXhwYW5kZWR7YmFja2dyb3VuZC1jb2xvcjojZTBlMGUwfXRhYmxlLmZhbmN5dHJlZS1leHQtY29sdW1udmlldyBzcGFuLmZhbmN5dHJlZS1ub2RlLmZhbmN5dHJlZS1hY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojY2JlOGY2fXRhYmxlLmZhbmN5dHJlZS1leHQtY29sdW1udmlldyAuZmFuY3l0cmVlLWhhcy1jaGlsZHJlbiBzcGFuLmZhbmN5dHJlZS1jdi1yaWdodHtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDozcHh9LmZhbmN5dHJlZS1leHQtZmlsdGVyLWRpbW0gc3Bhbi5mYW5jeXRyZWUtbm9kZSBzcGFuLmZhbmN5dHJlZS10aXRsZXtjb2xvcjpzaWx2ZXI7Zm9udC13ZWlnaHQ6bGlnaHRlcn0uZmFuY3l0cmVlLWV4dC1maWx0ZXItZGltbSBzcGFuLmZhbmN5dHJlZS1ub2RlLmZhbmN5dHJlZS1zdWJtYXRjaCBzcGFuLmZhbmN5dHJlZS10aXRsZSwuZmFuY3l0cmVlLWV4dC1maWx0ZXItZGltbSB0ci5mYW5jeXRyZWUtc3VibWF0Y2ggc3Bhbi5mYW5jeXRyZWUtdGl0bGV7Y29sb3I6IzAwMDtmb250LXdlaWdodDo0MDB9LmZhbmN5dHJlZS1leHQtZmlsdGVyLWRpbW0gc3Bhbi5mYW5jeXRyZWUtbm9kZS5mYW5jeXRyZWUtbWF0Y2ggc3Bhbi5mYW5jeXRyZWUtdGl0bGUsLmZhbmN5dHJlZS1leHQtZmlsdGVyLWRpbW0gdHIuZmFuY3l0cmVlLW1hdGNoIHNwYW4uZmFuY3l0cmVlLXRpdGxle2NvbG9yOiMwMDA7Zm9udC13ZWlnaHQ6NzAwfS5mYW5jeXRyZWUtZXh0LWZpbHRlci1oaWRlIHNwYW4uZmFuY3l0cmVlLW5vZGUuZmFuY3l0cmVlLWhpZGUsLmZhbmN5dHJlZS1leHQtZmlsdGVyLWhpZGUgdHIuZmFuY3l0cmVlLWhpZGV7ZGlzcGxheTpub25lfS5mYW5jeXRyZWUtZXh0LWZpbHRlci1oaWRlIHNwYW4uZmFuY3l0cmVlLW5vZGUuZmFuY3l0cmVlLXN1Ym1hdGNoIHNwYW4uZmFuY3l0cmVlLXRpdGxlLC5mYW5jeXRyZWUtZXh0LWZpbHRlci1oaWRlIHRyLmZhbmN5dHJlZS1zdWJtYXRjaCBzcGFuLmZhbmN5dHJlZS10aXRsZXtjb2xvcjpzaWx2ZXI7Zm9udC13ZWlnaHQ6bGlnaHRlcn0uZmFuY3l0cmVlLWV4dC1maWx0ZXItaGlkZSBzcGFuLmZhbmN5dHJlZS1ub2RlLmZhbmN5dHJlZS1tYXRjaCBzcGFuLmZhbmN5dHJlZS10aXRsZSwuZmFuY3l0cmVlLWV4dC1maWx0ZXItaGlkZSB0ci5mYW5jeXRyZWUtbWF0Y2ggc3Bhbi5mYW5jeXRyZWUtdGl0bGV7Y29sb3I6IzAwMDtmb250LXdlaWdodDo0MDB9LmZhbmN5dHJlZS1leHQtZmlsdGVyLWhpZGUtZXhwYW5kZXJzIHNwYW4uZmFuY3l0cmVlLW5vZGUuZmFuY3l0cmVlLW1hdGNoIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVyLC5mYW5jeXRyZWUtZXh0LWZpbHRlci1oaWRlLWV4cGFuZGVycyB0ci5mYW5jeXRyZWUtbWF0Y2ggc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXJ7dmlzaWJpbGl0eTpoaWRkZW59LmZhbmN5dHJlZS1leHQtZmlsdGVyLWhpZGUtZXhwYW5kZXJzIHNwYW4uZmFuY3l0cmVlLW5vZGUuZmFuY3l0cmVlLXN1Ym1hdGNoIHNwYW4uZmFuY3l0cmVlLWV4cGFuZGVyLC5mYW5jeXRyZWUtZXh0LWZpbHRlci1oaWRlLWV4cGFuZGVycyB0ci5mYW5jeXRyZWUtc3VibWF0Y2ggc3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXJ7dmlzaWJpbGl0eTp2aXNpYmxlfS5mYW5jeXRyZWUtZXh0LWNoaWxkY291bnRlciBzcGFuLmZhbmN5dHJlZS1jdXN0b20taWNvbiwuZmFuY3l0cmVlLWV4dC1jaGlsZGNvdW50ZXIgc3Bhbi5mYW5jeXRyZWUtaWNvbiwuZmFuY3l0cmVlLWV4dC1maWx0ZXIgc3Bhbi5mYW5jeXRyZWUtY3VzdG9tLWljb24sLmZhbmN5dHJlZS1leHQtZmlsdGVyIHNwYW4uZmFuY3l0cmVlLWljb257cG9zaXRpb246cmVsYXRpdmV9LmZhbmN5dHJlZS1leHQtY2hpbGRjb3VudGVyIHNwYW4uZmFuY3l0cmVlLWNoaWxkY291bnRlciwuZmFuY3l0cmVlLWV4dC1maWx0ZXIgc3Bhbi5mYW5jeXRyZWUtY2hpbGRjb3VudGVye2NvbG9yOiNmZmY7YmFja2dyb3VuZDojNzc3O2JvcmRlcjoxcHggc29saWQgZ3JheTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTZweDtyaWdodDotNnB4O21pbi13aWR0aDoxMHB4O2hlaWdodDoxMHB4O2xpbmUtaGVpZ2h0OjE7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7Ym9yZGVyLXJhZGl1czoxMHB4O3BhZGRpbmc6MnB4O3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZTo5cHh9dWwuZmFuY3l0cmVlLWV4dC13aWRle3Bvc2l0aW9uOnJlbGF0aXZlO21pbi13aWR0aDoxMDAlO3otaW5kZXg6Mjstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9dWwuZmFuY3l0cmVlLWV4dC13aWRlIHNwYW4uZmFuY3l0cmVlLW5vZGU+c3Bhbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjJ9dWwuZmFuY3l0cmVlLWV4dC13aWRlIHNwYW4uZmFuY3l0cmVlLW5vZGUgc3Bhbi5mYW5jeXRyZWUtdGl0bGV7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO2xlZnQ6MDttaW4td2lkdGg6MTAwJTttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowOy13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZmFuY3l0cmVlLWV4dC1maXhlZC13cmFwcGVyIC5mYW5jeXRyZWUtZXh0LWZpeGVkLWhpZGRlbntkaXNwbGF5Om5vbmV9LmZhbmN5dHJlZS1leHQtZml4ZWQtd3JhcHBlciBkaXYuZmFuY3l0cmVlLWV4dC1maXhlZC1zY3JvbGwtYm9yZGVyLWJvdHRvbXtib3JkZXItYm90dG9tOjNweCBzb2xpZCByZ2JhKDAsMCwwLC43NSl9LmZhbmN5dHJlZS1leHQtZml4ZWQtd3JhcHBlciBkaXYuZmFuY3l0cmVlLWV4dC1maXhlZC1zY3JvbGwtYm9yZGVyLXJpZ2h0e2JvcmRlci1yaWdodDozcHggc29saWQgcmdiYSgwLDAsMCwuNzUpfS5mYW5jeXRyZWUtZXh0LWZpeGVkLXdyYXBwZXIgZGl2LmZhbmN5dHJlZS1leHQtZml4ZWQtd3JhcHBlci10bHtwb3NpdGlvbjphYnNvbHV0ZTtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDozO3RvcDowO2xlZnQ6MH0uZmFuY3l0cmVlLWV4dC1maXhlZC13cmFwcGVyIGRpdi5mYW5jeXRyZWUtZXh0LWZpeGVkLXdyYXBwZXItdHJ7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6Mjt0b3A6MH0uZmFuY3l0cmVlLWV4dC1maXhlZC13cmFwcGVyIGRpdi5mYW5jeXRyZWUtZXh0LWZpeGVkLXdyYXBwZXItYmx7cG9zaXRpb246YWJzb2x1dGU7b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6MjtsZWZ0OjB9LmZhbmN5dHJlZS1leHQtZml4ZWQtd3JhcHBlciBkaXYuZmFuY3l0cmVlLWV4dC1maXhlZC13cmFwcGVyLWJye3Bvc2l0aW9uOmFic29sdXRlO292ZXJmbG93OnNjcm9sbDt6LWluZGV4OjF9dWwuZmFuY3l0cmVlLWNvbnRhaW5lciB1bHtwYWRkaW5nOi4zZW0gMCAwIDFlbTttYXJnaW46MH1zcGFuLmZhbmN5dHJlZS10aXRsZXtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6MH1zcGFuLmZhbmN5dHJlZS1mb2N1c2VkIHNwYW4uZmFuY3l0cmVlLXRpdGxle291dGxpbmU6MXB4IGRvdHRlZCAjMDAwfXNwYW4uZmFuY3l0cmVlLWFjdGl2ZSBzcGFuLmZhbmN5dHJlZS10aXRsZXtiYWNrZ3JvdW5kLWNvbG9yOiNkNGQ0ZDR9LmZhbmN5dHJlZS10cmVlZm9jdXMgc3Bhbi5mYW5jeXRyZWUtYWN0aXZlIHNwYW4uZmFuY3l0cmVlLXRpdGxle2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzg3NWQ3fXRhYmxlLmZhbmN5dHJlZS1leHQtdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlfXRhYmxlLmZhbmN5dHJlZS1leHQtdGFibGUgdGJvZHkgdHIuZmFuY3l0cmVlLWZvY3VzZWR7YmFja2dyb3VuZC1jb2xvcjojOTlkZWZkfXRhYmxlLmZhbmN5dHJlZS1leHQtdGFibGUgdGJvZHkgdHIuZmFuY3l0cmVlLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiM0MTY5ZTF9dGFibGUuZmFuY3l0cmVlLWV4dC1jb2x1bW52aWV3IHRib2R5IHRyIHRke2JvcmRlcjoxcHggc29saWQgZ3JheX10YWJsZS5mYW5jeXRyZWUtZXh0LWNvbHVtbnZpZXcgc3Bhbi5mYW5jeXRyZWUtbm9kZS5mYW5jeXRyZWUtZXhwYW5kZWR7YmFja2dyb3VuZC1jb2xvcjojY2NjfXRhYmxlLmZhbmN5dHJlZS1leHQtY29sdW1udmlldyBzcGFuLmZhbmN5dHJlZS1ub2RlLmZhbmN5dHJlZS1hY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojNDE2OWUxfVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXNjYXBlKHVybCkge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgfVxuICAgIC8vIElmIHVybCBpcyBhbHJlYWR5IHdyYXBwZWQgaW4gcXVvdGVzLCByZW1vdmUgdGhlbVxuICAgIGlmICgvXlsnXCJdLipbJ1wiXSQvLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICAvLyBTaG91bGQgdXJsIGJlIHdyYXBwZWQ/XG4gICAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcbiAgICBpZiAoL1tcIicoKSBcXHRcXG5dLy50ZXN0KHVybCkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSArICdcIidcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsXG59XG4iLCIvKiFcbiAqIGpxdWVyeS5mYW5jeXRyZWUuZWRpdC5qc1xuICpcbiAqIE1ha2Ugbm9kZSB0aXRsZXMgZWRpdGFibGUuXG4gKiAoRXh0ZW5zaW9uIG1vZHVsZSBmb3IganF1ZXJ5LmZhbmN5dHJlZS5qczogaHR0cHM6Ly9naXRodWIuY29tL21hcjEwL2ZhbmN5dHJlZS8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA4LTIwMTksIE1hcnRpbiBXZW5kdCAoaHR0cHM6Ly93d1dlbmR0LmRlKVxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcjEwL2ZhbmN5dHJlZS93aWtpL0xpY2Vuc2VJbmZvXG4gKlxuICogQHZlcnNpb24gMi4zMy4wXG4gKiBAZGF0ZSAyMDE5LTEwLTI5VDA4OjAwOjA3WlxuICovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoW1wianF1ZXJ5XCIsIFwiLi9qcXVlcnkuZmFuY3l0cmVlXCJdLCBmYWN0b3J5KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS9Db21tb25KU1xuXHRcdHJlcXVpcmUoXCIuL2pxdWVyeS5mYW5jeXRyZWVcIik7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufSkoZnVuY3Rpb24oJCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBQcml2YXRlIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzXG5cdCAqL1xuXG5cdHZhciBpc01hYyA9IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSxcblx0XHRlc2NhcGVIdG1sID0gJC51aS5mYW5jeXRyZWUuZXNjYXBlSHRtbCxcblx0XHR1bmVzY2FwZUh0bWwgPSAkLnVpLmZhbmN5dHJlZS51bmVzY2FwZUh0bWw7XG5cblx0LyoqXG5cdCAqIFtleHQtZWRpdF0gU3RhcnQgaW5saW5lIGVkaXRpbmcgb2YgY3VycmVudCBub2RlIHRpdGxlLlxuXHQgKlxuXHQgKiBAYWxpYXMgRmFuY3l0cmVlTm9kZSNlZGl0U3RhcnRcblx0ICogQHJlcXVpcmVzIEZhbmN5dHJlZVxuXHQgKi9cblx0JC51aS5mYW5jeXRyZWUuX0ZhbmN5dHJlZU5vZGVDbGFzcy5wcm90b3R5cGUuZWRpdFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyICRpbnB1dCxcblx0XHRcdG5vZGUgPSB0aGlzLFxuXHRcdFx0dHJlZSA9IHRoaXMudHJlZSxcblx0XHRcdGxvY2FsID0gdHJlZS5leHQuZWRpdCxcblx0XHRcdGluc3RPcHRzID0gdHJlZS5vcHRpb25zLmVkaXQsXG5cdFx0XHQkdGl0bGUgPSAkKFwiLmZhbmN5dHJlZS10aXRsZVwiLCBub2RlLnNwYW4pLFxuXHRcdFx0ZXZlbnREYXRhID0ge1xuXHRcdFx0XHRub2RlOiBub2RlLFxuXHRcdFx0XHR0cmVlOiB0cmVlLFxuXHRcdFx0XHRvcHRpb25zOiB0cmVlLm9wdGlvbnMsXG5cdFx0XHRcdGlzTmV3OiAkKG5vZGVbdHJlZS5zdGF0dXNDbGFzc1Byb3BOYW1lXSkuaGFzQ2xhc3MoXG5cdFx0XHRcdFx0XCJmYW5jeXRyZWUtZWRpdC1uZXdcIlxuXHRcdFx0XHQpLFxuXHRcdFx0XHRvcmdUaXRsZTogbm9kZS50aXRsZSxcblx0XHRcdFx0aW5wdXQ6IG51bGwsXG5cdFx0XHRcdGRpcnR5OiBmYWxzZSxcblx0XHRcdH07XG5cblx0XHQvLyBiZWZvcmVFZGl0IG1heSB3YW50IHRvIG1vZGlmeSB0aGUgdGl0bGUgYmVmb3JlIGVkaXRpbmdcblx0XHRpZiAoXG5cdFx0XHRpbnN0T3B0cy5iZWZvcmVFZGl0LmNhbGwoXG5cdFx0XHRcdG5vZGUsXG5cdFx0XHRcdHsgdHlwZTogXCJiZWZvcmVFZGl0XCIgfSxcblx0XHRcdFx0ZXZlbnREYXRhXG5cdFx0XHQpID09PSBmYWxzZVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQkLnVpLmZhbmN5dHJlZS5hc3NlcnQoIWxvY2FsLmN1cnJlbnROb2RlLCBcInJlY3Vyc2l2ZSBlZGl0XCIpO1xuXHRcdGxvY2FsLmN1cnJlbnROb2RlID0gdGhpcztcblx0XHRsb2NhbC5ldmVudERhdGEgPSBldmVudERhdGE7XG5cblx0XHQvLyBEaXNhYmxlIHN0YW5kYXJkIEZhbmN5dHJlZSBtb3VzZS0gYW5kIGtleSBoYW5kbGluZ1xuXHRcdHRyZWUud2lkZ2V0Ll91bmJpbmQoKTtcblxuXHRcdGxvY2FsLmxhc3REcmFnZ2FibGVBdHRyVmFsdWUgPSBub2RlLnNwYW4uZHJhZ2dhYmxlO1xuXHRcdGlmIChsb2NhbC5sYXN0RHJhZ2dhYmxlQXR0clZhbHVlKSB7XG5cdFx0XHRub2RlLnNwYW4uZHJhZ2dhYmxlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gIzExNjogZXh0LWRuZCBwcmV2ZW50cyB0aGUgYmx1ciBldmVudCwgc28gd2UgaGF2ZSB0byBjYXRjaCBvdXRlciBjbGlja3Ncblx0XHQkKGRvY3VtZW50KS5vbihcIm1vdXNlZG93bi5mYW5jeXRyZWUtZWRpdFwiLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKCEkKGV2ZW50LnRhcmdldCkuaGFzQ2xhc3MoXCJmYW5jeXRyZWUtZWRpdC1pbnB1dFwiKSkge1xuXHRcdFx0XHRub2RlLmVkaXRFbmQodHJ1ZSwgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gUmVwbGFjZSBub2RlIHdpdGggPGlucHV0PlxuXHRcdCRpbnB1dCA9ICQoXCI8aW5wdXQgLz5cIiwge1xuXHRcdFx0Y2xhc3M6IFwiZmFuY3l0cmVlLWVkaXQtaW5wdXRcIixcblx0XHRcdHR5cGU6IFwidGV4dFwiLFxuXHRcdFx0dmFsdWU6IHRyZWUub3B0aW9ucy5lc2NhcGVUaXRsZXNcblx0XHRcdFx0PyBldmVudERhdGEub3JnVGl0bGVcblx0XHRcdFx0OiB1bmVzY2FwZUh0bWwoZXZlbnREYXRhLm9yZ1RpdGxlKSxcblx0XHR9KTtcblx0XHRsb2NhbC5ldmVudERhdGEuaW5wdXQgPSAkaW5wdXQ7XG5cdFx0aWYgKGluc3RPcHRzLmFkanVzdFdpZHRoT2ZzICE9IG51bGwpIHtcblx0XHRcdCRpbnB1dC53aWR0aCgkdGl0bGUud2lkdGgoKSArIGluc3RPcHRzLmFkanVzdFdpZHRoT2ZzKTtcblx0XHR9XG5cdFx0aWYgKGluc3RPcHRzLmlucHV0Q3NzICE9IG51bGwpIHtcblx0XHRcdCRpbnB1dC5jc3MoaW5zdE9wdHMuaW5wdXRDc3MpO1xuXHRcdH1cblxuXHRcdCR0aXRsZS5odG1sKCRpbnB1dCk7XG5cblx0XHQvLyBGb2N1cyA8aW5wdXQ+IGFuZCBiaW5kIGtleWJvYXJkIGhhbmRsZXJcblx0XHQkaW5wdXRcblx0XHRcdC5mb2N1cygpXG5cdFx0XHQuY2hhbmdlKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdCRpbnB1dC5hZGRDbGFzcyhcImZhbmN5dHJlZS1lZGl0LWRpcnR5XCIpO1xuXHRcdFx0fSlcblx0XHRcdC5vbihcImtleWRvd25cIiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0c3dpdGNoIChldmVudC53aGljaCkge1xuXHRcdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVTQ0FQRTpcblx0XHRcdFx0XHRcdG5vZGUuZWRpdEVuZChmYWxzZSwgZXZlbnQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAkLnVpLmtleUNvZGUuRU5URVI6XG5cdFx0XHRcdFx0XHRub2RlLmVkaXRFbmQodHJ1ZSwgZXZlbnQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBzbyB3ZSBkb24ndCBzdGFydCBlZGl0bW9kZSBvbiBNYWNcblx0XHRcdFx0fVxuXHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdH0pXG5cdFx0XHQuYmx1cihmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5lZGl0RW5kKHRydWUsIGV2ZW50KTtcblx0XHRcdH0pO1xuXG5cdFx0aW5zdE9wdHMuZWRpdC5jYWxsKG5vZGUsIHsgdHlwZTogXCJlZGl0XCIgfSwgZXZlbnREYXRhKTtcblx0fTtcblxuXHQvKipcblx0ICogW2V4dC1lZGl0XSBTdG9wIGlubGluZSBlZGl0aW5nLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFthcHBseUNoYW5nZXM9ZmFsc2VdIGZhbHNlOiBjYW5jZWwgZWRpdCwgdHJ1ZTogc2F2ZSAoaWYgbW9kaWZpZWQpXG5cdCAqIEBhbGlhcyBGYW5jeXRyZWVOb2RlI2VkaXRFbmRcblx0ICogQHJlcXVpcmVzIGpxdWVyeS5mYW5jeXRyZWUuZWRpdC5qc1xuXHQgKi9cblx0JC51aS5mYW5jeXRyZWUuX0ZhbmN5dHJlZU5vZGVDbGFzcy5wcm90b3R5cGUuZWRpdEVuZCA9IGZ1bmN0aW9uKFxuXHRcdGFwcGx5Q2hhbmdlcyxcblx0XHRfZXZlbnRcblx0KSB7XG5cdFx0dmFyIG5ld1ZhbCxcblx0XHRcdG5vZGUgPSB0aGlzLFxuXHRcdFx0dHJlZSA9IHRoaXMudHJlZSxcblx0XHRcdGxvY2FsID0gdHJlZS5leHQuZWRpdCxcblx0XHRcdGV2ZW50RGF0YSA9IGxvY2FsLmV2ZW50RGF0YSxcblx0XHRcdGluc3RPcHRzID0gdHJlZS5vcHRpb25zLmVkaXQsXG5cdFx0XHQkdGl0bGUgPSAkKFwiLmZhbmN5dHJlZS10aXRsZVwiLCBub2RlLnNwYW4pLFxuXHRcdFx0JGlucHV0ID0gJHRpdGxlLmZpbmQoXCJpbnB1dC5mYW5jeXRyZWUtZWRpdC1pbnB1dFwiKTtcblxuXHRcdGlmIChpbnN0T3B0cy50cmltKSB7XG5cdFx0XHQkaW5wdXQudmFsKCQudHJpbSgkaW5wdXQudmFsKCkpKTtcblx0XHR9XG5cdFx0bmV3VmFsID0gJGlucHV0LnZhbCgpO1xuXG5cdFx0ZXZlbnREYXRhLmRpcnR5ID0gbmV3VmFsICE9PSBub2RlLnRpdGxlO1xuXHRcdGV2ZW50RGF0YS5vcmlnaW5hbEV2ZW50ID0gX2V2ZW50O1xuXG5cdFx0Ly8gRmluZCBvdXQsIGlmIHNhdmluZyBpcyByZXF1aXJlZFxuXHRcdGlmIChhcHBseUNoYW5nZXMgPT09IGZhbHNlKSB7XG5cdFx0XHQvLyBJZiB0cnVlL2ZhbHNlIHdhcyBwYXNzZWQsIGhvbm9yIHRoaXMgKGV4Y2VwdCBpbiByZW5hbWUgbW9kZSwgaWYgdW5jaGFuZ2VkKVxuXHRcdFx0ZXZlbnREYXRhLnNhdmUgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50RGF0YS5pc05ldykge1xuXHRcdFx0Ly8gSW4gY3JlYXRlIG1vZGUsIHdlIHNhdmUgZXZlcnl0aGluZywgZXhjZXB0IGZvciBlbXB0eSB0ZXh0XG5cdFx0XHRldmVudERhdGEuc2F2ZSA9IG5ld1ZhbCAhPT0gXCJcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSW4gcmVuYW1lIG1vZGUsIHdlIHNhdmUgZXZlcnl0aW5nLCBleGNlcHQgZm9yIGVtcHR5IG9yIHVuY2hhbmdlZCB0ZXh0XG5cdFx0XHRldmVudERhdGEuc2F2ZSA9IGV2ZW50RGF0YS5kaXJ0eSAmJiBuZXdWYWwgIT09IFwiXCI7XG5cdFx0fVxuXHRcdC8vIEFsbG93IHRvIGJyZWFrIChrZWVwIGVkaXRvciBvcGVuKSwgbW9kaWZ5IGlucHV0LCBvciByZS1kZWZpbmUgZGF0YS5zYXZlXG5cdFx0aWYgKFxuXHRcdFx0aW5zdE9wdHMuYmVmb3JlQ2xvc2UuY2FsbChcblx0XHRcdFx0bm9kZSxcblx0XHRcdFx0eyB0eXBlOiBcImJlZm9yZUNsb3NlXCIgfSxcblx0XHRcdFx0ZXZlbnREYXRhXG5cdFx0XHQpID09PSBmYWxzZVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoXG5cdFx0XHRldmVudERhdGEuc2F2ZSAmJlxuXHRcdFx0aW5zdE9wdHMuc2F2ZS5jYWxsKG5vZGUsIHsgdHlwZTogXCJzYXZlXCIgfSwgZXZlbnREYXRhKSA9PT0gZmFsc2Vcblx0XHQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0JGlucHV0LnJlbW92ZUNsYXNzKFwiZmFuY3l0cmVlLWVkaXQtZGlydHlcIikub2ZmKCk7XG5cdFx0Ly8gVW5iaW5kIG91dGVyLWNsaWNrIGhhbmRsZXJcblx0XHQkKGRvY3VtZW50KS5vZmYoXCIuZmFuY3l0cmVlLWVkaXRcIik7XG5cblx0XHRpZiAoZXZlbnREYXRhLnNhdmUpIHtcblx0XHRcdC8vICMgMTcxOiBlc2NhcGUgdXNlciBpbnB1dCAobm90IHJlcXVpcmVkIGlmIGdsb2JhbCBlc2NhcGluZyBpcyBvbilcblx0XHRcdG5vZGUuc2V0VGl0bGUoXG5cdFx0XHRcdHRyZWUub3B0aW9ucy5lc2NhcGVUaXRsZXMgPyBuZXdWYWwgOiBlc2NhcGVIdG1sKG5ld1ZhbClcblx0XHRcdCk7XG5cdFx0XHRub2RlLnNldEZvY3VzKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChldmVudERhdGEuaXNOZXcpIHtcblx0XHRcdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRcdFx0bm9kZSA9IGV2ZW50RGF0YS5ub2RlID0gbnVsbDtcblx0XHRcdFx0bG9jYWwucmVsYXRlZE5vZGUuc2V0Rm9jdXMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucmVuZGVyVGl0bGUoKTtcblx0XHRcdFx0bm9kZS5zZXRGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2NhbC5ldmVudERhdGEgPSBudWxsO1xuXHRcdGxvY2FsLmN1cnJlbnROb2RlID0gbnVsbDtcblx0XHRsb2NhbC5yZWxhdGVkTm9kZSA9IG51bGw7XG5cdFx0Ly8gUmUtZW5hYmxlIG1vdXNlIGFuZCBrZXlib2FyZCBoYW5kbGluZ1xuXHRcdHRyZWUud2lkZ2V0Ll9iaW5kKCk7XG5cblx0XHRpZiAobG9jYWwubGFzdERyYWdnYWJsZUF0dHJWYWx1ZSkge1xuXHRcdFx0bm9kZS5zcGFuLmRyYWdnYWJsZSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IGtleWJvYXJkIGZvY3VzLCBldmVuIGlmIHNldEZvY3VzKCkgY2xhaW1zICdub3RoaW5nIHRvIGRvJ1xuXHRcdCQodHJlZS4kY29udGFpbmVyKS5mb2N1cygpO1xuXHRcdGV2ZW50RGF0YS5pbnB1dCA9IG51bGw7XG5cdFx0aW5zdE9wdHMuY2xvc2UuY2FsbChub2RlLCB7IHR5cGU6IFwiY2xvc2VcIiB9LCBldmVudERhdGEpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBbZXh0LWVkaXRdIENyZWF0ZSBhIG5ldyBjaGlsZCBvciBzaWJsaW5nIG5vZGUgYW5kIHN0YXJ0IGVkaXQgbW9kZS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IFttb2RlPSdjaGlsZCddICdiZWZvcmUnLCAnYWZ0ZXInLCBvciAnY2hpbGQnXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbaW5pdF0gTm9kZURhdGEgKG9yIHNpbXBsZSB0aXRsZSBzdHJpbmcpXG5cdCAqIEBhbGlhcyBGYW5jeXRyZWVOb2RlI2VkaXRDcmVhdGVOb2RlXG5cdCAqIEByZXF1aXJlcyBqcXVlcnkuZmFuY3l0cmVlLmVkaXQuanNcblx0ICogQHNpbmNlIDIuNFxuXHQgKi9cblx0JC51aS5mYW5jeXRyZWUuX0ZhbmN5dHJlZU5vZGVDbGFzcy5wcm90b3R5cGUuZWRpdENyZWF0ZU5vZGUgPSBmdW5jdGlvbihcblx0XHRtb2RlLFxuXHRcdGluaXRcblx0KSB7XG5cdFx0dmFyIG5ld05vZGUsXG5cdFx0XHR0cmVlID0gdGhpcy50cmVlLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRtb2RlID0gbW9kZSB8fCBcImNoaWxkXCI7XG5cdFx0aWYgKGluaXQgPT0gbnVsbCkge1xuXHRcdFx0aW5pdCA9IHsgdGl0bGU6IFwiXCIgfTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRpbml0ID0geyB0aXRsZTogaW5pdCB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLnVpLmZhbmN5dHJlZS5hc3NlcnQoJC5pc1BsYWluT2JqZWN0KGluaXQpKTtcblx0XHR9XG5cdFx0Ly8gTWFrZSBzdXJlIG5vZGUgaXMgZXhwYW5kZWQgKGFuZCBsb2FkZWQpIGluICdjaGlsZCcgbW9kZVxuXHRcdGlmIChcblx0XHRcdG1vZGUgPT09IFwiY2hpbGRcIiAmJlxuXHRcdFx0IXRoaXMuaXNFeHBhbmRlZCgpICYmXG5cdFx0XHR0aGlzLmhhc0NoaWxkcmVuKCkgIT09IGZhbHNlXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnNldEV4cGFuZGVkKCkuZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5lZGl0Q3JlYXRlTm9kZShtb2RlLCBpbml0KTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRuZXdOb2RlID0gdGhpcy5hZGROb2RlKGluaXQsIG1vZGUpO1xuXG5cdFx0Ly8gIzY0NDogRG9uJ3QgZmlsdGVyIG5ldyBub2Rlcy5cblx0XHRuZXdOb2RlLm1hdGNoID0gdHJ1ZTtcblx0XHQkKG5ld05vZGVbdHJlZS5zdGF0dXNDbGFzc1Byb3BOYW1lXSlcblx0XHRcdC5yZW1vdmVDbGFzcyhcImZhbmN5dHJlZS1oaWRlXCIpXG5cdFx0XHQuYWRkQ2xhc3MoXCJmYW5jeXRyZWUtbWF0Y2hcIik7XG5cblx0XHRuZXdOb2RlLm1ha2VWaXNpYmxlKC8qe25vQW5pbWF0aW9uOiB0cnVlfSovKS5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0JChuZXdOb2RlW3RyZWUuc3RhdHVzQ2xhc3NQcm9wTmFtZV0pLmFkZENsYXNzKFwiZmFuY3l0cmVlLWVkaXQtbmV3XCIpO1xuXHRcdFx0c2VsZi50cmVlLmV4dC5lZGl0LnJlbGF0ZWROb2RlID0gc2VsZjtcblx0XHRcdG5ld05vZGUuZWRpdFN0YXJ0KCk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFtleHQtZWRpdF0gQ2hlY2sgaWYgYW55IG5vZGUgaW4gdGhpcyB0cmVlICBpbiBlZGl0IG1vZGUuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlIHwgbnVsbH1cblx0ICogQGFsaWFzIEZhbmN5dHJlZSNpc0VkaXRpbmdcblx0ICogQHJlcXVpcmVzIGpxdWVyeS5mYW5jeXRyZWUuZWRpdC5qc1xuXHQgKi9cblx0JC51aS5mYW5jeXRyZWUuX0ZhbmN5dHJlZUNsYXNzLnByb3RvdHlwZS5pc0VkaXRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5leHQuZWRpdCA/IHRoaXMuZXh0LmVkaXQuY3VycmVudE5vZGUgOiBudWxsO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBbZXh0LWVkaXRdIENoZWNrIGlmIHRoaXMgbm9kZSBpcyBpbiBlZGl0IG1vZGUuXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIG5vZGUgaXMgY3VycmVudGx5IGJlZWluZyBlZGl0ZWRcblx0ICogQGFsaWFzIEZhbmN5dHJlZU5vZGUjaXNFZGl0aW5nXG5cdCAqIEByZXF1aXJlcyBqcXVlcnkuZmFuY3l0cmVlLmVkaXQuanNcblx0ICovXG5cdCQudWkuZmFuY3l0cmVlLl9GYW5jeXRyZWVOb2RlQ2xhc3MucHJvdG90eXBlLmlzRWRpdGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRyZWUuZXh0LmVkaXRcblx0XHRcdD8gdGhpcy50cmVlLmV4dC5lZGl0LmN1cnJlbnROb2RlID09PSB0aGlzXG5cdFx0XHQ6IGZhbHNlO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIEV4dGVuc2lvbiBjb2RlXG5cdCAqL1xuXHQkLnVpLmZhbmN5dHJlZS5yZWdpc3RlckV4dGVuc2lvbih7XG5cdFx0bmFtZTogXCJlZGl0XCIsXG5cdFx0dmVyc2lvbjogXCIyLjMzLjBcIixcblx0XHQvLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgZXh0ZW5zaW9uLlxuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGFkanVzdFdpZHRoT2ZzOiA0LCAvLyBudWxsOiBkb24ndCBhZGp1c3QgaW5wdXQgc2l6ZSB0byBjb250ZW50XG5cdFx0XHRhbGxvd0VtcHR5OiBmYWxzZSwgLy8gUHJldmVudCBlbXB0eSBpbnB1dFxuXHRcdFx0aW5wdXRDc3M6IHsgbWluV2lkdGg6IFwiM2VtXCIgfSxcblx0XHRcdC8vIHRyaWdnZXJDYW5jZWw6IFtcImVzY1wiLCBcInRhYlwiLCBcImNsaWNrXCJdLFxuXHRcdFx0dHJpZ2dlclN0YXJ0OiBbXCJmMlwiLCBcIm1hYytlbnRlclwiLCBcInNoaWZ0K2NsaWNrXCJdLFxuXHRcdFx0dHJpbTogdHJ1ZSwgLy8gVHJpbSB3aGl0ZXNwYWNlIGJlZm9yZSBzYXZlXG5cdFx0XHQvLyBFdmVudHM6XG5cdFx0XHRiZWZvcmVDbG9zZTogJC5ub29wLCAvLyBSZXR1cm4gZmFsc2UgdG8gcHJldmVudCBjYW5jZWwvc2F2ZSAoZGF0YS5pbnB1dCBpcyBhdmFpbGFibGUpXG5cdFx0XHRiZWZvcmVFZGl0OiAkLm5vb3AsIC8vIFJldHVybiBmYWxzZSB0byBwcmV2ZW50IGVkaXQgbW9kZVxuXHRcdFx0Y2xvc2U6ICQubm9vcCwgLy8gRWRpdG9yIHdhcyByZW1vdmVkXG5cdFx0XHRlZGl0OiAkLm5vb3AsIC8vIEVkaXRvciB3YXMgb3BlbmVkIChhdmFpbGFibGUgYXMgZGF0YS5pbnB1dClcblx0XHRcdC8vXHRcdGtleXByZXNzOiAkLm5vb3AsICAgIC8vIE5vdCB5ZXQgaW1wbGVtZW50ZWRcblx0XHRcdHNhdmU6ICQubm9vcCwgLy8gU2F2ZSBkYXRhLmlucHV0LnZhbCgpIG9yIHJldHVybiBmYWxzZSB0byBrZWVwIGVkaXRvciBvcGVuXG5cdFx0fSxcblx0XHQvLyBMb2NhbCBhdHRyaWJ1dGVzXG5cdFx0Y3VycmVudE5vZGU6IG51bGwsXG5cblx0XHR0cmVlSW5pdDogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHR2YXIgdHJlZSA9IGN0eC50cmVlO1xuXG5cdFx0XHR0aGlzLl9zdXBlckFwcGx5KGFyZ3VtZW50cyk7XG5cblx0XHRcdHRoaXMuJGNvbnRhaW5lclxuXHRcdFx0XHQuYWRkQ2xhc3MoXCJmYW5jeXRyZWUtZXh0LWVkaXRcIilcblx0XHRcdFx0Lm9uKFwiZmFuY3l0cmVlYmVmb3JldXBkYXRldmlld3BvcnRcIiwgZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcblx0XHRcdFx0XHR2YXIgZWRpdE5vZGUgPSB0cmVlLmlzRWRpdGluZygpO1xuXHRcdFx0XHRcdC8vIFdoZW4gc2Nyb2xsaW5nLCB0aGUgVFIgbWF5IGJlIHJlLXVzZWQgYnkgYW5vdGhlciBub2RlLCBzbyB0aGVcblx0XHRcdFx0XHQvLyBhY3RpdmUgY2VsbCBtYXJrZXIgYW5cblx0XHRcdFx0XHRpZiAoZWRpdE5vZGUpIHtcblx0XHRcdFx0XHRcdGVkaXROb2RlLmluZm8oXCJDYW5jZWwgZWRpdCBkdWUgdG8gc2Nyb2xsIGV2ZW50LlwiKTtcblx0XHRcdFx0XHRcdGVkaXROb2RlLmVkaXRFbmQoZmFsc2UsIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0bm9kZUNsaWNrOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdHZhciBldmVudFN0ciA9ICQudWkuZmFuY3l0cmVlLmV2ZW50VG9TdHJpbmcoY3R4Lm9yaWdpbmFsRXZlbnQpLFxuXHRcdFx0XHR0cmlnZ2VyU3RhcnQgPSBjdHgub3B0aW9ucy5lZGl0LnRyaWdnZXJTdGFydDtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRldmVudFN0ciA9PT0gXCJzaGlmdCtjbGlja1wiICYmXG5cdFx0XHRcdCQuaW5BcnJheShcInNoaWZ0K2NsaWNrXCIsIHRyaWdnZXJTdGFydCkgPj0gMFxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChjdHgub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuXHRcdFx0XHRcdGN0eC5ub2RlLmVkaXRTdGFydCgpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRldmVudFN0ciA9PT0gXCJjbGlja1wiICYmXG5cdFx0XHRcdCQuaW5BcnJheShcImNsaWNrQWN0aXZlXCIsIHRyaWdnZXJTdGFydCkgPj0gMFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIE9ubHkgd2hlbiBjbGljayB3YXMgaW5zaWRlIHRpdGxlIHRleHQgKG5vdCBheW53aGVyZSBlbHNlIGluIHRoZSByb3cpXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRjdHgubm9kZS5pc0FjdGl2ZSgpICYmXG5cdFx0XHRcdFx0IWN0eC5ub2RlLmlzRWRpdGluZygpICYmXG5cdFx0XHRcdFx0JChjdHgub3JpZ2luYWxFdmVudC50YXJnZXQpLmhhc0NsYXNzKFwiZmFuY3l0cmVlLXRpdGxlXCIpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGN0eC5ub2RlLmVkaXRTdGFydCgpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdG5vZGVEYmxjbGljazogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRpZiAoJC5pbkFycmF5KFwiZGJsY2xpY2tcIiwgY3R4Lm9wdGlvbnMuZWRpdC50cmlnZ2VyU3RhcnQpID49IDApIHtcblx0XHRcdFx0Y3R4Lm5vZGUuZWRpdFN0YXJ0KCk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlckFwcGx5KGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0XHRub2RlS2V5ZG93bjogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRzd2l0Y2ggKGN0eC5vcmlnaW5hbEV2ZW50LndoaWNoKSB7XG5cdFx0XHRcdGNhc2UgMTEzOiAvLyBbRjJdXG5cdFx0XHRcdFx0aWYgKCQuaW5BcnJheShcImYyXCIsIGN0eC5vcHRpb25zLmVkaXQudHJpZ2dlclN0YXJ0KSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRjdHgubm9kZS5lZGl0U3RhcnQoKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJC51aS5rZXlDb2RlLkVOVEVSOlxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdCQuaW5BcnJheShcIm1hYytlbnRlclwiLCBjdHgub3B0aW9ucy5lZGl0LnRyaWdnZXJTdGFydCkgPj1cblx0XHRcdFx0XHRcdFx0MCAmJlxuXHRcdFx0XHRcdFx0aXNNYWNcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGN0eC5ub2RlLmVkaXRTdGFydCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlckFwcGx5KGFyZ3VtZW50cyk7XG5cdFx0fSxcblx0fSk7XG5cdC8vIFZhbHVlIHJldHVybmVkIGJ5IGByZXF1aXJlKCdqcXVlcnkuZmFuY3l0cmVlLi4nKWBcblx0cmV0dXJuICQudWkuZmFuY3l0cmVlO1xufSk7IC8vIEVuZCBvZiBjbG9zdXJlXG4iLCIvKiFcbiAqIGpxdWVyeS5mYW5jeXRyZWUuZmlsdGVyLmpzXG4gKlxuICogUmVtb3ZlIG9yIGhpZ2hsaWdodCB0cmVlIG5vZGVzLCBiYXNlZCBvbiBhIGZpbHRlci5cbiAqIChFeHRlbnNpb24gbW9kdWxlIGZvciBqcXVlcnkuZmFuY3l0cmVlLmpzOiBodHRwczovL2dpdGh1Yi5jb20vbWFyMTAvZmFuY3l0cmVlLylcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxOSwgTWFydGluIFdlbmR0IChodHRwczovL3d3V2VuZHQuZGUpXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyMTAvZmFuY3l0cmVlL3dpa2kvTGljZW5zZUluZm9cbiAqXG4gKiBAdmVyc2lvbiAyLjMzLjBcbiAqIEBkYXRlIDIwMTktMTAtMjlUMDg6MDA6MDdaXG4gKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXCJqcXVlcnlcIiwgXCIuL2pxdWVyeS5mYW5jeXRyZWVcIl0sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHQvLyBOb2RlL0NvbW1vbkpTXG5cdFx0cmVxdWlyZShcIi4vanF1ZXJ5LmZhbmN5dHJlZVwiKTtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xuXHR9XG59KShmdW5jdGlvbigkKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIFByaXZhdGUgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcblx0ICovXG5cblx0dmFyIEtleU5vRGF0YSA9IFwiX19ub3RfZm91bmRfX1wiLFxuXHRcdGVzY2FwZUh0bWwgPSAkLnVpLmZhbmN5dHJlZS5lc2NhcGVIdG1sO1xuXG5cdGZ1bmN0aW9uIF9lc2NhcGVSZWdleChzdHIpIHtcblx0XHRyZXR1cm4gKHN0ciArIFwiXCIpLnJlcGxhY2UoLyhbLj8qK14kW1xcXVxcXFwoKXt9fC1dKS9nLCBcIlxcXFwkMVwiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dHJhY3RIdG1sVGV4dChzKSB7XG5cdFx0aWYgKHMuaW5kZXhPZihcIj5cIikgPj0gMCkge1xuXHRcdFx0cmV0dXJuICQoXCI8ZGl2Lz5cIilcblx0XHRcdFx0Lmh0bWwocylcblx0XHRcdFx0LnRleHQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHM7XG5cdH1cblxuXHQkLnVpLmZhbmN5dHJlZS5fRmFuY3l0cmVlQ2xhc3MucHJvdG90eXBlLl9hcHBseUZpbHRlckltcGwgPSBmdW5jdGlvbihcblx0XHRmaWx0ZXIsXG5cdFx0YnJhbmNoTW9kZSxcblx0XHRfb3B0c1xuXHQpIHtcblx0XHR2YXIgbWF0Y2gsXG5cdFx0XHRzdGF0dXNOb2RlLFxuXHRcdFx0cmUsXG5cdFx0XHRyZUhpZ2hsaWdodCxcblx0XHRcdHRlbXAsXG5cdFx0XHRwcmV2RW5hYmxlVXBkYXRlLFxuXHRcdFx0Y291bnQgPSAwLFxuXHRcdFx0dHJlZU9wdHMgPSB0aGlzLm9wdGlvbnMsXG5cdFx0XHRlc2NhcGVUaXRsZXMgPSB0cmVlT3B0cy5lc2NhcGVUaXRsZXMsXG5cdFx0XHRwcmV2QXV0b0NvbGxhcHNlID0gdHJlZU9wdHMuYXV0b0NvbGxhcHNlLFxuXHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCB0cmVlT3B0cy5maWx0ZXIsIF9vcHRzKSxcblx0XHRcdGhpZGVNb2RlID0gb3B0cy5tb2RlID09PSBcImhpZGVcIixcblx0XHRcdGxlYXZlc09ubHkgPSAhIW9wdHMubGVhdmVzT25seSAmJiAhYnJhbmNoTW9kZTtcblxuXHRcdC8vIERlZmF1bHQgdG8gJ21hdGNoIHRpdGxlIHN1YnN0cmluZyAobm90IGNhc2Ugc2Vuc2l0aXZlKSdcblx0XHRpZiAodHlwZW9mIGZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0aWYgKGZpbHRlciA9PT0gXCJcIikge1xuXHRcdFx0XHR0aGlzLndhcm4oXG5cdFx0XHRcdFx0XCJGYW5jeXRyZWUgcGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSBmaWx0ZXIgaXMgaGFuZGxlZCBhcyBjbGVhckZpbHRlcigpLlwiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHRoaXMuY2xlYXJGaWx0ZXIoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9wdHMuZnV6enkpIHtcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vY29kZXJldmlldy5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjM4OTkvZmFzdGVyLWphdmFzY3JpcHQtZnV6enktc3RyaW5nLW1hdGNoaW5nLWZ1bmN0aW9uLzIzOTA1IzIzOTA1XG5cdFx0XHRcdC8vIGFuZCBodHRwOi8vd3d3LnF1b3JhLmNvbS9Ib3ctaXMtdGhlLWZ1enp5LXNlYXJjaC1hbGdvcml0aG0taW4tU3VibGltZS1UZXh0LWRlc2lnbmVkXG5cdFx0XHRcdC8vIGFuZCBodHRwOi8vd3d3LmR1c3RpbmRpYXouY29tL2F1dG9jb21wbGV0ZS1mdXp6eS1tYXRjaGluZ1xuXHRcdFx0XHRtYXRjaCA9IGZpbHRlci5zcGxpdChcIlwiKS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiBhICsgXCJbXlwiICsgYiArIFwiXSpcIiArIGI7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBfZXNjYXBlUmVnZXgoZmlsdGVyKTsgLy8gbWFrZSBzdXJlIGEgJy4nIGlzIHRyZWF0ZWQgbGl0ZXJhbGx5XG5cdFx0XHR9XG5cdFx0XHRyZSA9IG5ldyBSZWdFeHAoXCIuKlwiICsgbWF0Y2ggKyBcIi4qXCIsIFwiaVwiKTtcblx0XHRcdHJlSGlnaGxpZ2h0ID0gbmV3IFJlZ0V4cChfZXNjYXBlUmVnZXgoZmlsdGVyKSwgXCJnaVwiKTtcblx0XHRcdGZpbHRlciA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0aWYgKCFub2RlLnRpdGxlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciB0ZXh0ID0gZXNjYXBlVGl0bGVzXG5cdFx0XHRcdFx0XHQ/IG5vZGUudGl0bGVcblx0XHRcdFx0XHRcdDogZXh0cmFjdEh0bWxUZXh0KG5vZGUudGl0bGUpLFxuXHRcdFx0XHRcdHJlcyA9ICEhcmUudGVzdCh0ZXh0KTtcblxuXHRcdFx0XHRpZiAocmVzICYmIG9wdHMuaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0aWYgKGVzY2FwZVRpdGxlcykge1xuXHRcdFx0XHRcdFx0Ly8gIzc0MDogd2UgbXVzdCBub3QgYXBwbHkgdGhlIG1hcmtzIHRvIGVzY2FwZWQgZW50aXR5IG5hbWVzLCBlLmcuIGAmcXVvdDtgXG5cdFx0XHRcdFx0XHQvLyBVc2Ugc29tZSBleG90aWMgY2hhcmFjdGVycyB0byBtYXJrIG1hdGNoZXM6XG5cdFx0XHRcdFx0XHR0ZW1wID0gdGV4dC5yZXBsYWNlKHJlSGlnaGxpZ2h0LCBmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBcIlxcdUZGRjdcIiArIHMgKyBcIlxcdUZGRjhcIjtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0Ly8gbm93IHdlIGNhbiBlc2NhcGUgdGhlIHRpdGxlLi4uXG5cdFx0XHRcdFx0XHRub2RlLnRpdGxlV2l0aEhpZ2hsaWdodCA9IGVzY2FwZUh0bWwodGVtcClcblx0XHRcdFx0XHRcdFx0Ly8gLi4uIGFuZCBmaW5hbGx5IGluc2VydCB0aGUgZGVzaXJlZCBgPG1hcms+YCB0YWdzXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cXHVGRkY3L2csIFwiPG1hcms+XCIpXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cXHVGRkY4L2csIFwiPC9tYXJrPlwiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS50aXRsZVdpdGhIaWdobGlnaHQgPSB0ZXh0LnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdHJlSGlnaGxpZ2h0LFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiPG1hcms+XCIgKyBzICsgXCI8L21hcms+XCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIG5vZGUuZGVidWcoXCJmaWx0ZXJcIiwgZXNjYXBlVGl0bGVzLCB0ZXh0LCBub2RlLnRpdGxlV2l0aEhpZ2hsaWdodCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpcy5lbmFibGVGaWx0ZXIgPSB0cnVlO1xuXHRcdHRoaXMubGFzdEZpbHRlckFyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRwcmV2RW5hYmxlVXBkYXRlID0gdGhpcy5lbmFibGVVcGRhdGUoZmFsc2UpO1xuXG5cdFx0dGhpcy4kZGl2LmFkZENsYXNzKFwiZmFuY3l0cmVlLWV4dC1maWx0ZXJcIik7XG5cdFx0aWYgKGhpZGVNb2RlKSB7XG5cdFx0XHR0aGlzLiRkaXYuYWRkQ2xhc3MoXCJmYW5jeXRyZWUtZXh0LWZpbHRlci1oaWRlXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLiRkaXYuYWRkQ2xhc3MoXCJmYW5jeXRyZWUtZXh0LWZpbHRlci1kaW1tXCIpO1xuXHRcdH1cblx0XHR0aGlzLiRkaXYudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcImZhbmN5dHJlZS1leHQtZmlsdGVyLWhpZGUtZXhwYW5kZXJzXCIsXG5cdFx0XHQhIW9wdHMuaGlkZUV4cGFuZGVyc1xuXHRcdCk7XG5cdFx0Ly8gUmVzZXQgY3VycmVudCBmaWx0ZXJcblx0XHR0aGlzLnJvb3ROb2RlLnN1Yk1hdGNoQ291bnQgPSAwO1xuXHRcdHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0ZGVsZXRlIG5vZGUubWF0Y2g7XG5cdFx0XHRkZWxldGUgbm9kZS50aXRsZVdpdGhIaWdobGlnaHQ7XG5cdFx0XHRub2RlLnN1Yk1hdGNoQ291bnQgPSAwO1xuXHRcdH0pO1xuXHRcdHN0YXR1c05vZGUgPSB0aGlzLmdldFJvb3ROb2RlKCkuX2ZpbmREaXJlY3RDaGlsZChLZXlOb0RhdGEpO1xuXHRcdGlmIChzdGF0dXNOb2RlKSB7XG5cdFx0XHRzdGF0dXNOb2RlLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdC8vIEFkanVzdCBub2RlLmhpZGUsIC5tYXRjaCwgYW5kIC5zdWJNYXRjaENvdW50IHByb3BlcnRpZXNcblx0XHR0cmVlT3B0cy5hdXRvQ29sbGFwc2UgPSBmYWxzZTsgLy8gIzUyOFxuXG5cdFx0dGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRpZiAobGVhdmVzT25seSAmJiBub2RlLmNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlcyA9IGZpbHRlcihub2RlKSxcblx0XHRcdFx0bWF0Y2hlZEJ5QnJhbmNoID0gZmFsc2U7XG5cblx0XHRcdGlmIChyZXMgPT09IFwic2tpcFwiKSB7XG5cdFx0XHRcdG5vZGUudmlzaXQoZnVuY3Rpb24oYykge1xuXHRcdFx0XHRcdGMubWF0Y2ggPSBmYWxzZTtcblx0XHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRcdHJldHVybiBcInNraXBcIjtcblx0XHRcdH1cblx0XHRcdGlmICghcmVzICYmIChicmFuY2hNb2RlIHx8IHJlcyA9PT0gXCJicmFuY2hcIikgJiYgbm9kZS5wYXJlbnQubWF0Y2gpIHtcblx0XHRcdFx0cmVzID0gdHJ1ZTtcblx0XHRcdFx0bWF0Y2hlZEJ5QnJhbmNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChyZXMpIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0bm9kZS5tYXRjaCA9IHRydWU7XG5cdFx0XHRcdG5vZGUudmlzaXRQYXJlbnRzKGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0XHRpZiAocCAhPT0gbm9kZSkge1xuXHRcdFx0XHRcdFx0cC5zdWJNYXRjaENvdW50ICs9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEV4cGFuZCBtYXRjaCAodW5sZXNzIHRoaXMgaXMgbm8gcmVhbCBtYXRjaCwgYnV0IG9ubHkgYSBub2RlIGluIGEgbWF0Y2hlZCBicmFuY2gpXG5cdFx0XHRcdFx0aWYgKG9wdHMuYXV0b0V4cGFuZCAmJiAhbWF0Y2hlZEJ5QnJhbmNoICYmICFwLmV4cGFuZGVkKSB7XG5cdFx0XHRcdFx0XHRwLnNldEV4cGFuZGVkKHRydWUsIHtcblx0XHRcdFx0XHRcdFx0bm9BbmltYXRpb246IHRydWUsXG5cdFx0XHRcdFx0XHRcdG5vRXZlbnRzOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRzY3JvbGxJbnRvVmlldzogZmFsc2UsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHAuX2ZpbHRlckF1dG9FeHBhbmRlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR0cmVlT3B0cy5hdXRvQ29sbGFwc2UgPSBwcmV2QXV0b0NvbGxhcHNlO1xuXG5cdFx0aWYgKGNvdW50ID09PSAwICYmIG9wdHMubm9kYXRhICYmIGhpZGVNb2RlKSB7XG5cdFx0XHRzdGF0dXNOb2RlID0gb3B0cy5ub2RhdGE7XG5cdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHN0YXR1c05vZGUpKSB7XG5cdFx0XHRcdHN0YXR1c05vZGUgPSBzdGF0dXNOb2RlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3RhdHVzTm9kZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRzdGF0dXNOb2RlID0ge307XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzdGF0dXNOb2RlID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdHN0YXR1c05vZGUgPSB7IHRpdGxlOiBzdGF0dXNOb2RlIH07XG5cdFx0XHR9XG5cdFx0XHRzdGF0dXNOb2RlID0gJC5leHRlbmQoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdGF0dXNOb2RlVHlwZTogXCJub2RhdGFcIixcblx0XHRcdFx0XHRrZXk6IEtleU5vRGF0YSxcblx0XHRcdFx0XHR0aXRsZTogdGhpcy5vcHRpb25zLnN0cmluZ3Mubm9EYXRhLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdGF0dXNOb2RlXG5cdFx0XHQpO1xuXG5cdFx0XHR0aGlzLmdldFJvb3ROb2RlKCkuYWRkTm9kZShzdGF0dXNOb2RlKS5tYXRjaCA9IHRydWU7XG5cdFx0fVxuXHRcdC8vIFJlZHJhdyB3aG9sZSB0cmVlXG5cdFx0dGhpcy5fY2FsbEhvb2soXCJ0cmVlU3RydWN0dXJlQ2hhbmdlZFwiLCB0aGlzLCBcImFwcGx5RmlsdGVyXCIpO1xuXHRcdC8vIHRoaXMucmVuZGVyKCk7XG5cdFx0dGhpcy5lbmFibGVVcGRhdGUocHJldkVuYWJsZVVwZGF0ZSk7XG5cdFx0cmV0dXJuIGNvdW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBbZXh0LWZpbHRlcl0gRGltbSBvciBoaWRlIG5vZGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uIHwgc3RyaW5nfSBmaWx0ZXJcblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0cz17YXV0b0V4cGFuZDogZmFsc2UsIGxlYXZlc09ubHk6IGZhbHNlfV1cblx0ICogQHJldHVybnMge2ludGVnZXJ9IGNvdW50XG5cdCAqIEBhbGlhcyBGYW5jeXRyZWUjZmlsdGVyTm9kZXNcblx0ICogQHJlcXVpcmVzIGpxdWVyeS5mYW5jeXRyZWUuZmlsdGVyLmpzXG5cdCAqL1xuXHQkLnVpLmZhbmN5dHJlZS5fRmFuY3l0cmVlQ2xhc3MucHJvdG90eXBlLmZpbHRlck5vZGVzID0gZnVuY3Rpb24oXG5cdFx0ZmlsdGVyLFxuXHRcdG9wdHNcblx0KSB7XG5cdFx0aWYgKHR5cGVvZiBvcHRzID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0b3B0cyA9IHsgbGVhdmVzT25seTogb3B0cyB9O1xuXHRcdFx0dGhpcy53YXJuKFxuXHRcdFx0XHRcIkZhbmN5dHJlZS5maWx0ZXJOb2RlcygpIGxlYXZlc09ubHkgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgc2luY2UgMi45LjAgLyAyMDE1LTA0LTE5LiBVc2Ugb3B0cy5sZWF2ZXNPbmx5IGluc3RlYWQuXCJcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9hcHBseUZpbHRlckltcGwoZmlsdGVyLCBmYWxzZSwgb3B0cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFtleHQtZmlsdGVyXSBEaW1tIG9yIGhpZGUgd2hvbGUgYnJhbmNoZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb24gfCBzdHJpbmd9IGZpbHRlclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzPXthdXRvRXhwYW5kOiBmYWxzZX1dXG5cdCAqIEByZXR1cm5zIHtpbnRlZ2VyfSBjb3VudFxuXHQgKiBAYWxpYXMgRmFuY3l0cmVlI2ZpbHRlckJyYW5jaGVzXG5cdCAqIEByZXF1aXJlcyBqcXVlcnkuZmFuY3l0cmVlLmZpbHRlci5qc1xuXHQgKi9cblx0JC51aS5mYW5jeXRyZWUuX0ZhbmN5dHJlZUNsYXNzLnByb3RvdHlwZS5maWx0ZXJCcmFuY2hlcyA9IGZ1bmN0aW9uKFxuXHRcdGZpbHRlcixcblx0XHRvcHRzXG5cdCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseUZpbHRlckltcGwoZmlsdGVyLCB0cnVlLCBvcHRzKTtcblx0fTtcblxuXHQvKipcblx0ICogW2V4dC1maWx0ZXJdIFJlc2V0IHRoZSBmaWx0ZXIuXG5cdCAqXG5cdCAqIEBhbGlhcyBGYW5jeXRyZWUjY2xlYXJGaWx0ZXJcblx0ICogQHJlcXVpcmVzIGpxdWVyeS5mYW5jeXRyZWUuZmlsdGVyLmpzXG5cdCAqL1xuXHQkLnVpLmZhbmN5dHJlZS5fRmFuY3l0cmVlQ2xhc3MucHJvdG90eXBlLmNsZWFyRmlsdGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyICR0aXRsZSxcblx0XHRcdHN0YXR1c05vZGUgPSB0aGlzLmdldFJvb3ROb2RlKCkuX2ZpbmREaXJlY3RDaGlsZChLZXlOb0RhdGEpLFxuXHRcdFx0ZXNjYXBlVGl0bGVzID0gdGhpcy5vcHRpb25zLmVzY2FwZVRpdGxlcyxcblx0XHRcdGVuaGFuY2VUaXRsZSA9IHRoaXMub3B0aW9ucy5lbmhhbmNlVGl0bGUsXG5cdFx0XHRwcmV2RW5hYmxlVXBkYXRlID0gdGhpcy5lbmFibGVVcGRhdGUoZmFsc2UpO1xuXG5cdFx0aWYgKHN0YXR1c05vZGUpIHtcblx0XHRcdHN0YXR1c05vZGUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdC8vIHdlIGFsc28gY291bnRlZCByb290IG5vZGUncyBzdWJNYXRjaENvdW50XG5cdFx0ZGVsZXRlIHRoaXMucm9vdE5vZGUubWF0Y2g7XG5cdFx0ZGVsZXRlIHRoaXMucm9vdE5vZGUuc3ViTWF0Y2hDb3VudDtcblxuXHRcdHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0aWYgKG5vZGUubWF0Y2ggJiYgbm9kZS5zcGFuKSB7XG5cdFx0XHRcdC8vICM0OTEsICM2MDFcblx0XHRcdFx0JHRpdGxlID0gJChub2RlLnNwYW4pLmZpbmQoXCI+c3Bhbi5mYW5jeXRyZWUtdGl0bGVcIik7XG5cdFx0XHRcdGlmIChlc2NhcGVUaXRsZXMpIHtcblx0XHRcdFx0XHQkdGl0bGUudGV4dChub2RlLnRpdGxlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkdGl0bGUuaHRtbChub2RlLnRpdGxlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5oYW5jZVRpdGxlKSB7XG5cdFx0XHRcdFx0ZW5oYW5jZVRpdGxlKFxuXHRcdFx0XHRcdFx0eyB0eXBlOiBcImVuaGFuY2VUaXRsZVwiIH0sXG5cdFx0XHRcdFx0XHR7IG5vZGU6IG5vZGUsICR0aXRsZTogJHRpdGxlIH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgbm9kZS5tYXRjaDtcblx0XHRcdGRlbGV0ZSBub2RlLnN1Yk1hdGNoQ291bnQ7XG5cdFx0XHRkZWxldGUgbm9kZS50aXRsZVdpdGhIaWdobGlnaHQ7XG5cdFx0XHRpZiAobm9kZS4kc3ViTWF0Y2hCYWRnZSkge1xuXHRcdFx0XHRub2RlLiRzdWJNYXRjaEJhZGdlLnJlbW92ZSgpO1xuXHRcdFx0XHRkZWxldGUgbm9kZS4kc3ViTWF0Y2hCYWRnZTtcblx0XHRcdH1cblx0XHRcdGlmIChub2RlLl9maWx0ZXJBdXRvRXhwYW5kZWQgJiYgbm9kZS5leHBhbmRlZCkge1xuXHRcdFx0XHRub2RlLnNldEV4cGFuZGVkKGZhbHNlLCB7XG5cdFx0XHRcdFx0bm9BbmltYXRpb246IHRydWUsXG5cdFx0XHRcdFx0bm9FdmVudHM6IHRydWUsXG5cdFx0XHRcdFx0c2Nyb2xsSW50b1ZpZXc6IGZhbHNlLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSBub2RlLl9maWx0ZXJBdXRvRXhwYW5kZWQ7XG5cdFx0fSk7XG5cdFx0dGhpcy5lbmFibGVGaWx0ZXIgPSBmYWxzZTtcblx0XHR0aGlzLmxhc3RGaWx0ZXJBcmdzID0gbnVsbDtcblx0XHR0aGlzLiRkaXYucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcImZhbmN5dHJlZS1leHQtZmlsdGVyIGZhbmN5dHJlZS1leHQtZmlsdGVyLWRpbW0gZmFuY3l0cmVlLWV4dC1maWx0ZXItaGlkZVwiXG5cdFx0KTtcblx0XHR0aGlzLl9jYWxsSG9vayhcInRyZWVTdHJ1Y3R1cmVDaGFuZ2VkXCIsIHRoaXMsIFwiY2xlYXJGaWx0ZXJcIik7XG5cdFx0Ly8gdGhpcy5yZW5kZXIoKTtcblx0XHR0aGlzLmVuYWJsZVVwZGF0ZShwcmV2RW5hYmxlVXBkYXRlKTtcblx0fTtcblxuXHQvKipcblx0ICogW2V4dC1maWx0ZXJdIFJldHVybiB0cnVlIGlmIGEgZmlsdGVyIGlzIGN1cnJlbnRseSBhcHBsaWVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICogQGFsaWFzIEZhbmN5dHJlZSNpc0ZpbHRlckFjdGl2ZVxuXHQgKiBAcmVxdWlyZXMganF1ZXJ5LmZhbmN5dHJlZS5maWx0ZXIuanNcblx0ICogQHNpbmNlIDIuMTNcblx0ICovXG5cdCQudWkuZmFuY3l0cmVlLl9GYW5jeXRyZWVDbGFzcy5wcm90b3R5cGUuaXNGaWx0ZXJBY3RpdmUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmVuYWJsZUZpbHRlcjtcblx0fTtcblxuXHQvKipcblx0ICogW2V4dC1maWx0ZXJdIFJldHVybiB0cnVlIGlmIHRoaXMgbm9kZSBpcyBtYXRjaGVkIGJ5IGN1cnJlbnQgZmlsdGVyIChvciBubyBmaWx0ZXIgaXMgYWN0aXZlKS5cblx0ICpcblx0ICogQHJldHVybnMge0Jvb2xlYW59XG5cdCAqIEBhbGlhcyBGYW5jeXRyZWVOb2RlI2lzTWF0Y2hlZFxuXHQgKiBAcmVxdWlyZXMganF1ZXJ5LmZhbmN5dHJlZS5maWx0ZXIuanNcblx0ICogQHNpbmNlIDIuMTNcblx0ICovXG5cdCQudWkuZmFuY3l0cmVlLl9GYW5jeXRyZWVOb2RlQ2xhc3MucHJvdG90eXBlLmlzTWF0Y2hlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMudHJlZS5lbmFibGVGaWx0ZXIgJiYgIXRoaXMubWF0Y2gpO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIEV4dGVuc2lvbiBjb2RlXG5cdCAqL1xuXHQkLnVpLmZhbmN5dHJlZS5yZWdpc3RlckV4dGVuc2lvbih7XG5cdFx0bmFtZTogXCJmaWx0ZXJcIixcblx0XHR2ZXJzaW9uOiBcIjIuMzMuMFwiLFxuXHRcdC8vIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhpcyBleHRlbnNpb24uXG5cdFx0b3B0aW9uczoge1xuXHRcdFx0YXV0b0FwcGx5OiB0cnVlLCAvLyBSZS1hcHBseSBsYXN0IGZpbHRlciBpZiBsYXp5IGRhdGEgaXMgbG9hZGVkXG5cdFx0XHRhdXRvRXhwYW5kOiBmYWxzZSwgLy8gRXhwYW5kIGFsbCBicmFuY2hlcyB0aGF0IGNvbnRhaW4gbWF0Y2hlcyB3aGlsZSBmaWx0ZXJlZFxuXHRcdFx0Y291bnRlcjogdHJ1ZSwgLy8gU2hvdyBhIGJhZGdlIHdpdGggbnVtYmVyIG9mIG1hdGNoaW5nIGNoaWxkIG5vZGVzIG5lYXIgcGFyZW50IGljb25zXG5cdFx0XHRmdXp6eTogZmFsc2UsIC8vIE1hdGNoIHNpbmdsZSBjaGFyYWN0ZXJzIGluIG9yZGVyLCBlLmcuICdmYicgd2lsbCBtYXRjaCAnRm9vQmFyJ1xuXHRcdFx0aGlkZUV4cGFuZGVkQ291bnRlcjogdHJ1ZSwgLy8gSGlkZSBjb3VudGVyIGJhZGdlIGlmIHBhcmVudCBpcyBleHBhbmRlZFxuXHRcdFx0aGlkZUV4cGFuZGVyczogZmFsc2UsIC8vIEhpZGUgZXhwYW5kZXJzIGlmIGFsbCBjaGlsZCBub2RlcyBhcmUgaGlkZGVuIGJ5IGZpbHRlclxuXHRcdFx0aGlnaGxpZ2h0OiB0cnVlLCAvLyBIaWdobGlnaHQgbWF0Y2hlcyBieSB3cmFwcGluZyBpbnNpZGUgPG1hcms+IHRhZ3Ncblx0XHRcdGxlYXZlc09ubHk6IGZhbHNlLCAvLyBNYXRjaCBlbmQgbm9kZXMgb25seVxuXHRcdFx0bm9kYXRhOiB0cnVlLCAvLyBEaXNwbGF5IGEgJ25vIGRhdGEnIHN0YXR1cyBub2RlIGlmIHJlc3VsdCBpcyBlbXB0eVxuXHRcdFx0bW9kZTogXCJkaW1tXCIsIC8vIEdyYXlvdXQgdW5tYXRjaGVkIG5vZGVzIChwYXNzIFwiaGlkZVwiIHRvIHJlbW92ZSB1bm1hdGNoZWQgbm9kZSBpbnN0ZWFkKVxuXHRcdH0sXG5cdFx0bm9kZUxvYWRDaGlsZHJlbjogZnVuY3Rpb24oY3R4LCBzb3VyY2UpIHtcblx0XHRcdHZhciB0cmVlID0gY3R4LnRyZWU7XG5cblx0XHRcdHJldHVybiB0aGlzLl9zdXBlckFwcGx5KGFyZ3VtZW50cykuZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRyZWUuZW5hYmxlRmlsdGVyICYmXG5cdFx0XHRcdFx0dHJlZS5sYXN0RmlsdGVyQXJncyAmJlxuXHRcdFx0XHRcdGN0eC5vcHRpb25zLmZpbHRlci5hdXRvQXBwbHlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dHJlZS5fYXBwbHlGaWx0ZXJJbXBsLmFwcGx5KHRyZWUsIHRyZWUubGFzdEZpbHRlckFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdG5vZGVTZXRFeHBhbmRlZDogZnVuY3Rpb24oY3R4LCBmbGFnLCBjYWxsT3B0cykge1xuXHRcdFx0dmFyIG5vZGUgPSBjdHgubm9kZTtcblxuXHRcdFx0ZGVsZXRlIG5vZGUuX2ZpbHRlckF1dG9FeHBhbmRlZDtcblx0XHRcdC8vIE1ha2Ugc3VyZSBjb3VudGVyIGJhZGdlIGlzIGRpc3BsYXllZCBhZ2Fpbiwgd2hlbiBub2RlIGlzIGJlZWluZyBjb2xsYXBzZWRcblx0XHRcdGlmIChcblx0XHRcdFx0IWZsYWcgJiZcblx0XHRcdFx0Y3R4Lm9wdGlvbnMuZmlsdGVyLmhpZGVFeHBhbmRlZENvdW50ZXIgJiZcblx0XHRcdFx0bm9kZS4kc3ViTWF0Y2hCYWRnZVxuXHRcdFx0KSB7XG5cdFx0XHRcdG5vZGUuJHN1Yk1hdGNoQmFkZ2Uuc2hvdygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKTtcblx0XHR9LFxuXHRcdG5vZGVSZW5kZXJTdGF0dXM6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0Ly8gU2V0IGNsYXNzZXMgZm9yIGN1cnJlbnQgc3RhdHVzXG5cdFx0XHR2YXIgcmVzLFxuXHRcdFx0XHRub2RlID0gY3R4Lm5vZGUsXG5cdFx0XHRcdHRyZWUgPSBjdHgudHJlZSxcblx0XHRcdFx0b3B0cyA9IGN0eC5vcHRpb25zLmZpbHRlcixcblx0XHRcdFx0JHRpdGxlID0gJChub2RlLnNwYW4pLmZpbmQoXCJzcGFuLmZhbmN5dHJlZS10aXRsZVwiKSxcblx0XHRcdFx0JHNwYW4gPSAkKG5vZGVbdHJlZS5zdGF0dXNDbGFzc1Byb3BOYW1lXSksXG5cdFx0XHRcdGVuaGFuY2VUaXRsZSA9IGN0eC5vcHRpb25zLmVuaGFuY2VUaXRsZSxcblx0XHRcdFx0ZXNjYXBlVGl0bGVzID0gY3R4Lm9wdGlvbnMuZXNjYXBlVGl0bGVzO1xuXG5cdFx0XHRyZXMgPSB0aGlzLl9zdXBlcihjdHgpO1xuXHRcdFx0Ly8gbm90aGluZyB0byBkbywgaWYgbm9kZSB3YXMgbm90IHlldCByZW5kZXJlZFxuXHRcdFx0aWYgKCEkc3Bhbi5sZW5ndGggfHwgIXRyZWUuZW5hYmxlRmlsdGVyKSB7XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0XHQkc3BhblxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoXCJmYW5jeXRyZWUtbWF0Y2hcIiwgISFub2RlLm1hdGNoKVxuXHRcdFx0XHQudG9nZ2xlQ2xhc3MoXCJmYW5jeXRyZWUtc3VibWF0Y2hcIiwgISFub2RlLnN1Yk1hdGNoQ291bnQpXG5cdFx0XHRcdC50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHRcImZhbmN5dHJlZS1oaWRlXCIsXG5cdFx0XHRcdFx0IShub2RlLm1hdGNoIHx8IG5vZGUuc3ViTWF0Y2hDb3VudClcblx0XHRcdFx0KTtcblx0XHRcdC8vIEFkZC91cGRhdGUgY291bnRlciBiYWRnZVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRvcHRzLmNvdW50ZXIgJiZcblx0XHRcdFx0bm9kZS5zdWJNYXRjaENvdW50ICYmXG5cdFx0XHRcdCghbm9kZS5pc0V4cGFuZGVkKCkgfHwgIW9wdHMuaGlkZUV4cGFuZGVkQ291bnRlcilcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAoIW5vZGUuJHN1Yk1hdGNoQmFkZ2UpIHtcblx0XHRcdFx0XHRub2RlLiRzdWJNYXRjaEJhZGdlID0gJChcblx0XHRcdFx0XHRcdFwiPHNwYW4gY2xhc3M9J2ZhbmN5dHJlZS1jaGlsZGNvdW50ZXInLz5cIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0JChcblx0XHRcdFx0XHRcdFwic3Bhbi5mYW5jeXRyZWUtaWNvbiwgc3Bhbi5mYW5jeXRyZWUtY3VzdG9tLWljb25cIixcblx0XHRcdFx0XHRcdG5vZGUuc3BhblxuXHRcdFx0XHRcdCkuYXBwZW5kKG5vZGUuJHN1Yk1hdGNoQmFkZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuJHN1Yk1hdGNoQmFkZ2Uuc2hvdygpLnRleHQobm9kZS5zdWJNYXRjaENvdW50KTtcblx0XHRcdH0gZWxzZSBpZiAobm9kZS4kc3ViTWF0Y2hCYWRnZSkge1xuXHRcdFx0XHRub2RlLiRzdWJNYXRjaEJhZGdlLmhpZGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vZGUuZGVidWcoXCJub2RlUmVuZGVyU3RhdHVzXCIsIG5vZGUudGl0bGVXaXRoSGlnaGxpZ2h0LCBub2RlLnRpdGxlKVxuXHRcdFx0Ly8gIzYwMTogYWxzbyBjaGVjayBmb3IgJHRpdGxlLmxlbmd0aCwgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlclxuXHRcdFx0Ly8gaWYgbm9kZS5zcGFuIGlzIG51bGwgKGkuZS4gbm90IHJlbmRlcmVkKVxuXHRcdFx0aWYgKG5vZGUuc3BhbiAmJiAoIW5vZGUuaXNFZGl0aW5nIHx8ICFub2RlLmlzRWRpdGluZy5jYWxsKG5vZGUpKSkge1xuXHRcdFx0XHRpZiAobm9kZS50aXRsZVdpdGhIaWdobGlnaHQpIHtcblx0XHRcdFx0XHQkdGl0bGUuaHRtbChub2RlLnRpdGxlV2l0aEhpZ2hsaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXNjYXBlVGl0bGVzKSB7XG5cdFx0XHRcdFx0JHRpdGxlLnRleHQobm9kZS50aXRsZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JHRpdGxlLmh0bWwobm9kZS50aXRsZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuaGFuY2VUaXRsZSkge1xuXHRcdFx0XHRcdGVuaGFuY2VUaXRsZShcblx0XHRcdFx0XHRcdHsgdHlwZTogXCJlbmhhbmNlVGl0bGVcIiB9LFxuXHRcdFx0XHRcdFx0eyBub2RlOiBub2RlLCAkdGl0bGU6ICR0aXRsZSB9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXHR9KTtcblx0Ly8gVmFsdWUgcmV0dXJuZWQgYnkgYHJlcXVpcmUoJ2pxdWVyeS5mYW5jeXRyZWUuLicpYFxuXHRyZXR1cm4gJC51aS5mYW5jeXRyZWU7XG59KTsgLy8gRW5kIG9mIGNsb3N1cmVcbiIsIi8qIVxuICoganF1ZXJ5LmZhbmN5dHJlZS5nbHlwaC5qc1xuICpcbiAqIFVzZSBnbHlwaC1mb250cywgbGlnYXR1cmUtZm9udHMsIG9yIFNWRyBpY29ucyBpbnN0ZWFkIG9mIGljb24gc3ByaXRlcy5cbiAqIChFeHRlbnNpb24gbW9kdWxlIGZvciBqcXVlcnkuZmFuY3l0cmVlLmpzOiBodHRwczovL2dpdGh1Yi5jb20vbWFyMTAvZmFuY3l0cmVlLylcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxOSwgTWFydGluIFdlbmR0IChodHRwczovL3d3V2VuZHQuZGUpXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyMTAvZmFuY3l0cmVlL3dpa2kvTGljZW5zZUluZm9cbiAqXG4gKiBAdmVyc2lvbiAyLjMzLjBcbiAqIEBkYXRlIDIwMTktMTAtMjlUMDg6MDA6MDdaXG4gKi9cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXCJqcXVlcnlcIiwgXCIuL2pxdWVyeS5mYW5jeXRyZWVcIl0sIGZhY3RvcnkpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHQvLyBOb2RlL0NvbW1vbkpTXG5cdFx0cmVxdWlyZShcIi4vanF1ZXJ5LmZhbmN5dHJlZVwiKTtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xuXHR9XG59KShmdW5jdGlvbigkKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0ICogUHJpdmF0ZSBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlc1xuXHQgKi9cblxuXHR2YXIgRlQgPSAkLnVpLmZhbmN5dHJlZSxcblx0XHRQUkVTRVRTID0ge1xuXHRcdFx0YXdlc29tZTM6IHtcblx0XHRcdFx0Ly8gT3V0ZGF0ZWQhXG5cdFx0XHRcdF9hZGRDbGFzczogXCJcIixcblx0XHRcdFx0Y2hlY2tib3g6IFwiaWNvbi1jaGVjay1lbXB0eVwiLFxuXHRcdFx0XHRjaGVja2JveFNlbGVjdGVkOiBcImljb24tY2hlY2tcIixcblx0XHRcdFx0Y2hlY2tib3hVbmtub3duOiBcImljb24tY2hlY2sgaWNvbi1tdXRlZFwiLFxuXHRcdFx0XHRkcmFnSGVscGVyOiBcImljb24tY2FyZXQtcmlnaHRcIixcblx0XHRcdFx0ZHJvcE1hcmtlcjogXCJpY29uLWNhcmV0LXJpZ2h0XCIsXG5cdFx0XHRcdGVycm9yOiBcImljb24tZXhjbGFtYXRpb24tc2lnblwiLFxuXHRcdFx0XHRleHBhbmRlckNsb3NlZDogXCJpY29uLWNhcmV0LXJpZ2h0XCIsXG5cdFx0XHRcdGV4cGFuZGVyTGF6eTogXCJpY29uLWFuZ2xlLXJpZ2h0XCIsXG5cdFx0XHRcdGV4cGFuZGVyT3BlbjogXCJpY29uLWNhcmV0LWRvd25cIixcblx0XHRcdFx0bG9hZGluZzogXCJpY29uLXJlZnJlc2ggaWNvbi1zcGluXCIsXG5cdFx0XHRcdG5vZGF0YTogXCJpY29uLW1laFwiLFxuXHRcdFx0XHRub0V4cGFuZGVyOiBcIlwiLFxuXHRcdFx0XHRyYWRpbzogXCJpY29uLWNpcmNsZS1ibGFua1wiLFxuXHRcdFx0XHRyYWRpb1NlbGVjdGVkOiBcImljb24tY2lyY2xlXCIsXG5cdFx0XHRcdC8vIHJhZGlvVW5rbm93bjogXCJpY29uLWNpcmNsZSBpY29uLW11dGVkXCIsXG5cdFx0XHRcdC8vIERlZmF1bHQgbm9kZSBpY29ucy5cblx0XHRcdFx0Ly8gKFVzZSB0cmVlLm9wdGlvbnMuaWNvbiBjYWxsYmFjayB0byBkZWZpbmUgY3VzdG9tIGljb25zIGJhc2VkIG9uIG5vZGUgZGF0YSlcblx0XHRcdFx0ZG9jOiBcImljb24tZmlsZS1hbHRcIixcblx0XHRcdFx0ZG9jT3BlbjogXCJpY29uLWZpbGUtYWx0XCIsXG5cdFx0XHRcdGZvbGRlcjogXCJpY29uLWZvbGRlci1jbG9zZS1hbHRcIixcblx0XHRcdFx0Zm9sZGVyT3BlbjogXCJpY29uLWZvbGRlci1vcGVuLWFsdFwiLFxuXHRcdFx0fSxcblx0XHRcdGF3ZXNvbWU0OiB7XG5cdFx0XHRcdF9hZGRDbGFzczogXCJmYVwiLFxuXHRcdFx0XHRjaGVja2JveDogXCJmYS1zcXVhcmUtb1wiLFxuXHRcdFx0XHRjaGVja2JveFNlbGVjdGVkOiBcImZhLWNoZWNrLXNxdWFyZS1vXCIsXG5cdFx0XHRcdGNoZWNrYm94VW5rbm93bjogXCJmYS1zcXVhcmUgZmFuY3l0cmVlLWhlbHBlci1pbmRldGVybWluYXRlLWNiXCIsXG5cdFx0XHRcdGRyYWdIZWxwZXI6IFwiZmEtYXJyb3ctcmlnaHRcIixcblx0XHRcdFx0ZHJvcE1hcmtlcjogXCJmYS1sb25nLWFycm93LXJpZ2h0XCIsXG5cdFx0XHRcdGVycm9yOiBcImZhLXdhcm5pbmdcIixcblx0XHRcdFx0ZXhwYW5kZXJDbG9zZWQ6IFwiZmEtY2FyZXQtcmlnaHRcIixcblx0XHRcdFx0ZXhwYW5kZXJMYXp5OiBcImZhLWFuZ2xlLXJpZ2h0XCIsXG5cdFx0XHRcdGV4cGFuZGVyT3BlbjogXCJmYS1jYXJldC1kb3duXCIsXG5cdFx0XHRcdC8vIFdlIG1heSBwcmV2ZW50IHdvYmJsaW5nIHJvdGF0aW9ucyBvbiBGRiBieSBjcmVhdGluZyBhIHNlcGFyYXRlIHN1YiBlbGVtZW50OlxuXHRcdFx0XHRsb2FkaW5nOiB7IGh0bWw6IFwiPHNwYW4gY2xhc3M9J2ZhIGZhLXNwaW5uZXIgZmEtcHVsc2UnIC8+XCIgfSxcblx0XHRcdFx0bm9kYXRhOiBcImZhLW1laC1vXCIsXG5cdFx0XHRcdG5vRXhwYW5kZXI6IFwiXCIsXG5cdFx0XHRcdHJhZGlvOiBcImZhLWNpcmNsZS10aGluXCIsIC8vIFwiZmEtY2lyY2xlLW9cIlxuXHRcdFx0XHRyYWRpb1NlbGVjdGVkOiBcImZhLWNpcmNsZVwiLFxuXHRcdFx0XHQvLyByYWRpb1Vua25vd246IFwiZmEtZG90LWNpcmNsZS1vXCIsXG5cdFx0XHRcdC8vIERlZmF1bHQgbm9kZSBpY29ucy5cblx0XHRcdFx0Ly8gKFVzZSB0cmVlLm9wdGlvbnMuaWNvbiBjYWxsYmFjayB0byBkZWZpbmUgY3VzdG9tIGljb25zIGJhc2VkIG9uIG5vZGUgZGF0YSlcblx0XHRcdFx0ZG9jOiBcImZhLWZpbGUtb1wiLFxuXHRcdFx0XHRkb2NPcGVuOiBcImZhLWZpbGUtb1wiLFxuXHRcdFx0XHRmb2xkZXI6IFwiZmEtZm9sZGVyLW9cIixcblx0XHRcdFx0Zm9sZGVyT3BlbjogXCJmYS1mb2xkZXItb3Blbi1vXCIsXG5cdFx0XHR9LFxuXHRcdFx0YXdlc29tZTU6IHtcblx0XHRcdFx0Ly8gZm9udGF3ZXNvbWUgNSBoYXZlIHNldmVyYWwgZGlmZmVyZW50IGJhc2UgY2xhc3Nlc1xuXHRcdFx0XHQvLyBcImZhciwgZmFzLCBmYWwgYW5kIGZhYlwiIFRoZSByZW5kZXJlZCBzdmcgcHV0cyB0aGF0IHByZWZpeFxuXHRcdFx0XHQvLyBpbiBhIGRpZmZlcmVudCBsb2NhdGlvbiBzbyB3ZSBoYXZlIHRvIGtlZXAgdGhlbSBzZXBhcmF0ZSBoZXJlXG5cdFx0XHRcdF9hZGRDbGFzczogXCJcIixcblx0XHRcdFx0Y2hlY2tib3g6IFwiZmFyIGZhLXNxdWFyZVwiLFxuXHRcdFx0XHRjaGVja2JveFNlbGVjdGVkOiBcImZhciBmYS1jaGVjay1zcXVhcmVcIixcblx0XHRcdFx0Ly8gY2hlY2tib3hVbmtub3duOiBcImZhciBmYS13aW5kb3ctY2xvc2VcIixcblx0XHRcdFx0Y2hlY2tib3hVbmtub3duOlxuXHRcdFx0XHRcdFwiZmFzIGZhLXNxdWFyZSBmYW5jeXRyZWUtaGVscGVyLWluZGV0ZXJtaW5hdGUtY2JcIixcblx0XHRcdFx0cmFkaW86IFwiZmFyIGZhLWNpcmNsZVwiLFxuXHRcdFx0XHRyYWRpb1NlbGVjdGVkOiBcImZhcyBmYS1jaXJjbGVcIixcblx0XHRcdFx0cmFkaW9Vbmtub3duOiBcImZhciBmYS1kb3QtY2lyY2xlXCIsXG5cdFx0XHRcdGRyYWdIZWxwZXI6IFwiZmFzIGZhLWFycm93LXJpZ2h0XCIsXG5cdFx0XHRcdGRyb3BNYXJrZXI6IFwiZmFzIGZhLWxvbmctYXJyb3ctYWx0LXJpZ2h0XCIsXG5cdFx0XHRcdGVycm9yOiBcImZhcyBmYS1leGNsYW1hdGlvbi10cmlhbmdsZVwiLFxuXHRcdFx0XHRleHBhbmRlckNsb3NlZDogXCJmYXMgZmEtY2FyZXQtcmlnaHRcIixcblx0XHRcdFx0ZXhwYW5kZXJMYXp5OiBcImZhcyBmYS1hbmdsZS1yaWdodFwiLFxuXHRcdFx0XHRleHBhbmRlck9wZW46IFwiZmFzIGZhLWNhcmV0LWRvd25cIixcblx0XHRcdFx0bG9hZGluZzogXCJmYXMgZmEtc3Bpbm5lciBmYS1wdWxzZVwiLFxuXHRcdFx0XHRub2RhdGE6IFwiZmFyIGZhLW1laFwiLFxuXHRcdFx0XHRub0V4cGFuZGVyOiBcIlwiLFxuXHRcdFx0XHQvLyBEZWZhdWx0IG5vZGUgaWNvbnMuXG5cdFx0XHRcdC8vIChVc2UgdHJlZS5vcHRpb25zLmljb24gY2FsbGJhY2sgdG8gZGVmaW5lIGN1c3RvbSBpY29ucyBiYXNlZCBvbiBub2RlIGRhdGEpXG5cdFx0XHRcdGRvYzogXCJmYXIgZmEtZmlsZVwiLFxuXHRcdFx0XHRkb2NPcGVuOiBcImZhciBmYS1maWxlXCIsXG5cdFx0XHRcdGZvbGRlcjogXCJmYXIgZmEtZm9sZGVyXCIsXG5cdFx0XHRcdGZvbGRlck9wZW46IFwiZmFyIGZhLWZvbGRlci1vcGVuXCIsXG5cdFx0XHR9LFxuXHRcdFx0Ym9vdHN0cmFwMzoge1xuXHRcdFx0XHRfYWRkQ2xhc3M6IFwiZ2x5cGhpY29uXCIsXG5cdFx0XHRcdGNoZWNrYm94OiBcImdseXBoaWNvbi11bmNoZWNrZWRcIixcblx0XHRcdFx0Y2hlY2tib3hTZWxlY3RlZDogXCJnbHlwaGljb24tY2hlY2tcIixcblx0XHRcdFx0Y2hlY2tib3hVbmtub3duOlxuXHRcdFx0XHRcdFwiZ2x5cGhpY29uLWV4cGFuZCBmYW5jeXRyZWUtaGVscGVyLWluZGV0ZXJtaW5hdGUtY2JcIiwgLy8gXCJnbHlwaGljb24tc2hhcmVcIixcblx0XHRcdFx0ZHJhZ0hlbHBlcjogXCJnbHlwaGljb24tcGxheVwiLFxuXHRcdFx0XHRkcm9wTWFya2VyOiBcImdseXBoaWNvbi1hcnJvdy1yaWdodFwiLFxuXHRcdFx0XHRlcnJvcjogXCJnbHlwaGljb24td2FybmluZy1zaWduXCIsXG5cdFx0XHRcdGV4cGFuZGVyQ2xvc2VkOiBcImdseXBoaWNvbi1tZW51LXJpZ2h0XCIsIC8vIGdseXBoaWNvbi1wbHVzLXNpZ25cblx0XHRcdFx0ZXhwYW5kZXJMYXp5OiBcImdseXBoaWNvbi1tZW51LXJpZ2h0XCIsIC8vIGdseXBoaWNvbi1wbHVzLXNpZ25cblx0XHRcdFx0ZXhwYW5kZXJPcGVuOiBcImdseXBoaWNvbi1tZW51LWRvd25cIiwgLy8gZ2x5cGhpY29uLW1pbnVzLXNpZ25cblx0XHRcdFx0bG9hZGluZzogXCJnbHlwaGljb24tcmVmcmVzaCBmYW5jeXRyZWUtaGVscGVyLXNwaW5cIixcblx0XHRcdFx0bm9kYXRhOiBcImdseXBoaWNvbi1pbmZvLXNpZ25cIixcblx0XHRcdFx0bm9FeHBhbmRlcjogXCJcIixcblx0XHRcdFx0cmFkaW86IFwiZ2x5cGhpY29uLXJlbW92ZS1jaXJjbGVcIiwgLy8gXCJnbHlwaGljb24tdW5jaGVja2VkXCIsXG5cdFx0XHRcdHJhZGlvU2VsZWN0ZWQ6IFwiZ2x5cGhpY29uLW9rLWNpcmNsZVwiLCAvLyBcImdseXBoaWNvbi1jaGVja1wiLFxuXHRcdFx0XHQvLyByYWRpb1Vua25vd246IFwiZ2x5cGhpY29uLWJhbi1jaXJjbGVcIixcblx0XHRcdFx0Ly8gRGVmYXVsdCBub2RlIGljb25zLlxuXHRcdFx0XHQvLyAoVXNlIHRyZWUub3B0aW9ucy5pY29uIGNhbGxiYWNrIHRvIGRlZmluZSBjdXN0b20gaWNvbnMgYmFzZWQgb24gbm9kZSBkYXRhKVxuXHRcdFx0XHRkb2M6IFwiZ2x5cGhpY29uLWZpbGVcIixcblx0XHRcdFx0ZG9jT3BlbjogXCJnbHlwaGljb24tZmlsZVwiLFxuXHRcdFx0XHRmb2xkZXI6IFwiZ2x5cGhpY29uLWZvbGRlci1jbG9zZVwiLFxuXHRcdFx0XHRmb2xkZXJPcGVuOiBcImdseXBoaWNvbi1mb2xkZXItb3BlblwiLFxuXHRcdFx0fSxcblx0XHRcdG1hdGVyaWFsOiB7XG5cdFx0XHRcdF9hZGRDbGFzczogXCJtYXRlcmlhbC1pY29uc1wiLFxuXHRcdFx0XHRjaGVja2JveDogeyB0ZXh0OiBcImNoZWNrX2JveF9vdXRsaW5lX2JsYW5rXCIgfSxcblx0XHRcdFx0Y2hlY2tib3hTZWxlY3RlZDogeyB0ZXh0OiBcImNoZWNrX2JveFwiIH0sXG5cdFx0XHRcdGNoZWNrYm94VW5rbm93bjogeyB0ZXh0OiBcImluZGV0ZXJtaW5hdGVfY2hlY2tfYm94XCIgfSxcblx0XHRcdFx0ZHJhZ0hlbHBlcjogeyB0ZXh0OiBcInBsYXlfYXJyb3dcIiB9LFxuXHRcdFx0XHRkcm9wTWFya2VyOiB7IHRleHQ6IFwiYXJyb3ctZm9yd2FyZFwiIH0sXG5cdFx0XHRcdGVycm9yOiB7IHRleHQ6IFwid2FybmluZ1wiIH0sXG5cdFx0XHRcdGV4cGFuZGVyQ2xvc2VkOiB7IHRleHQ6IFwiY2hldnJvbl9yaWdodFwiIH0sXG5cdFx0XHRcdGV4cGFuZGVyTGF6eTogeyB0ZXh0OiBcImxhc3RfcGFnZVwiIH0sXG5cdFx0XHRcdGV4cGFuZGVyT3BlbjogeyB0ZXh0OiBcImV4cGFuZF9tb3JlXCIgfSxcblx0XHRcdFx0bG9hZGluZzoge1xuXHRcdFx0XHRcdHRleHQ6IFwiYXV0b3JlbmV3XCIsXG5cdFx0XHRcdFx0YWRkQ2xhc3M6IFwiZmFuY3l0cmVlLWhlbHBlci1zcGluXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdG5vZGF0YTogeyB0ZXh0OiBcImluZm9cIiB9LFxuXHRcdFx0XHRub0V4cGFuZGVyOiB7IHRleHQ6IFwiXCIgfSxcblx0XHRcdFx0cmFkaW86IHsgdGV4dDogXCJyYWRpb19idXR0b25fdW5jaGVja2VkXCIgfSxcblx0XHRcdFx0cmFkaW9TZWxlY3RlZDogeyB0ZXh0OiBcInJhZGlvX2J1dHRvbl9jaGVja2VkXCIgfSxcblx0XHRcdFx0Ly8gRGVmYXVsdCBub2RlIGljb25zLlxuXHRcdFx0XHQvLyAoVXNlIHRyZWUub3B0aW9ucy5pY29uIGNhbGxiYWNrIHRvIGRlZmluZSBjdXN0b20gaWNvbnMgYmFzZWQgb24gbm9kZSBkYXRhKVxuXHRcdFx0XHRkb2M6IHsgdGV4dDogXCJpbnNlcnRfZHJpdmVfZmlsZVwiIH0sXG5cdFx0XHRcdGRvY09wZW46IHsgdGV4dDogXCJpbnNlcnRfZHJpdmVfZmlsZVwiIH0sXG5cdFx0XHRcdGZvbGRlcjogeyB0ZXh0OiBcImZvbGRlclwiIH0sXG5cdFx0XHRcdGZvbGRlck9wZW46IHsgdGV4dDogXCJmb2xkZXJfb3BlblwiIH0sXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0ZnVuY3Rpb24gc2V0SWNvbihzcGFuLCBiYXNlQ2xhc3MsIG9wdHMsIHR5cGUpIHtcblx0XHR2YXIgbWFwID0gb3B0cy5tYXAsXG5cdFx0XHRpY29uID0gbWFwW3R5cGVdLFxuXHRcdFx0JHNwYW4gPSAkKHNwYW4pLFxuXHRcdFx0JGNvdW50ZXIgPSAkc3Bhbi5maW5kKFwiLmZhbmN5dHJlZS1jaGlsZGNvdW50ZXJcIiksXG5cdFx0XHRzZXRDbGFzcyA9IGJhc2VDbGFzcyArIFwiIFwiICsgKG1hcC5fYWRkQ2xhc3MgfHwgXCJcIik7XG5cblx0XHRpZiAodHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdC8vICM4ODM6IHJlbW92ZSBpbm5lciBodG1sIHRoYXQgbWF5IGJlIGFkZGVkIGJ5IHByZXYuIG1vZGVcblx0XHRcdHNwYW4uaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdCRzcGFuLmF0dHIoXCJjbGFzc1wiLCBzZXRDbGFzcyArIFwiIFwiICsgaWNvbikuYXBwZW5kKCRjb3VudGVyKTtcblx0XHR9IGVsc2UgaWYgKGljb24pIHtcblx0XHRcdGlmIChpY29uLnRleHQpIHtcblx0XHRcdFx0c3Bhbi50ZXh0Q29udGVudCA9IFwiXCIgKyBpY29uLnRleHQ7XG5cdFx0XHR9IGVsc2UgaWYgKGljb24uaHRtbCkge1xuXHRcdFx0XHRzcGFuLmlubmVySFRNTCA9IGljb24uaHRtbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNwYW4uaW5uZXJIVE1MID0gXCJcIjtcblx0XHRcdH1cblx0XHRcdCRzcGFuXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgc2V0Q2xhc3MgKyBcIiBcIiArIChpY29uLmFkZENsYXNzIHx8IFwiXCIpKVxuXHRcdFx0XHQuYXBwZW5kKCRjb3VudGVyKTtcblx0XHR9XG5cdH1cblxuXHQkLnVpLmZhbmN5dHJlZS5yZWdpc3RlckV4dGVuc2lvbih7XG5cdFx0bmFtZTogXCJnbHlwaFwiLFxuXHRcdHZlcnNpb246IFwiMi4zMy4wXCIsXG5cdFx0Ly8gRGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIGV4dGVuc2lvbi5cblx0XHRvcHRpb25zOiB7XG5cdFx0XHRwcmVzZXQ6IG51bGwsIC8vICdhd2Vzb21lMycsICdhd2Vzb21lNCcsICdib290c3RyYXAzJywgJ21hdGVyaWFsJ1xuXHRcdFx0bWFwOiB7fSxcblx0XHR9LFxuXG5cdFx0dHJlZUluaXQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0dmFyIHRyZWUgPSBjdHgudHJlZSxcblx0XHRcdFx0b3B0cyA9IGN0eC5vcHRpb25zLmdseXBoO1xuXG5cdFx0XHRpZiAob3B0cy5wcmVzZXQpIHtcblx0XHRcdFx0RlQuYXNzZXJ0KFxuXHRcdFx0XHRcdCEhUFJFU0VUU1tvcHRzLnByZXNldF0sXG5cdFx0XHRcdFx0XCJJbnZhbGlkIHZhbHVlIGZvciBgb3B0aW9ucy5nbHlwaC5wcmVzZXRgOiBcIiArIG9wdHMucHJlc2V0XG5cdFx0XHRcdCk7XG5cdFx0XHRcdG9wdHMubWFwID0gJC5leHRlbmQoe30sIFBSRVNFVFNbb3B0cy5wcmVzZXRdLCBvcHRzLm1hcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmVlLndhcm4oXCJleHQtZ2x5cGg6IG1pc3NpbmcgYHByZXNldGAgb3B0aW9uLlwiKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKTtcblx0XHRcdHRyZWUuJGNvbnRhaW5lci5hZGRDbGFzcyhcImZhbmN5dHJlZS1leHQtZ2x5cGhcIik7XG5cdFx0fSxcblx0XHRub2RlUmVuZGVyU3RhdHVzOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdHZhciBjaGVja2JveCxcblx0XHRcdFx0aWNvbixcblx0XHRcdFx0cmVzLFxuXHRcdFx0XHRzcGFuLFxuXHRcdFx0XHRub2RlID0gY3R4Lm5vZGUsXG5cdFx0XHRcdCRzcGFuID0gJChub2RlLnNwYW4pLFxuXHRcdFx0XHRvcHRzID0gY3R4Lm9wdGlvbnMuZ2x5cGg7XG5cblx0XHRcdHJlcyA9IHRoaXMuX3N1cGVyKGN0eCk7XG5cblx0XHRcdGlmIChub2RlLmlzUm9vdCgpKSB7XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0XHRzcGFuID0gJHNwYW4uY2hpbGRyZW4oXCJzcGFuLmZhbmN5dHJlZS1leHBhbmRlclwiKS5nZXQoMCk7XG5cdFx0XHRpZiAoc3Bhbikge1xuXHRcdFx0XHQvLyBpZiggbm9kZS5pc0xvYWRpbmcoKSApe1xuXHRcdFx0XHQvLyBpY29uID0gXCJsb2FkaW5nXCI7XG5cdFx0XHRcdGlmIChub2RlLmV4cGFuZGVkICYmIG5vZGUuaGFzQ2hpbGRyZW4oKSkge1xuXHRcdFx0XHRcdGljb24gPSBcImV4cGFuZGVyT3BlblwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUuaXNVbmRlZmluZWQoKSkge1xuXHRcdFx0XHRcdGljb24gPSBcImV4cGFuZGVyTGF6eVwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUuaGFzQ2hpbGRyZW4oKSkge1xuXHRcdFx0XHRcdGljb24gPSBcImV4cGFuZGVyQ2xvc2VkXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWNvbiA9IFwibm9FeHBhbmRlclwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwYW4uY2xhc3NOYW1lID0gXCJmYW5jeXRyZWUtZXhwYW5kZXIgXCIgKyBtYXBbaWNvbl07XG5cdFx0XHRcdHNldEljb24oc3BhbiwgXCJmYW5jeXRyZWUtZXhwYW5kZXJcIiwgb3B0cywgaWNvbik7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChub2RlLnRyKSB7XG5cdFx0XHRcdHNwYW4gPSAkKFwidGRcIiwgbm9kZS50cilcblx0XHRcdFx0XHQuZmluZChcInNwYW4uZmFuY3l0cmVlLWNoZWNrYm94XCIpXG5cdFx0XHRcdFx0LmdldCgwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNwYW4gPSAkc3Bhbi5jaGlsZHJlbihcInNwYW4uZmFuY3l0cmVlLWNoZWNrYm94XCIpLmdldCgwKTtcblx0XHRcdH1cblx0XHRcdGlmIChzcGFuKSB7XG5cdFx0XHRcdGNoZWNrYm94ID0gRlQuZXZhbE9wdGlvbihcImNoZWNrYm94XCIsIG5vZGUsIG5vZGUsIG9wdHMsIGZhbHNlKTtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5yYWRpb2dyb3VwKSB8fFxuXHRcdFx0XHRcdGNoZWNrYm94ID09PSBcInJhZGlvXCJcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aWNvbiA9IG5vZGUuc2VsZWN0ZWQgPyBcInJhZGlvU2VsZWN0ZWRcIiA6IFwicmFkaW9cIjtcblx0XHRcdFx0XHRzZXRJY29uKFxuXHRcdFx0XHRcdFx0c3Bhbixcblx0XHRcdFx0XHRcdFwiZmFuY3l0cmVlLWNoZWNrYm94IGZhbmN5dHJlZS1yYWRpb1wiLFxuXHRcdFx0XHRcdFx0b3B0cyxcblx0XHRcdFx0XHRcdGljb25cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuXHRcdFx0XHRcdGljb24gPSBub2RlLnNlbGVjdGVkXG5cdFx0XHRcdFx0XHQ/IFwiY2hlY2tib3hTZWxlY3RlZFwiXG5cdFx0XHRcdFx0XHQ6IG5vZGUucGFydHNlbFxuXHRcdFx0XHRcdFx0PyBcImNoZWNrYm94VW5rbm93blwiXG5cdFx0XHRcdFx0XHQ6IFwiY2hlY2tib3hcIjtcblx0XHRcdFx0XHQvLyBzcGFuLmNsYXNzTmFtZSA9IFwiZmFuY3l0cmVlLWNoZWNrYm94IFwiICsgbWFwW2ljb25dO1xuXHRcdFx0XHRcdHNldEljb24oc3BhbiwgXCJmYW5jeXRyZWUtY2hlY2tib3hcIiwgb3B0cywgaWNvbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhbmRhcmQgaWNvbiAobm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgbWF0Y2ggLmZhbmN5dHJlZS1jdXN0b20taWNvbixcblx0XHRcdC8vIHRoYXQgbWlnaHQgYmUgc2V0IGJ5IG9wdHMuaWNvbiBjYWxsYmFja3MpXG5cdFx0XHRzcGFuID0gJHNwYW4uY2hpbGRyZW4oXCJzcGFuLmZhbmN5dHJlZS1pY29uXCIpLmdldCgwKTtcblx0XHRcdGlmIChzcGFuKSB7XG5cdFx0XHRcdGlmIChub2RlLnN0YXR1c05vZGVUeXBlKSB7XG5cdFx0XHRcdFx0aWNvbiA9IG5vZGUuc3RhdHVzTm9kZVR5cGU7IC8vIGxvYWRpbmcsIGVycm9yXG5cdFx0XHRcdH0gZWxzZSBpZiAobm9kZS5mb2xkZXIpIHtcblx0XHRcdFx0XHRpY29uID1cblx0XHRcdFx0XHRcdG5vZGUuZXhwYW5kZWQgJiYgbm9kZS5oYXNDaGlsZHJlbigpXG5cdFx0XHRcdFx0XHRcdD8gXCJmb2xkZXJPcGVuXCJcblx0XHRcdFx0XHRcdFx0OiBcImZvbGRlclwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGljb24gPSBub2RlLmV4cGFuZGVkID8gXCJkb2NPcGVuXCIgOiBcImRvY1wiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldEljb24oc3BhbiwgXCJmYW5jeXRyZWUtaWNvblwiLCBvcHRzLCBpY29uKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHRub2RlU2V0U3RhdHVzOiBmdW5jdGlvbihjdHgsIHN0YXR1cywgbWVzc2FnZSwgZGV0YWlscykge1xuXHRcdFx0dmFyIHJlcyxcblx0XHRcdFx0c3Bhbixcblx0XHRcdFx0b3B0cyA9IGN0eC5vcHRpb25zLmdseXBoLFxuXHRcdFx0XHRub2RlID0gY3R4Lm5vZGU7XG5cblx0XHRcdHJlcyA9IHRoaXMuX3N1cGVyQXBwbHkoYXJndW1lbnRzKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzdGF0dXMgPT09IFwiZXJyb3JcIiB8fFxuXHRcdFx0XHRzdGF0dXMgPT09IFwibG9hZGluZ1wiIHx8XG5cdFx0XHRcdHN0YXR1cyA9PT0gXCJub2RhdGFcIlxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChub2RlLnBhcmVudCkge1xuXHRcdFx0XHRcdHNwYW4gPSAkKFwic3Bhbi5mYW5jeXRyZWUtZXhwYW5kZXJcIiwgbm9kZS5zcGFuKS5nZXQoMCk7XG5cdFx0XHRcdFx0aWYgKHNwYW4pIHtcblx0XHRcdFx0XHRcdHNldEljb24oc3BhbiwgXCJmYW5jeXRyZWUtZXhwYW5kZXJcIiwgb3B0cywgc3RhdHVzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHRzcGFuID0gJChcblx0XHRcdFx0XHRcdFwiLmZhbmN5dHJlZS1zdGF0dXNub2RlLVwiICsgc3RhdHVzLFxuXHRcdFx0XHRcdFx0bm9kZVt0aGlzLm5vZGVDb250YWluZXJBdHRyTmFtZV1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQuZmluZChcInNwYW4uZmFuY3l0cmVlLWljb25cIilcblx0XHRcdFx0XHRcdC5nZXQoMCk7XG5cdFx0XHRcdFx0aWYgKHNwYW4pIHtcblx0XHRcdFx0XHRcdHNldEljb24oc3BhbiwgXCJmYW5jeXRyZWUtaWNvblwiLCBvcHRzLCBzdGF0dXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXHR9KTtcblx0Ly8gVmFsdWUgcmV0dXJuZWQgYnkgYHJlcXVpcmUoJ2pxdWVyeS5mYW5jeXRyZWUuLicpYFxuXHRyZXR1cm4gJC51aS5mYW5jeXRyZWU7XG59KTsgLy8gRW5kIG9mIGNsb3N1cmVcbiIsIi8qIVxuICoganF1ZXJ5LmZhbmN5dHJlZS5qc1xuICogVHJlZSB2aWV3IGNvbnRyb2wgd2l0aCBzdXBwb3J0IGZvciBsYXp5IGxvYWRpbmcgYW5kIG11Y2ggbW9yZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXIxMC9mYW5jeXRyZWUvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA4LTIwMTksIE1hcnRpbiBXZW5kdCAoaHR0cHM6Ly93d1dlbmR0LmRlKVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyMTAvZmFuY3l0cmVlL3dpa2kvTGljZW5zZUluZm9cbiAqXG4gKiBAdmVyc2lvbiAyLjMzLjBcbiAqIEBkYXRlIDIwMTktMTAtMjlUMDg6MDA6MDdaXG4gKi9cblxuLyoqIENvcmUgRmFuY3l0cmVlIG1vZHVsZS5cbiAqL1xuXG4vLyBVTUQgd3JhcHBlciBmb3IgdGhlIEZhbmN5dHJlZSBjb3JlIG1vZHVsZVxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXCJqcXVlcnlcIiwgXCIuL2pxdWVyeS5mYW5jeXRyZWUudWktZGVwc1wiXSwgZmFjdG9yeSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRcdC8vIE5vZGUvQ29tbW9uSlNcblx0XHRyZXF1aXJlKFwiLi9qcXVlcnkuZmFuY3l0cmVlLnVpLWRlcHNcIik7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoalF1ZXJ5KTtcblx0fVxufSkoZnVuY3Rpb24oJCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQvLyBwcmV2ZW50IGR1cGxpY2F0ZSBsb2FkaW5nXG5cdGlmICgkLnVpICYmICQudWkuZmFuY3l0cmVlKSB7XG5cdFx0JC51aS5mYW5jeXRyZWUud2FybihcIkZhbmN5dHJlZTogaWdub3JlZCBkdXBsaWNhdGUgaW5jbHVkZVwiKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIFByaXZhdGUgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXNcblx0ICovXG5cblx0dmFyIGksXG5cdFx0YXR0cixcblx0XHRGVCA9IG51bGwsIC8vIGluaXRpYWxpemVkIGJlbG93XG5cdFx0VEVTVF9JTUcgPSBuZXcgUmVnRXhwKC9cXC58XFwvLyksIC8vIHN0cmluZ3MgYXJlIGNvbnNpZGVyZWQgaW1hZ2UgdXJscyBpZiB0aGV5IGNvbnRhaW4gJy4nIG9yICcvJ1xuXHRcdFJFWF9IVE1MID0gL1smPD5cIicvXS9nLCAvLyBFc2NhcGUgdGhvc2UgY2hhcmFjdGVyc1xuXHRcdFJFWF9UT09MVElQID0gL1s8PlwiJy9dL2csIC8vIERvbid0IGVzY2FwZSBgJmAgaW4gdG9vbHRpcHNcblx0XHRSRUNVUlNJVkVfUkVRVUVTVF9FUlJPUiA9IFwiJHJlY3Vyc2l2ZV9yZXF1ZXN0XCIsXG5cdFx0Ly8gQ0xJUEJPQVJEID0gbnVsbCxcblx0XHRFTlRJVFlfTUFQID0ge1xuXHRcdFx0XCImXCI6IFwiJmFtcDtcIixcblx0XHRcdFwiPFwiOiBcIiZsdDtcIixcblx0XHRcdFwiPlwiOiBcIiZndDtcIixcblx0XHRcdCdcIic6IFwiJnF1b3Q7XCIsXG5cdFx0XHRcIidcIjogXCImIzM5O1wiLFxuXHRcdFx0XCIvXCI6IFwiJiN4MkY7XCIsXG5cdFx0fSxcblx0XHRJR05PUkVfS0VZQ09ERVMgPSB7IDE2OiB0cnVlLCAxNzogdHJ1ZSwgMTg6IHRydWUgfSxcblx0XHRTUEVDSUFMX0tFWUNPREVTID0ge1xuXHRcdFx0ODogXCJiYWNrc3BhY2VcIixcblx0XHRcdDk6IFwidGFiXCIsXG5cdFx0XHQxMDogXCJyZXR1cm5cIixcblx0XHRcdDEzOiBcInJldHVyblwiLFxuXHRcdFx0Ly8gMTY6IG51bGwsIDE3OiBudWxsLCAxODogbnVsbCwgIC8vIGlnbm9yZSBzaGlmdCwgY3RybCwgYWx0XG5cdFx0XHQxOTogXCJwYXVzZVwiLFxuXHRcdFx0MjA6IFwiY2Fwc2xvY2tcIixcblx0XHRcdDI3OiBcImVzY1wiLFxuXHRcdFx0MzI6IFwic3BhY2VcIixcblx0XHRcdDMzOiBcInBhZ2V1cFwiLFxuXHRcdFx0MzQ6IFwicGFnZWRvd25cIixcblx0XHRcdDM1OiBcImVuZFwiLFxuXHRcdFx0MzY6IFwiaG9tZVwiLFxuXHRcdFx0Mzc6IFwibGVmdFwiLFxuXHRcdFx0Mzg6IFwidXBcIixcblx0XHRcdDM5OiBcInJpZ2h0XCIsXG5cdFx0XHQ0MDogXCJkb3duXCIsXG5cdFx0XHQ0NTogXCJpbnNlcnRcIixcblx0XHRcdDQ2OiBcImRlbFwiLFxuXHRcdFx0NTk6IFwiO1wiLFxuXHRcdFx0NjE6IFwiPVwiLFxuXHRcdFx0Ly8gOTE6IG51bGwsIDkzOiBudWxsLCAgLy8gaWdub3JlIGxlZnQgYW5kIHJpZ2h0IG1ldGFcblx0XHRcdDk2OiBcIjBcIixcblx0XHRcdDk3OiBcIjFcIixcblx0XHRcdDk4OiBcIjJcIixcblx0XHRcdDk5OiBcIjNcIixcblx0XHRcdDEwMDogXCI0XCIsXG5cdFx0XHQxMDE6IFwiNVwiLFxuXHRcdFx0MTAyOiBcIjZcIixcblx0XHRcdDEwMzogXCI3XCIsXG5cdFx0XHQxMDQ6IFwiOFwiLFxuXHRcdFx0MTA1OiBcIjlcIixcblx0XHRcdDEwNjogXCIqXCIsXG5cdFx0XHQxMDc6IFwiK1wiLFxuXHRcdFx0MTA5OiBcIi1cIixcblx0XHRcdDExMDogXCIuXCIsXG5cdFx0XHQxMTE6IFwiL1wiLFxuXHRcdFx0MTEyOiBcImYxXCIsXG5cdFx0XHQxMTM6IFwiZjJcIixcblx0XHRcdDExNDogXCJmM1wiLFxuXHRcdFx0MTE1OiBcImY0XCIsXG5cdFx0XHQxMTY6IFwiZjVcIixcblx0XHRcdDExNzogXCJmNlwiLFxuXHRcdFx0MTE4OiBcImY3XCIsXG5cdFx0XHQxMTk6IFwiZjhcIixcblx0XHRcdDEyMDogXCJmOVwiLFxuXHRcdFx0MTIxOiBcImYxMFwiLFxuXHRcdFx0MTIyOiBcImYxMVwiLFxuXHRcdFx0MTIzOiBcImYxMlwiLFxuXHRcdFx0MTQ0OiBcIm51bWxvY2tcIixcblx0XHRcdDE0NTogXCJzY3JvbGxcIixcblx0XHRcdDE3MzogXCItXCIsXG5cdFx0XHQxODY6IFwiO1wiLFxuXHRcdFx0MTg3OiBcIj1cIixcblx0XHRcdDE4ODogXCIsXCIsXG5cdFx0XHQxODk6IFwiLVwiLFxuXHRcdFx0MTkwOiBcIi5cIixcblx0XHRcdDE5MTogXCIvXCIsXG5cdFx0XHQxOTI6IFwiYFwiLFxuXHRcdFx0MjE5OiBcIltcIixcblx0XHRcdDIyMDogXCJcXFxcXCIsXG5cdFx0XHQyMjE6IFwiXVwiLFxuXHRcdFx0MjIyOiBcIidcIixcblx0XHR9LFxuXHRcdE1PRElGSUVSUyA9IHtcblx0XHRcdDE2OiBcInNoaWZ0XCIsXG5cdFx0XHQxNzogXCJjdHJsXCIsXG5cdFx0XHQxODogXCJhbHRcIixcblx0XHRcdDkxOiBcIm1ldGFcIixcblx0XHRcdDkzOiBcIm1ldGFcIixcblx0XHR9LFxuXHRcdE1PVVNFX0JVVFRPTlMgPSB7IDA6IFwiXCIsIDE6IFwibGVmdFwiLCAyOiBcIm1pZGRsZVwiLCAzOiBcInJpZ2h0XCIgfSxcblx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgc2V0IHdpdGggZXF1aXZhbGVudCBjbGFzcyBuYW1lcyBpbiB0aGUgTEkgdGFnc1xuXHRcdC8vIE5vdGU6IHYyLjIzOiBjaGVja2JveCBhbmQgaGlkZUNoZWNrYm94IGFyZSAqbm90KiBpbiB0aGlzIGxpc3Rcblx0XHRDTEFTU19BVFRSUyA9IFwiYWN0aXZlIGV4cGFuZGVkIGZvY3VzIGZvbGRlciBsYXp5IHJhZGlvZ3JvdXAgc2VsZWN0ZWQgdW5zZWxlY3RhYmxlIHVuc2VsZWN0YWJsZUlnbm9yZVwiLnNwbGl0KFxuXHRcdFx0XCIgXCJcblx0XHQpLFxuXHRcdENMQVNTX0FUVFJfTUFQID0ge30sXG5cdFx0Ly8gVG9wLWxldmVsIEZhbmN5dHJlZSBhdHRyaWJ1dGVzLCB0aGF0IGNhbiBiZSBzZXQgYnkgZGljdFxuXHRcdFRSRUVfQVRUUlMgPSBcImNvbHVtbnMgdHlwZXNcIi5zcGxpdChcIiBcIiksXG5cdFx0Ly8gVFJFRV9BVFRSX01BUCA9IHt9LFxuXHRcdC8vIFRvcC1sZXZlbCBGYW5jeXRyZWVOb2RlIGF0dHJpYnV0ZXMsIHRoYXQgY2FuIGJlIHNldCBieSBkaWN0XG5cdFx0Tk9ERV9BVFRSUyA9IFwiY2hlY2tib3ggZXhwYW5kZWQgZXh0cmFDbGFzc2VzIGZvbGRlciBpY29uIGljb25Ub29sdGlwIGtleSBsYXp5IHBhcnRzZWwgcmFkaW9ncm91cCByZWZLZXkgc2VsZWN0ZWQgc3RhdHVzTm9kZVR5cGUgdGl0bGUgdG9vbHRpcCB0eXBlIHVuc2VsZWN0YWJsZSB1bnNlbGVjdGFibGVJZ25vcmUgdW5zZWxlY3RhYmxlU3RhdHVzXCIuc3BsaXQoXG5cdFx0XHRcIiBcIlxuXHRcdCksXG5cdFx0Tk9ERV9BVFRSX01BUCA9IHt9LFxuXHRcdC8vIE1hcHBpbmcgb2YgbG93ZXJjYXNlIC0+IHJlYWwgbmFtZSAoYmVjYXVzZSBIVE1MNSBkYXRhLS4uLiBhdHRyaWJ1dGUgb25seSBzdXBwb3J0cyBsb3dlcmNhc2UpXG5cdFx0Tk9ERV9BVFRSX0xPV0VSQ0FTRV9NQVAgPSB7fSxcblx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgdGhhdCBzaG91bGQgTk9UIGJlIGFkZGVkIHRvIG5vZGUuZGF0YVxuXHRcdE5PTkVfTk9ERV9EQVRBX01BUCA9IHtcblx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdFx0ZGF0YTogdHJ1ZSxcblx0XHRcdGZvY3VzOiB0cnVlLFxuXHRcdH07XG5cblx0Zm9yIChpID0gMDsgaSA8IENMQVNTX0FUVFJTLmxlbmd0aDsgaSsrKSB7XG5cdFx0Q0xBU1NfQVRUUl9NQVBbQ0xBU1NfQVRUUlNbaV1dID0gdHJ1ZTtcblx0fVxuXHRmb3IgKGkgPSAwOyBpIDwgTk9ERV9BVFRSUy5sZW5ndGg7IGkrKykge1xuXHRcdGF0dHIgPSBOT0RFX0FUVFJTW2ldO1xuXHRcdE5PREVfQVRUUl9NQVBbYXR0cl0gPSB0cnVlO1xuXHRcdGlmIChhdHRyICE9PSBhdHRyLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdE5PREVfQVRUUl9MT1dFUkNBU0VfTUFQW2F0dHIudG9Mb3dlckNhc2UoKV0gPSBhdHRyO1xuXHRcdH1cblx0fVxuXHQvLyBmb3IoaT0wOyBpPFRSRUVfQVRUUlMubGVuZ3RoOyBpKyspIHtcblx0Ly8gXHRUUkVFX0FUVFJfTUFQW1RSRUVfQVRUUlNbaV1dID0gdHJ1ZTtcblx0Ly8gfVxuXG5cdGZ1bmN0aW9uIF9hc3NlcnQoY29uZCwgbXNnKSB7XG5cdFx0Ly8gVE9ETzogc2VlIHF1bml0LmpzIGV4dHJhY3RTdGFja3RyYWNlKClcblx0XHRpZiAoIWNvbmQpIHtcblx0XHRcdG1zZyA9IG1zZyA/IFwiOiBcIiArIG1zZyA6IFwiXCI7XG5cdFx0XHQvLyBjb25zb2xlQXBwbHkoXCJhc3NlcnRcIiwgWyEhY29uZCwgbXNnXSk7XG5cdFx0XHQkLmVycm9yKFwiRmFuY3l0cmVlIGFzc2VydGlvbiBmYWlsZWRcIiArIG1zZyk7XG5cdFx0fVxuXHR9XG5cblx0X2Fzc2VydCgkLnVpLCBcIkZhbmN5dHJlZSByZXF1aXJlcyBqUXVlcnkgVUkgKGh0dHA6Ly9qcXVlcnl1aS5jb20pXCIpO1xuXG5cdGZ1bmN0aW9uIGNvbnNvbGVBcHBseShtZXRob2QsIGFyZ3MpIHtcblx0XHR2YXIgaSxcblx0XHRcdHMsXG5cdFx0XHRmbiA9IHdpbmRvdy5jb25zb2xlID8gd2luZG93LmNvbnNvbGVbbWV0aG9kXSA6IG51bGw7XG5cblx0XHRpZiAoZm4pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZuLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gSUUgOD9cblx0XHRcdFx0cyA9IFwiXCI7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cyArPSBhcmdzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZuKHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qIHN1cHBvcnQ6IElFOCBQb2x5ZmlsIGZvciBEYXRlLm5vdygpICovXG5cdGlmICghRGF0ZS5ub3cpIHtcblx0XHREYXRlLm5vdyA9IGZ1bmN0aW9uIG5vdygpIHtcblx0XHRcdHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHR9O1xuXHR9XG5cblx0LypSZXR1cm4gdHJ1ZSBpZiB4IGlzIGEgRmFuY3l0cmVlTm9kZS4qL1xuXHRmdW5jdGlvbiBfaXNOb2RlKHgpIHtcblx0XHRyZXR1cm4gISEoeC50cmVlICYmIHguc3RhdHVzTm9kZVR5cGUgIT09IHVuZGVmaW5lZCk7XG5cdH1cblxuXHQvKiogUmV0dXJuIHRydWUgaWYgZG90dGVkIHZlcnNpb24gc3RyaW5nIGlzIGVxdWFsIG9yIGhpZ2hlciB0aGFuIHJlcXVlc3RlZCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBTZWUgaHR0cDovL2pzZmlkZGxlLm5ldC9tYXIxMC9GalNBTi9cblx0ICovXG5cdGZ1bmN0aW9uIGlzVmVyc2lvbkF0TGVhc3QoZG90dGVkVmVyc2lvbiwgbWFqb3IsIG1pbm9yLCBwYXRjaCkge1xuXHRcdHZhciBpLFxuXHRcdFx0dixcblx0XHRcdHQsXG5cdFx0XHR2ZXJQYXJ0cyA9ICQubWFwKCQudHJpbShkb3R0ZWRWZXJzaW9uKS5zcGxpdChcIi5cIiksIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KGUsIDEwKTtcblx0XHRcdH0pLFxuXHRcdFx0dGVzdFBhcnRzID0gJC5tYXAoXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG5cdFx0XHRcdGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoZSwgMTApO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRlc3RQYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0diA9IHZlclBhcnRzW2ldIHx8IDA7XG5cdFx0XHR0ID0gdGVzdFBhcnRzW2ldIHx8IDA7XG5cdFx0XHRpZiAodiAhPT0gdCkge1xuXHRcdFx0XHRyZXR1cm4gdiA+IHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlZXAtbWVyZ2UgYSBsaXN0IG9mIG9iamVjdHMgKGJ1dCByZXBsYWNlIGFycmF5LXR5cGUgb3B0aW9ucykuXG5cdCAqXG5cdCAqIGpRdWVyeSdzICQuZXh0ZW5kKHRydWUsIC4uLikgbWV0aG9kIGRvZXMgYSBkZWVwIG1lcmdlLCB0aGF0IGFsc28gbWVyZ2VzIEFycmF5cy5cblx0ICogVGhpcyB2YXJpYW50IGlzIHVzZWQgdG8gbWVyZ2UgZXh0ZW5zaW9uIGRlZmF1bHRzIHdpdGggdXNlciBvcHRpb25zLCBhbmQgc2hvdWxkXG5cdCAqIG1lcmdlIG9iamVjdHMsIGJ1dCBvdmVycmlkZSBhcnJheXMgKGZvciBleGFtcGxlIHRoZSBgdHJpZ2dlclN0YXJ0OiBbLi4uXWAgb3B0aW9uXG5cdCAqIG9mIGV4dC1lZGl0KS4gQWxzbyBgbnVsbGAgdmFsdWVzIGFyZSBjb3BpZWQgb3ZlciBhbmQgbm90IHNraXBwZWQuXG5cdCAqXG5cdCAqIFNlZSBpc3N1ZSAjODc2XG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqIF9zaW1wbGVEZWVwTWVyZ2Uoe30sIG8xLCBvMik7XG5cdCAqL1xuXHRmdW5jdGlvbiBfc2ltcGxlRGVlcE1lcmdlKCkge1xuXHRcdHZhciBvcHRpb25zLFxuXHRcdFx0bmFtZSxcblx0XHRcdHNyYyxcblx0XHRcdGNvcHksXG5cdFx0XHRjbG9uZSxcblx0XHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRcdGkgPSAxLFxuXHRcdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcblxuXHRcdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRcdGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICEkLmlzRnVuY3Rpb24odGFyZ2V0KSkge1xuXHRcdFx0dGFyZ2V0ID0ge307XG5cdFx0fVxuXHRcdGlmIChpID09PSBsZW5ndGgpIHtcblx0XHRcdHRocm93IEVycm9yKFwibmVlZCBhdCBsZWFzdCB0d28gYXJnc1wiKTtcblx0XHR9XG5cdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0aWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSAhPSBudWxsKSB7XG5cdFx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdFx0c3JjID0gdGFyZ2V0W25hbWVdO1xuXHRcdFx0XHRcdFx0Y29weSA9IG9wdGlvbnNbbmFtZV07XG5cdFx0XHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSBjb3B5KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHNcblx0XHRcdFx0XHRcdC8vIChOT1RFOiB1bmxpa2UgJC5leHRlbmQsIHdlIGRvbid0IG1lcmdlIGFycmF5cywgYnV0IHJlcGxhY2UgdGhlbSlcblx0XHRcdFx0XHRcdGlmIChjb3B5ICYmICQuaXNQbGFpbk9iamVjdChjb3B5KSkge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiAkLmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gX3NpbXBsZURlZXBNZXJnZShjbG9uZSwgY29weSk7XG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9IGNvcHk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdC8qKiBSZXR1cm4gYSB3cmFwcGVyIHRoYXQgY2FsbHMgc3ViLm1ldGhvZE5hbWUoKSBhbmQgZXhwb3Nlc1xuXHQgKiAgdGhpcyAgICAgICAgICAgICA6IHRyZWVcblx0ICogIHRoaXMuX2xvY2FsICAgICAgOiB0cmVlLmV4dC5FWFROQU1FXG5cdCAqICB0aGlzLl9zdXBlciAgICAgIDogYmFzZS5tZXRob2ROYW1lLmNhbGwoKVxuXHQgKiAgdGhpcy5fc3VwZXJBcHBseSA6IGJhc2UubWV0aG9kTmFtZS5hcHBseSgpXG5cdCAqL1xuXHRmdW5jdGlvbiBfbWFrZVZpcnR1YWxGdW5jdGlvbihtZXRob2ROYW1lLCB0cmVlLCBiYXNlLCBleHRlbnNpb24sIGV4dE5hbWUpIHtcblx0XHQvLyAkLnVpLmZhbmN5dHJlZS5kZWJ1ZyhcIl9tYWtlVmlydHVhbEZ1bmN0aW9uXCIsIG1ldGhvZE5hbWUsIHRyZWUsIGJhc2UsIGV4dGVuc2lvbiwgZXh0TmFtZSk7XG5cdFx0Ly8gaWYocmV4VGVzdFN1cGVyICYmICFyZXhUZXN0U3VwZXIudGVzdChmdW5jKSl7XG5cdFx0Ly8gICAgIC8vIGV4dGVuc2lvbi5tZXRob2ROYW1lKCkgZG9lc24ndCBjYWxsIF9zdXBlcigpLCBzbyBubyB3cmFwcGVyIHJlcXVpcmVkXG5cdFx0Ly8gICAgIHJldHVybiBmdW5jO1xuXHRcdC8vIH1cblx0XHQvLyBVc2UgYW4gaW1tZWRpYXRlIGZ1bmN0aW9uIGFzIGNsb3N1cmVcblx0XHR2YXIgcHJveHkgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJldkZ1bmMgPSB0cmVlW21ldGhvZE5hbWVdLCAvLyBvcmcuIHRyZWUgbWV0aG9kIG9yIHByZXYuIHByb3h5XG5cdFx0XHRcdGJhc2VGdW5jID0gZXh0ZW5zaW9uW21ldGhvZE5hbWVdLCAvL1xuXHRcdFx0XHRfbG9jYWwgPSB0cmVlLmV4dFtleHROYW1lXSxcblx0XHRcdFx0X3N1cGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZXZGdW5jLmFwcGx5KHRyZWUsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9zdXBlckFwcGx5ID0gZnVuY3Rpb24oYXJncykge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2RnVuYy5hcHBseSh0cmVlLCBhcmdzKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0Ly8gUmV0dXJuIHRoZSB3cmFwcGVyIGZ1bmN0aW9uXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBwcmV2TG9jYWwgPSB0cmVlLl9sb2NhbCxcblx0XHRcdFx0XHRwcmV2U3VwZXIgPSB0cmVlLl9zdXBlcixcblx0XHRcdFx0XHRwcmV2U3VwZXJBcHBseSA9IHRyZWUuX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0cmVlLl9sb2NhbCA9IF9sb2NhbDtcblx0XHRcdFx0XHR0cmVlLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0XHR0cmVlLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cdFx0XHRcdFx0cmV0dXJuIGJhc2VGdW5jLmFwcGx5KHRyZWUsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0dHJlZS5fbG9jYWwgPSBwcmV2TG9jYWw7XG5cdFx0XHRcdFx0dHJlZS5fc3VwZXIgPSBwcmV2U3VwZXI7XG5cdFx0XHRcdFx0dHJlZS5fc3VwZXJBcHBseSA9IHByZXZTdXBlckFwcGx5O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pKCk7IC8vIGVuZCBvZiBJbW1lZGlhdGUgRnVuY3Rpb25cblx0XHRyZXR1cm4gcHJveHk7XG5cdH1cblxuXHQvKipcblx0ICogU3ViY2xhc3MgYGJhc2VgIGJ5IGNyZWF0aW5nIHByb3h5IGZ1bmN0aW9uc1xuXHQgKi9cblx0ZnVuY3Rpb24gX3N1YmNsYXNzT2JqZWN0KHRyZWUsIGJhc2UsIGV4dGVuc2lvbiwgZXh0TmFtZSkge1xuXHRcdC8vICQudWkuZmFuY3l0cmVlLmRlYnVnKFwiX3N1YmNsYXNzT2JqZWN0XCIsIHRyZWUsIGJhc2UsIGV4dGVuc2lvbiwgZXh0TmFtZSk7XG5cdFx0Zm9yICh2YXIgYXR0ck5hbWUgaW4gZXh0ZW5zaW9uKSB7XG5cdFx0XHRpZiAodHlwZW9mIGV4dGVuc2lvblthdHRyTmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRpZiAodHlwZW9mIHRyZWVbYXR0ck5hbWVdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHQvLyBvdmVycmlkZSBleGlzdGluZyBtZXRob2Rcblx0XHRcdFx0XHR0cmVlW2F0dHJOYW1lXSA9IF9tYWtlVmlydHVhbEZ1bmN0aW9uKFxuXHRcdFx0XHRcdFx0YXR0ck5hbWUsXG5cdFx0XHRcdFx0XHR0cmVlLFxuXHRcdFx0XHRcdFx0YmFzZSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbixcblx0XHRcdFx0XHRcdGV4dE5hbWVcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGF0dHJOYW1lLmNoYXJBdCgwKSA9PT0gXCJfXCIpIHtcblx0XHRcdFx0XHQvLyBDcmVhdGUgcHJpdmF0ZSBtZXRob2RzIGluIHRyZWUuZXh0LkVYVEVOU0lPTiBuYW1lc3BhY2Vcblx0XHRcdFx0XHR0cmVlLmV4dFtleHROYW1lXVthdHRyTmFtZV0gPSBfbWFrZVZpcnR1YWxGdW5jdGlvbihcblx0XHRcdFx0XHRcdGF0dHJOYW1lLFxuXHRcdFx0XHRcdFx0dHJlZSxcblx0XHRcdFx0XHRcdGJhc2UsXG5cdFx0XHRcdFx0XHRleHRlbnNpb24sXG5cdFx0XHRcdFx0XHRleHROYW1lXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcdFx0XCJDb3VsZCBub3Qgb3ZlcnJpZGUgdHJlZS5cIiArXG5cdFx0XHRcdFx0XHRcdGF0dHJOYW1lICtcblx0XHRcdFx0XHRcdFx0XCIuIFVzZSBwcmVmaXggJ18nIHRvIGNyZWF0ZSB0cmVlLlwiICtcblx0XHRcdFx0XHRcdFx0ZXh0TmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiLl9cIiArXG5cdFx0XHRcdFx0XHRcdGF0dHJOYW1lXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQ3JlYXRlIG1lbWJlciB2YXJpYWJsZXMgaW4gdHJlZS5leHQuRVhURU5TSU9OIG5hbWVzcGFjZVxuXHRcdFx0XHRpZiAoYXR0ck5hbWUgIT09IFwib3B0aW9uc1wiKSB7XG5cdFx0XHRcdFx0dHJlZS5leHRbZXh0TmFtZV1bYXR0ck5hbWVdID0gZXh0ZW5zaW9uW2F0dHJOYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF9nZXRSZXNvbHZlZFByb21pc2UoY29udGV4dCwgYXJnQXJyYXkpIHtcblx0XHRpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJC5EZWZlcnJlZChmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlKCk7XG5cdFx0XHR9KS5wcm9taXNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiAkLkRlZmVycmVkKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNvbHZlV2l0aChjb250ZXh0LCBhcmdBcnJheSk7XG5cdFx0fSkucHJvbWlzZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX2dldFJlamVjdGVkUHJvbWlzZShjb250ZXh0LCBhcmdBcnJheSkge1xuXHRcdGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAkLkRlZmVycmVkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJlamVjdCgpO1xuXHRcdFx0fSkucHJvbWlzZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gJC5EZWZlcnJlZChmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVqZWN0V2l0aChjb250ZXh0LCBhcmdBcnJheSk7XG5cdFx0fSkucHJvbWlzZSgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gX21ha2VSZXNvbHZlRnVuYyhkZWZlcnJlZCwgY29udGV4dCkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKGNvbnRleHQpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBfZ2V0RWxlbWVudERhdGFBc0RpY3QoJGVsKSB7XG5cdFx0Ly8gRXZhbHVhdGUgJ2RhdGEtTkFNRScgYXR0cmlidXRlcyB3aXRoIHNwZWNpYWwgdHJlYXRtZW50IGZvciAnZGF0YS1qc29uJy5cblx0XHR2YXIgZCA9ICQuZXh0ZW5kKHt9LCAkZWwuZGF0YSgpKSxcblx0XHRcdGpzb24gPSBkLmpzb247XG5cblx0XHRkZWxldGUgZC5mYW5jeXRyZWU7IC8vIGFkZGVkIHRvIGNvbnRhaW5lciBieSB3aWRnZXQgZmFjdG9yeSAob2xkIGpRdWVyeSBVSSlcblx0XHRkZWxldGUgZC51aUZhbmN5dHJlZTsgLy8gYWRkZWQgdG8gY29udGFpbmVyIGJ5IHdpZGdldCBmYWN0b3J5XG5cblx0XHRpZiAoanNvbikge1xuXHRcdFx0ZGVsZXRlIGQuanNvbjtcblx0XHRcdC8vIDxsaSBkYXRhLWpzb249Jy4uLic+IGlzIGFscmVhZHkgcmV0dXJuZWQgYXMgb2JqZWN0IChodHRwOi8vYXBpLmpxdWVyeS5jb20vZGF0YS8jZGF0YS1odG1sNSlcblx0XHRcdGQgPSAkLmV4dGVuZChkLCBqc29uKTtcblx0XHR9XG5cdFx0cmV0dXJuIGQ7XG5cdH1cblxuXHRmdW5jdGlvbiBfZXNjYXBlVG9vbHRpcChzKSB7XG5cdFx0cmV0dXJuIChcIlwiICsgcykucmVwbGFjZShSRVhfVE9PTFRJUCwgZnVuY3Rpb24ocykge1xuXHRcdFx0cmV0dXJuIEVOVElUWV9NQVBbc107XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBUT0RPOiB1c2UgY3Vycnlpbmdcblx0ZnVuY3Rpb24gX21ha2VOb2RlVGl0bGVNYXRjaGVyKHMpIHtcblx0XHRzID0gcy50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbm9kZS50aXRsZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocykgPj0gMDtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gX21ha2VOb2RlVGl0bGVTdGFydE1hdGNoZXIocykge1xuXHRcdHZhciByZU1hdGNoID0gbmV3IFJlZ0V4cChcIl5cIiArIHMsIFwiaVwiKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIHJlTWF0Y2gudGVzdChub2RlLnRpdGxlKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBGYW5jeXRyZWVOb2RlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IEZhbmN5dHJlZU5vZGVcblx0ICpcblx0ICogQGNsYXNzIEZhbmN5dHJlZU5vZGVcblx0ICogQGNsYXNzZGVzYyBBIEZhbmN5dHJlZU5vZGUgcmVwcmVzZW50cyB0aGUgaGllcmFyY2hpY2FsIGRhdGEgbW9kZWwgYW5kIG9wZXJhdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gcGFyZW50XG5cdCAqIEBwYXJhbSB7Tm9kZURhdGF9IG9ialxuXHQgKlxuXHQgKiBAcHJvcGVydHkge0ZhbmN5dHJlZX0gdHJlZSBUaGUgdHJlZSBpbnN0YW5jZVxuXHQgKiBAcHJvcGVydHkge0ZhbmN5dHJlZU5vZGV9IHBhcmVudCBUaGUgcGFyZW50IG5vZGVcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGtleSBOb2RlIGlkIChtdXN0IGJlIHVuaXF1ZSBpbnNpZGUgdGhlIHRyZWUpXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aXRsZSBEaXNwbGF5IG5hbWUgKG1heSBjb250YWluIEhUTUwpXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhIENvbnRhaW5zIGFsbCBleHRyYSBkYXRhIHRoYXQgd2FzIHBhc3NlZCBvbiBub2RlIGNyZWF0aW9uXG5cdCAqIEBwcm9wZXJ0eSB7RmFuY3l0cmVlTm9kZVtdIHwgbnVsbCB8IHVuZGVmaW5lZH0gY2hpbGRyZW4gQXJyYXkgb2YgY2hpbGQgbm9kZXMuPGJyPlxuXHQgKiAgICAgRm9yIGxhenkgbm9kZXMsIG51bGwgb3IgdW5kZWZpbmVkIG1lYW5zICdub3QgeWV0IGxvYWRlZCcuIFVzZSBhbiBlbXB0eSBhcnJheVxuXHQgKiAgICAgdG8gZGVmaW5lIGEgbm9kZSB0aGF0IGhhcyBubyBjaGlsZHJlbi5cblx0ICogQHByb3BlcnR5IHtib29sZWFufSBleHBhbmRlZCBVc2UgaXNFeHBhbmRlZCgpLCBzZXRFeHBhbmRlZCgpIHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5LlxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gZXh0cmFDbGFzc2VzIEFkZGl0aW9uYWwgQ1NTIGNsYXNzZXMsIGFkZGVkIHRvIHRoZSBub2RlJ3MgYDxzcGFuPmAuPGJyPlxuXHQgKiAgICAgTm90ZTogdXNlIGBub2RlLmFkZC9yZW1vdmUvdG9nZ2xlQ2xhc3MoKWAgdG8gbW9kaWZ5LlxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IGZvbGRlciBGb2xkZXIgbm9kZXMgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdCBpY29ucyBhbmQgY2xpY2sgYmVoYXZpb3IuPGJyPlxuXHQgKiAgICAgTm90ZTogQWxzbyBub24tZm9sZGVycyBtYXkgaGF2ZSBjaGlsZHJlbi5cblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1c05vZGVUeXBlIG51bGwgZm9yIHN0YW5kYXJkIG5vZGVzLiBPdGhlcndpc2UgdHlwZSBvZiBzcGVjaWFsIHN5c3RlbSBub2RlOiAnZXJyb3InLCAnbG9hZGluZycsICdub2RhdGEnLCBvciAncGFnaW5nJy5cblx0ICogQHByb3BlcnR5IHtib29sZWFufSBsYXp5IFRydWUgaWYgdGhpcyBub2RlIGlzIGxvYWRlZCBvbiBkZW1hbmQsIGkuZS4gb24gZmlyc3QgZXhwYW5zaW9uLlxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNlbGVjdGVkIFVzZSBpc1NlbGVjdGVkKCksIHNldFNlbGVjdGVkKCkgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkuXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0b29sdGlwIEFsdGVybmF0aXZlIGRlc2NyaXB0aW9uIHVzZWQgYXMgaG92ZXIgcG9wdXBcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGljb25Ub29sdGlwIERlc2NyaXB0aW9uIHVzZWQgYXMgaG92ZXIgcG9wdXAgZm9yIGljb24uIEBzaW5jZSAyLjI3XG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIE5vZGUgdHlwZSwgdXNlZCB3aXRoIHRyZWUudHlwZXMgbWFwLiBAc2luY2UgMi4yN1xuXHQgKi9cblx0ZnVuY3Rpb24gRmFuY3l0cmVlTm9kZShwYXJlbnQsIG9iaikge1xuXHRcdHZhciBpLCBsLCBuYW1lLCBjbDtcblxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHRcdHRoaXMudHJlZSA9IHBhcmVudC50cmVlO1xuXHRcdHRoaXMudWwgPSBudWxsO1xuXHRcdHRoaXMubGkgPSBudWxsOyAvLyA8bGkgaWQ9J2tleScgZnRub2RlPXRoaXM+IHRhZ1xuXHRcdHRoaXMuc3RhdHVzTm9kZVR5cGUgPSBudWxsOyAvLyBpZiB0aGlzIGlzIGEgdGVtcC4gbm9kZSB0byBkaXNwbGF5IHRoZSBzdGF0dXMgb2YgaXRzIHBhcmVudFxuXHRcdHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlOyAvLyBpZiB0aGlzIG5vZGUgaXRzZWxmIGlzIGxvYWRpbmdcblx0XHR0aGlzLl9lcnJvciA9IG51bGw7IC8vIHttZXNzYWdlOiAnLi4uJ30gaWYgYSBsb2FkIGVycm9yIG9jY3VycmVkXG5cdFx0dGhpcy5kYXRhID0ge307XG5cblx0XHQvLyBUT0RPOiBtZXJnZSB0aGlzIGNvZGUgd2l0aCBub2RlLnRvRGljdCgpXG5cdFx0Ly8gY29weSBhdHRyaWJ1dGVzIGZyb20gb2JqIG9iamVjdFxuXHRcdGZvciAoaSA9IDAsIGwgPSBOT0RFX0FUVFJTLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bmFtZSA9IE5PREVfQVRUUlNbaV07XG5cdFx0XHR0aGlzW25hbWVdID0gb2JqW25hbWVdO1xuXHRcdH1cblx0XHQvLyB1bnNlbGVjdGFibGVJZ25vcmUgYW5kIHVuc2VsZWN0YWJsZVN0YXR1cyBpbXBseSB1bnNlbGVjdGFibGVcblx0XHRpZiAoXG5cdFx0XHR0aGlzLnVuc2VsZWN0YWJsZUlnbm9yZSAhPSBudWxsIHx8XG5cdFx0XHR0aGlzLnVuc2VsZWN0YWJsZVN0YXR1cyAhPSBudWxsXG5cdFx0KSB7XG5cdFx0XHR0aGlzLnVuc2VsZWN0YWJsZSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChvYmouaGlkZUNoZWNrYm94KSB7XG5cdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcIidoaWRlQ2hlY2tib3gnIG5vZGUgb3B0aW9uIHdhcyByZW1vdmVkIGluIHYyLjIzLjA6IHVzZSAnY2hlY2tib3g6IGZhbHNlJ1wiXG5cdFx0XHQpO1xuXHRcdH1cblx0XHQvLyBub2RlLmRhdGEgKz0gb2JqLmRhdGFcblx0XHRpZiAob2JqLmRhdGEpIHtcblx0XHRcdCQuZXh0ZW5kKHRoaXMuZGF0YSwgb2JqLmRhdGEpO1xuXHRcdH1cblx0XHQvLyBDb3B5IGFsbCBvdGhlciBhdHRyaWJ1dGVzIHRvIHRoaXMuZGF0YS5OQU1FXG5cdFx0Zm9yIChuYW1lIGluIG9iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhTk9ERV9BVFRSX01BUFtuYW1lXSAmJlxuXHRcdFx0XHQhJC5pc0Z1bmN0aW9uKG9ialtuYW1lXSkgJiZcblx0XHRcdFx0IU5PTkVfTk9ERV9EQVRBX01BUFtuYW1lXVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIG5vZGUuZGF0YS5OQU1FID0gb2JqLk5BTUVcblx0XHRcdFx0dGhpcy5kYXRhW25hbWVdID0gb2JqW25hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpeCBtaXNzaW5nIGtleVxuXHRcdGlmICh0aGlzLmtleSA9PSBudWxsKSB7XG5cdFx0XHQvLyB0ZXN0IGZvciBudWxsIE9SIHVuZGVmaW5lZFxuXHRcdFx0aWYgKHRoaXMudHJlZS5vcHRpb25zLmRlZmF1bHRLZXkpIHtcblx0XHRcdFx0dGhpcy5rZXkgPSB0aGlzLnRyZWUub3B0aW9ucy5kZWZhdWx0S2V5KHRoaXMpO1xuXHRcdFx0XHRfYXNzZXJ0KHRoaXMua2V5LCBcImRlZmF1bHRLZXkoKSBtdXN0IHJldHVybiBhIHVuaXF1ZSBrZXlcIik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmtleSA9IFwiX1wiICsgRlQuX25leHROb2RlS2V5Kys7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMua2V5ID0gXCJcIiArIHRoaXMua2V5OyAvLyBDb252ZXJ0IHRvIHN0cmluZyAoIzIxNylcblx0XHR9XG5cblx0XHQvLyBGaXggdHJlZS5hY3RpdmVOb2RlXG5cdFx0Ly8gVE9ETzogbm90IGVsZWdhbnQ6IHdlIHVzZSBvYmouYWN0aXZlIGFzIG1hcmtlciB0byBzZXQgdHJlZS5hY3RpdmVOb2RlXG5cdFx0Ly8gd2hlbiBsb2FkaW5nIGZyb20gYSBkaWN0aW9uYXJ5LlxuXHRcdGlmIChvYmouYWN0aXZlKSB7XG5cdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHR0aGlzLnRyZWUuYWN0aXZlTm9kZSA9PT0gbnVsbCxcblx0XHRcdFx0XCJvbmx5IG9uZSBhY3RpdmUgbm9kZSBhbGxvd2VkXCJcblx0XHRcdCk7XG5cdFx0XHR0aGlzLnRyZWUuYWN0aXZlTm9kZSA9IHRoaXM7XG5cdFx0fVxuXHRcdGlmIChvYmouc2VsZWN0ZWQpIHtcblx0XHRcdC8vICMxODZcblx0XHRcdHRoaXMudHJlZS5sYXN0U2VsZWN0ZWROb2RlID0gdGhpcztcblx0XHR9XG5cdFx0Ly8gVE9ETzogaGFuZGxlIG9iai5mb2N1cyA9IHRydWVcblxuXHRcdC8vIENyZWF0ZSBjaGlsZCBub2Rlc1xuXHRcdGNsID0gb2JqLmNoaWxkcmVuO1xuXHRcdGlmIChjbCkge1xuXHRcdFx0aWYgKGNsLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLl9zZXRDaGlsZHJlbihjbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBpZiBhbiBlbXB0eSBhcnJheSB3YXMgcGFzc2VkIGZvciBhIGxhenkgbm9kZSwga2VlcCBpdCwgaW4gb3JkZXIgdG8gbWFyayBpdCAnbG9hZGVkJ1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuID0gdGhpcy5sYXp5ID8gW10gOiBudWxsO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gQWRkIHRvIGtleS9yZWYgbWFwIChleGNlcHQgZm9yIHJvb3Qgbm9kZSlcblx0XHQvL1x0aWYoIHBhcmVudCApIHtcblx0XHR0aGlzLnRyZWUuX2NhbGxIb29rKFwidHJlZVJlZ2lzdGVyTm9kZVwiLCB0aGlzLnRyZWUsIHRydWUsIHRoaXMpO1xuXHRcdC8vXHR9XG5cdH1cblxuXHRGYW5jeXRyZWVOb2RlLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgRmFuY3l0cmVlTm9kZSMgKi8ge1xuXHRcdC8qIFJldHVybiB0aGUgZGlyZWN0IGNoaWxkIEZhbmN5dHJlZU5vZGUgd2l0aCBhIGdpdmVuIGtleSwgaW5kZXguICovXG5cdFx0X2ZpbmREaXJlY3RDaGlsZDogZnVuY3Rpb24ocHRyKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0bCxcblx0XHRcdFx0Y2wgPSB0aGlzLmNoaWxkcmVuO1xuXG5cdFx0XHRpZiAoY2wpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBwdHIgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gY2wubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2xbaV0ua2V5ID09PSBwdHIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNsW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgcHRyID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY2hpbGRyZW5bcHRyXTtcblx0XHRcdFx0fSBlbHNlIGlmIChwdHIucGFyZW50ID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHB0cjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHQvLyBUT0RPOiBhY3RpdmF0ZSgpXG5cdFx0Ly8gVE9ETzogYWN0aXZhdGVTaWxlbnRseSgpXG5cdFx0LyogSW50ZXJuYWwgaGVscGVyIGNhbGxlZCBpbiByZWN1cnNpdmUgYWRkQ2hpbGRyZW4gc2VxdWVuY2UuKi9cblx0XHRfc2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG5cdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHRjaGlsZHJlbiAmJiAoIXRoaXMuY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApLFxuXHRcdFx0XHRcIm9ubHkgaW5pdCBzdXBwb3J0ZWRcIlxuXHRcdFx0KTtcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaChuZXcgRmFuY3l0cmVlTm9kZSh0aGlzLCBjaGlsZHJlbltpXSkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50cmVlLl9jYWxsSG9vayhcblx0XHRcdFx0XCJ0cmVlU3RydWN0dXJlQ2hhbmdlZFwiLFxuXHRcdFx0XHR0aGlzLnRyZWUsXG5cdFx0XHRcdFwic2V0Q2hpbGRyZW5cIlxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEFwcGVuZCAob3IgaW5zZXJ0KSBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge05vZGVEYXRhW119IGNoaWxkcmVuIGFycmF5IG9mIGNoaWxkIG5vZGUgZGVmaW5pdGlvbnMgKGFsc28gc2luZ2xlIGNoaWxkIGFjY2VwdGVkKVxuXHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZSB8IHN0cmluZyB8IEludGVnZXJ9IFtpbnNlcnRCZWZvcmVdIGNoaWxkIG5vZGUgKG9yIGtleSBvciBpbmRleCBvZiBzdWNoKS5cblx0XHQgKiAgICAgSWYgb21pdHRlZCwgdGhlIG5ldyBjaGlsZHJlbiBhcmUgYXBwZW5kZWQuXG5cdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGV9IGZpcnN0IGNoaWxkIGFkZGVkXG5cdFx0ICpcblx0XHQgKiBAc2VlIEZhbmN5dHJlZU5vZGUjYXBwbHlQYXRjaFxuXHRcdCAqL1xuXHRcdGFkZENoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbiwgaW5zZXJ0QmVmb3JlKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0bCxcblx0XHRcdFx0cG9zLFxuXHRcdFx0XHRvcmlnRmlyc3RDaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpLFxuXHRcdFx0XHRvcmlnTGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKSxcblx0XHRcdFx0Zmlyc3ROb2RlID0gbnVsbCxcblx0XHRcdFx0bm9kZUxpc3QgPSBbXTtcblxuXHRcdFx0aWYgKCQuaXNQbGFpbk9iamVjdChjaGlsZHJlbikpIHtcblx0XHRcdFx0Y2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCF0aGlzLmNoaWxkcmVuKSB7XG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcdH1cblx0XHRcdGZvciAoaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0bm9kZUxpc3QucHVzaChuZXcgRmFuY3l0cmVlTm9kZSh0aGlzLCBjaGlsZHJlbltpXSkpO1xuXHRcdFx0fVxuXHRcdFx0Zmlyc3ROb2RlID0gbm9kZUxpc3RbMF07XG5cdFx0XHRpZiAoaW5zZXJ0QmVmb3JlID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uY29uY2F0KG5vZGVMaXN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFJldHVybnMgbnVsbCBpZiBpbnNlcnRCZWZvcmUgaXMgbm90IGEgZGlyZWN0IGNoaWxkOlxuXHRcdFx0XHRpbnNlcnRCZWZvcmUgPSB0aGlzLl9maW5kRGlyZWN0Q2hpbGQoaW5zZXJ0QmVmb3JlKTtcblx0XHRcdFx0cG9zID0gJC5pbkFycmF5KGluc2VydEJlZm9yZSwgdGhpcy5jaGlsZHJlbik7XG5cdFx0XHRcdF9hc3NlcnQocG9zID49IDAsIFwiaW5zZXJ0QmVmb3JlIG11c3QgYmUgYW4gZXhpc3RpbmcgY2hpbGRcIik7XG5cdFx0XHRcdC8vIGluc2VydCBub2RlTGlzdCBhZnRlciBjaGlsZHJlbltwb3NdXG5cdFx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlLmFwcGx5KFxuXHRcdFx0XHRcdHRoaXMuY2hpbGRyZW4sXG5cdFx0XHRcdFx0W3BvcywgMF0uY29uY2F0KG5vZGVMaXN0KVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9yaWdGaXJzdENoaWxkICYmICFpbnNlcnRCZWZvcmUpIHtcblx0XHRcdFx0Ly8gIzcwODogRmFzdCBwYXRoIC0tIGRvbid0IHJlbmRlciBldmVyeSBjaGlsZCBvZiByb290LCBqdXN0IHRoZSBuZXcgb25lcyFcblx0XHRcdFx0Ly8gIzcyMywgIzcyOTogYnV0IG9ubHkgaWYgaXQncyBhcHBlbmRlZCB0byBhbiBleGlzdGluZyBjaGlsZCBsaXN0XG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBub2RlTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRub2RlTGlzdFtpXS5yZW5kZXIoKTsgLy8gTmV3IG5vZGVzIHdlcmUgbmV2ZXIgcmVuZGVyZWQgYmVmb3JlXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQWRqdXN0IGNsYXNzZXMgd2hlcmUgc3RhdHVzIG1heSBoYXZlIGNoYW5nZWRcblx0XHRcdFx0Ly8gSGFzIGEgZmlyc3QgY2hpbGRcblx0XHRcdFx0aWYgKG9yaWdGaXJzdENoaWxkICE9PSB0aGlzLmdldEZpcnN0Q2hpbGQoKSkge1xuXHRcdFx0XHRcdC8vIERpZmZlcmVudCBmaXJzdCBjaGlsZCAtLSByZWNvbXB1dGUgY2xhc3Nlc1xuXHRcdFx0XHRcdG9yaWdGaXJzdENoaWxkLnJlbmRlclN0YXR1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvcmlnTGFzdENoaWxkICE9PSB0aGlzLmdldExhc3RDaGlsZCgpKSB7XG5cdFx0XHRcdFx0Ly8gRGlmZmVyZW50IGxhc3QgY2hpbGQgLS0gcmVjb21wdXRlIGNsYXNzZXNcblx0XHRcdFx0XHRvcmlnTGFzdENoaWxkLnJlbmRlclN0YXR1cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCF0aGlzLnBhcmVudCB8fCB0aGlzLnBhcmVudC51bCB8fCB0aGlzLnRyKSB7XG5cdFx0XHRcdC8vIHJlbmRlciBpZiB0aGUgcGFyZW50IHdhcyByZW5kZXJlZCAob3IgdGhpcyBpcyBhIHJvb3Qgbm9kZSlcblx0XHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLnRyZWUub3B0aW9ucy5zZWxlY3RNb2RlID09PSAzKSB7XG5cdFx0XHRcdHRoaXMuZml4U2VsZWN0aW9uM0Zyb21FbmROb2RlcygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy50cmlnZ2VyTW9kaWZ5Q2hpbGQoXG5cdFx0XHRcdFwiYWRkXCIsXG5cdFx0XHRcdG5vZGVMaXN0Lmxlbmd0aCA9PT0gMSA/IG5vZGVMaXN0WzBdIDogbnVsbFxuXHRcdFx0KTtcblx0XHRcdHJldHVybiBmaXJzdE5vZGU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBBZGQgY2xhc3MgdG8gbm9kZSdzIHNwYW4gdGFnIGFuZCB0byAuZXh0cmFDbGFzc2VzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBjbGFzcyBuYW1lXG5cdFx0ICpcblx0XHQgKiBAc2luY2UgMi4xN1xuXHRcdCAqL1xuXHRcdGFkZENsYXNzOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZSwgdHJ1ZSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBBcHBlbmQgb3IgcHJlcGVuZCBhIG5vZGUsIG9yIGFwcGVuZCBhIGNoaWxkIG5vZGUuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBjYWxscyBhZGRDaGlsZHJlbigpXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge05vZGVEYXRhfSBub2RlIG5vZGUgZGVmaW5pdGlvblxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZT1jaGlsZF0gJ2JlZm9yZScsICdhZnRlcicsICdmaXJzdENoaWxkJywgb3IgJ2NoaWxkJyAoJ292ZXInIGlzIGEgc3lub255bSBmb3IgJ2NoaWxkJylcblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX0gbmV3IG5vZGVcblx0XHQgKi9cblx0XHRhZGROb2RlOiBmdW5jdGlvbihub2RlLCBtb2RlKSB7XG5cdFx0XHRpZiAobW9kZSA9PT0gdW5kZWZpbmVkIHx8IG1vZGUgPT09IFwib3ZlclwiKSB7XG5cdFx0XHRcdG1vZGUgPSBcImNoaWxkXCI7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKG1vZGUpIHtcblx0XHRcdFx0Y2FzZSBcImFmdGVyXCI6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0UGFyZW50KCkuYWRkQ2hpbGRyZW4oXG5cdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0dGhpcy5nZXROZXh0U2libGluZygpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOlxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFBhcmVudCgpLmFkZENoaWxkcmVuKG5vZGUsIHRoaXMpO1xuXHRcdFx0XHRjYXNlIFwiZmlyc3RDaGlsZFwiOlxuXHRcdFx0XHRcdC8vIEluc2VydCBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIGlmIGFueVxuXHRcdFx0XHRcdHZhciBpbnNlcnRCZWZvcmUgPSB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlblswXSA6IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGRyZW4obm9kZSwgaW5zZXJ0QmVmb3JlKTtcblx0XHRcdFx0Y2FzZSBcImNoaWxkXCI6XG5cdFx0XHRcdGNhc2UgXCJvdmVyXCI6XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGRyZW4obm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRfYXNzZXJ0KGZhbHNlLCBcIkludmFsaWQgbW9kZTogXCIgKyBtb2RlKTtcblx0XHR9LFxuXHRcdC8qKkFkZCBjaGlsZCBzdGF0dXMgbm9kZXMgdGhhdCBpbmRpY2F0ZSAnTW9yZS4uLicsIGV0Yy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgYWxzbyBtYWludGFpbnMgdGhlIG5vZGUncyBgcGFydGxvYWRgIHByb3BlcnR5LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbnxvYmplY3R9IG5vZGUgb3B0aW9uYWwgbm9kZSBkZWZpbml0aW9uLiBQYXNzIGBmYWxzZWAgdG8gcmVtb3ZlIGFsbCBwYWdpbmcgbm9kZXMuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlPSdjaGlsZCddICdjaGlsZCd8Zmlyc3RDaGlsZCdcblx0XHQgKiBAc2luY2UgMi4xNVxuXHRcdCAqL1xuXHRcdGFkZFBhZ2luZ05vZGU6IGZ1bmN0aW9uKG5vZGUsIG1vZGUpIHtcblx0XHRcdHZhciBpLCBuO1xuXG5cdFx0XHRtb2RlID0gbW9kZSB8fCBcImNoaWxkXCI7XG5cdFx0XHRpZiAobm9kZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdG4gPSB0aGlzLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdGlmIChuLnN0YXR1c05vZGVUeXBlID09PSBcInBhZ2luZ1wiKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkKG4pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBhcnRsb2FkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG5vZGUgPSAkLmV4dGVuZChcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRpdGxlOiB0aGlzLnRyZWUub3B0aW9ucy5zdHJpbmdzLm1vcmVEYXRhLFxuXHRcdFx0XHRcdHN0YXR1c05vZGVUeXBlOiBcInBhZ2luZ1wiLFxuXHRcdFx0XHRcdGljb246IGZhbHNlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRub2RlXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5wYXJ0bG9hZCA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGROb2RlKG5vZGUsIG1vZGUpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogQXBwZW5kIG5ldyBub2RlIGFmdGVyIHRoaXMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBjYWxscyBhZGROb2RlKG5vZGUsICdhZnRlcicpXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge05vZGVEYXRhfSBub2RlIG5vZGUgZGVmaW5pdGlvblxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlfSBuZXcgbm9kZVxuXHRcdCAqL1xuXHRcdGFwcGVuZFNpYmxpbmc6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZE5vZGUobm9kZSwgXCJhZnRlclwiKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIChleHBlcmltZW50YWwpIEFwcGx5IGEgbW9kaWZpY2F0aW9uIChvciBuYXZpZ2F0aW9uKSBvcGVyYXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY21kXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXVxuXHRcdCAqIEBzZWUgRmFuY3l0cmVlI2FwcGx5Q29tbWFuZFxuXHRcdCAqIEBzaW5jZSAyLjMyXG5cdFx0ICovXG5cdFx0YXBwbHlDb21tYW5kOiBmdW5jdGlvbihjbWQsIG9wdHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyZWUuYXBwbHlDb21tYW5kKGNtZCwgdGhpcywgb3B0cyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBNb2RpZnkgZXhpc3RpbmcgY2hpbGQgbm9kZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge05vZGVQYXRjaH0gcGF0Y2hcblx0XHQgKiBAcmV0dXJucyB7JC5Qcm9taXNlfVxuXHRcdCAqIEBzZWUgRmFuY3l0cmVlTm9kZSNhZGRDaGlsZHJlblxuXHRcdCAqL1xuXHRcdGFwcGx5UGF0Y2g6IGZ1bmN0aW9uKHBhdGNoKSB7XG5cdFx0XHQvLyBwYXRjaCBba2V5LCBudWxsXSBtZWFucyAncmVtb3ZlJ1xuXHRcdFx0aWYgKHBhdGNoID09PSBudWxsKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRcdHJldHVybiBfZ2V0UmVzb2x2ZWRQcm9taXNlKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVE9ETzogbWFrZSBzdXJlIHRoYXQgcm9vdCBub2RlIGlzIG5vdCBjb2xsYXBzZWQgb3IgbW9kaWZpZWRcblx0XHRcdC8vIGNvcHkgKG1vc3QpIGF0dHJpYnV0ZXMgdG8gbm9kZS5BVFRSIG9yIG5vZGUuZGF0YS5BVFRSXG5cdFx0XHR2YXIgbmFtZSxcblx0XHRcdFx0cHJvbWlzZSxcblx0XHRcdFx0dixcblx0XHRcdFx0SUdOT1JFX01BUCA9IHsgY2hpbGRyZW46IHRydWUsIGV4cGFuZGVkOiB0cnVlLCBwYXJlbnQ6IHRydWUgfTsgLy8gVE9ETzogc2hvdWxkIGJlIGdsb2JhbFxuXG5cdFx0XHRmb3IgKG5hbWUgaW4gcGF0Y2gpIHtcblx0XHRcdFx0aWYgKHBhdGNoLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdFx0diA9IHBhdGNoW25hbWVdO1xuXHRcdFx0XHRcdGlmICghSUdOT1JFX01BUFtuYW1lXSAmJiAhJC5pc0Z1bmN0aW9uKHYpKSB7XG5cdFx0XHRcdFx0XHRpZiAoTk9ERV9BVFRSX01BUFtuYW1lXSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzW25hbWVdID0gdjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGF0YVtuYW1lXSA9IHY7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgYW5kL29yIGNyZWF0ZSBjaGlsZHJlblxuXHRcdFx0aWYgKHBhdGNoLmhhc093blByb3BlcnR5KFwiY2hpbGRyZW5cIikpIHtcblx0XHRcdFx0dGhpcy5yZW1vdmVDaGlsZHJlbigpO1xuXHRcdFx0XHRpZiAocGF0Y2guY2hpbGRyZW4pIHtcblx0XHRcdFx0XHQvLyBvbmx5IGlmIG5vdCBudWxsIGFuZCBub3QgZW1wdHkgbGlzdFxuXHRcdFx0XHRcdC8vIFRPRE86IGFkZENoaWxkcmVuIGluc3RlYWQ/XG5cdFx0XHRcdFx0dGhpcy5fc2V0Q2hpbGRyZW4ocGF0Y2guY2hpbGRyZW4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE86IGhvdyBjYW4gd2UgQVBQRU5EIG9yIElOU0VSVCBjaGlsZCBub2Rlcz9cblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyVGl0bGUoKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJTdGF0dXMoKTtcblx0XHRcdH1cblx0XHRcdC8vIEV4cGFuZCBjb2xsYXBzZSAoZmluYWwgc3RlcCwgc2luY2UgdGhpcyBtYXkgYmUgYXN5bmMpXG5cdFx0XHRpZiAocGF0Y2guaGFzT3duUHJvcGVydHkoXCJleHBhbmRlZFwiKSkge1xuXHRcdFx0XHRwcm9taXNlID0gdGhpcy5zZXRFeHBhbmRlZChwYXRjaC5leHBhbmRlZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9taXNlID0gX2dldFJlc29sdmVkUHJvbWlzZSh0aGlzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH0sXG5cdFx0LyoqIENvbGxhcHNlIGFsbCBzaWJsaW5nIG5vZGVzLlxuXHRcdCAqIEByZXR1cm5zIHskLlByb21pc2V9XG5cdFx0ICovXG5cdFx0Y29sbGFwc2VTaWJsaW5nczogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLl9jYWxsSG9vayhcIm5vZGVDb2xsYXBzZVNpYmxpbmdzXCIsIHRoaXMpO1xuXHRcdH0sXG5cdFx0LyoqIENvcHkgdGhpcyBub2RlIGFzIHNpYmxpbmcgb3IgY2hpbGQgb2YgYG5vZGVgLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtGYW5jeXRyZWVOb2RlfSBub2RlIHNvdXJjZSBub2RlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlPWNoaWxkXSAnYmVmb3JlJyB8ICdhZnRlcicgfCAnY2hpbGQnXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW21hcF0gY2FsbGJhY2sgZnVuY3Rpb24oTm9kZURhdGEpIHRoYXQgY291bGQgbW9kaWZ5IHRoZSBuZXcgbm9kZVxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlfSBuZXdcblx0XHQgKi9cblx0XHRjb3B5VG86IGZ1bmN0aW9uKG5vZGUsIG1vZGUsIG1hcCkge1xuXHRcdFx0cmV0dXJuIG5vZGUuYWRkTm9kZSh0aGlzLnRvRGljdCh0cnVlLCBtYXApLCBtb2RlKTtcblx0XHR9LFxuXHRcdC8qKiBDb3VudCBkaXJlY3QgYW5kIGluZGlyZWN0IGNoaWxkcmVuLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZGVlcD10cnVlXSBwYXNzICdmYWxzZScgdG8gb25seSBjb3VudCBkaXJlY3QgY2hpbGRyZW5cblx0XHQgKiBAcmV0dXJucyB7aW50fSBudW1iZXIgb2YgY2hpbGQgbm9kZXNcblx0XHQgKi9cblx0XHRjb3VudENoaWxkcmVuOiBmdW5jdGlvbihkZWVwKSB7XG5cdFx0XHR2YXIgY2wgPSB0aGlzLmNoaWxkcmVuLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRsLFxuXHRcdFx0XHRuO1xuXHRcdFx0aWYgKCFjbCkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdG4gPSBjbC5sZW5ndGg7XG5cdFx0XHRpZiAoZGVlcCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IG47IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRuICs9IGNsW2ldLmNvdW50Q2hpbGRyZW4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG47XG5cdFx0fSxcblx0XHQvLyBUT0RPOiBkZWFjdGl2YXRlKClcblx0XHQvKiogV3JpdGUgdG8gYnJvd3NlciBjb25zb2xlIGlmIGRlYnVnTGV2ZWwgPj0gNCAocHJlcGVuZGluZyBub2RlIGluZm8pXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyp9IG1zZyBzdHJpbmcgb3Igb2JqZWN0IG9yIGFycmF5IG9mIHN1Y2hcblx0XHQgKi9cblx0XHRkZWJ1ZzogZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRpZiAodGhpcy50cmVlLm9wdGlvbnMuZGVidWdMZXZlbCA+PSA0KSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRjb25zb2xlQXBwbHkoXCJsb2dcIiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKiBEZXByZWNhdGVkLlxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIDIwMTQtMDItMTYuIFVzZSByZXNldExhenkoKSBpbnN0ZWFkLlxuXHRcdCAqL1xuXHRcdGRpc2NhcmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy53YXJuKFxuXHRcdFx0XHRcIkZhbmN5dHJlZU5vZGUuZGlzY2FyZCgpIGlzIGRlcHJlY2F0ZWQgc2luY2UgMjAxNC0wMi0xNi4gVXNlIC5yZXNldExhenkoKSBpbnN0ZWFkLlwiXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXMucmVzZXRMYXp5KCk7XG5cdFx0fSxcblx0XHQvKiogUmVtb3ZlIERPTSBlbGVtZW50cyBmb3IgYWxsIGRlc2NlbmRlbnRzLiBNYXkgYmUgY2FsbGVkIG9uIC5jb2xsYXBzZSBldmVudFxuXHRcdCAqIHRvIGtlZXAgdGhlIERPTSBzbWFsbC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlU2VsZj1mYWxzZV1cblx0XHQgKi9cblx0XHRkaXNjYXJkTWFya3VwOiBmdW5jdGlvbihpbmNsdWRlU2VsZikge1xuXHRcdFx0dmFyIGZuID0gaW5jbHVkZVNlbGYgPyBcIm5vZGVSZW1vdmVNYXJrdXBcIiA6IFwibm9kZVJlbW92ZUNoaWxkTWFya3VwXCI7XG5cdFx0XHR0aGlzLnRyZWUuX2NhbGxIb29rKGZuLCB0aGlzKTtcblx0XHR9LFxuXHRcdC8qKiBXcml0ZSBlcnJvciB0byBicm93c2VyIGNvbnNvbGUgaWYgZGVidWdMZXZlbCA+PSAxIChwcmVwZW5kaW5nIHRyZWUgaW5mbylcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Kn0gbXNnIHN0cmluZyBvciBvYmplY3Qgb3IgYXJyYXkgb2Ygc3VjaFxuXHRcdCAqL1xuXHRcdGVycm9yOiBmdW5jdGlvbihtc2cpIHtcblx0XHRcdGlmICh0aGlzLnRyZWUub3B0aW9ucy5kZWJ1Z0xldmVsID49IDEpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsIHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0XHRcdGNvbnNvbGVBcHBseShcImVycm9yXCIsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipGaW5kIGFsbCBub2RlcyB0aGF0IG1hdGNoIGNvbmRpdGlvbiAoZXhjbHVkaW5nIHNlbGYpLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmcgfCBmdW5jdGlvbihub2RlKX0gbWF0Y2ggdGl0bGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IsIG9yIGFcblx0XHQgKiAgICAgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB0cnVlYCBpZiBhIG5vZGUgaXMgbWF0Y2hlZC5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZVtdfSBhcnJheSBvZiBub2RlcyAobWF5IGJlIGVtcHR5KVxuXHRcdCAqL1xuXHRcdGZpbmRBbGw6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRtYXRjaCA9ICQuaXNGdW5jdGlvbihtYXRjaCkgPyBtYXRjaCA6IF9tYWtlTm9kZVRpdGxlTWF0Y2hlcihtYXRjaCk7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHR0aGlzLnZpc2l0KGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0aWYgKG1hdGNoKG4pKSB7XG5cdFx0XHRcdFx0cmVzLnB1c2gobik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXHRcdC8qKkZpbmQgZmlyc3Qgbm9kZSB0aGF0IG1hdGNoZXMgY29uZGl0aW9uIChleGNsdWRpbmcgc2VsZikuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9uKG5vZGUpfSBtYXRjaCB0aXRsZSBzdHJpbmcgdG8gc2VhcmNoIGZvciwgb3IgYVxuXHRcdCAqICAgICBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIGEgbm9kZSBpcyBtYXRjaGVkLlxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlfSBtYXRjaGluZyBub2RlIG9yIG51bGxcblx0XHQgKiBAc2VlIEZhbmN5dHJlZU5vZGUjZmluZEFsbFxuXHRcdCAqL1xuXHRcdGZpbmRGaXJzdDogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdG1hdGNoID0gJC5pc0Z1bmN0aW9uKG1hdGNoKSA/IG1hdGNoIDogX21ha2VOb2RlVGl0bGVNYXRjaGVyKG1hdGNoKTtcblx0XHRcdHZhciByZXMgPSBudWxsO1xuXHRcdFx0dGhpcy52aXNpdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdGlmIChtYXRjaChuKSkge1xuXHRcdFx0XHRcdHJlcyA9IG47XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHQvKiogRmluZCBhIG5vZGUgcmVsYXRpdmUgdG8gc2VsZi5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gd2hlcmUgVGhlIGtleUNvZGUgdGhhdCB3b3VsZCBub3JtYWxseSB0cmlnZ2VyIHRoaXMgbW92ZSxcblx0XHQgKlx0XHRvciBhIGtleXdvcmQgKCdkb3duJywgJ2ZpcnN0JywgJ2xhc3QnLCAnbGVmdCcsICdwYXJlbnQnLCAncmlnaHQnLCAndXAnKS5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX1cblx0XHQgKiBAc2luY2UgdjIuMzFcblx0XHQgKi9cblx0XHRmaW5kUmVsYXRlZE5vZGU6IGZ1bmN0aW9uKHdoZXJlLCBpbmNsdWRlSGlkZGVuKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLmZpbmRSZWxhdGVkTm9kZSh0aGlzLCB3aGVyZSwgaW5jbHVkZUhpZGRlbik7XG5cdFx0fSxcblx0XHQvKiBBcHBseSBzZWxlY3Rpb24gc3RhdGUgKGludGVybmFsIHVzZSBvbmx5KSAqL1xuXHRcdF9jaGFuZ2VTZWxlY3RTdGF0dXNBdHRyczogZnVuY3Rpb24oc3RhdGUpIHtcblx0XHRcdHZhciBjaGFuZ2VkID0gZmFsc2UsXG5cdFx0XHRcdG9wdHMgPSB0aGlzLnRyZWUub3B0aW9ucyxcblx0XHRcdFx0dW5zZWxlY3RhYmxlID0gRlQuZXZhbE9wdGlvbihcblx0XHRcdFx0XHRcInVuc2VsZWN0YWJsZVwiLFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRvcHRzLFxuXHRcdFx0XHRcdGZhbHNlXG5cdFx0XHRcdCksXG5cdFx0XHRcdHVuc2VsZWN0YWJsZVN0YXR1cyA9IEZULmV2YWxPcHRpb24oXG5cdFx0XHRcdFx0XCJ1bnNlbGVjdGFibGVTdGF0dXNcIixcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0b3B0cyxcblx0XHRcdFx0XHR1bmRlZmluZWRcblx0XHRcdFx0KTtcblxuXHRcdFx0aWYgKHVuc2VsZWN0YWJsZSAmJiB1bnNlbGVjdGFibGVTdGF0dXMgIT0gbnVsbCkge1xuXHRcdFx0XHRzdGF0ZSA9IHVuc2VsZWN0YWJsZVN0YXR1cztcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBmYWxzZTpcblx0XHRcdFx0XHRjaGFuZ2VkID0gdGhpcy5zZWxlY3RlZCB8fCB0aGlzLnBhcnRzZWw7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMucGFydHNlbCA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIHRydWU6XG5cdFx0XHRcdFx0Y2hhbmdlZCA9ICF0aGlzLnNlbGVjdGVkIHx8ICF0aGlzLnBhcnRzZWw7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0dGhpcy5wYXJ0c2VsID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSB1bmRlZmluZWQ6XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRoaXMuc2VsZWN0ZWQgfHwgIXRoaXMucGFydHNlbDtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0dGhpcy5wYXJ0c2VsID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRfYXNzZXJ0KGZhbHNlLCBcImludmFsaWQgc3RhdGU6IFwiICsgc3RhdGUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcImZpeFNlbGVjdGlvbjNBZnRlckxvYWQoKSBfY2hhbmdlU2VsZWN0U3RhdHVzQXR0cnMoKVwiLCBzdGF0ZSwgY2hhbmdlZCk7XG5cdFx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0XHR0aGlzLnJlbmRlclN0YXR1cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBGaXggc2VsZWN0aW9uIHN0YXR1cywgYWZ0ZXIgdGhpcyBub2RlIHdhcyAoZGUpc2VsZWN0ZWQgaW4gbXVsdGktaGllciBtb2RlLlxuXHRcdCAqIFRoaXMgaW5jbHVkZXMgKGRlKXNlbGVjdGluZyBhbGwgY2hpbGRyZW4uXG5cdFx0ICovXG5cdFx0Zml4U2VsZWN0aW9uM0FmdGVyQ2xpY2s6IGZ1bmN0aW9uKGNhbGxPcHRzKSB7XG5cdFx0XHR2YXIgZmxhZyA9IHRoaXMuaXNTZWxlY3RlZCgpO1xuXG5cdFx0XHQvLyB0aGlzLmRlYnVnKFwiZml4U2VsZWN0aW9uM0FmdGVyQ2xpY2soKVwiKTtcblxuXHRcdFx0dGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdG5vZGUuX2NoYW5nZVNlbGVjdFN0YXR1c0F0dHJzKGZsYWcpO1xuXHRcdFx0XHRpZiAobm9kZS5yYWRpb2dyb3VwKSB7XG5cdFx0XHRcdFx0Ly8gIzkzMTogZG9uJ3QgKGRlKXNlbGVjdCB0aGlzIGJyYW5jaFxuXHRcdFx0XHRcdHJldHVybiBcInNraXBcIjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmZpeFNlbGVjdGlvbjNGcm9tRW5kTm9kZXMoY2FsbE9wdHMpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogRml4IHNlbGVjdGlvbiBzdGF0dXMgZm9yIG11bHRpLWhpZXIgbW9kZS5cblx0XHQgKiBPbmx5IGVuZC1ub2RlcyBhcmUgY29uc2lkZXJlZCB0byB1cGRhdGUgdGhlIGRlc2NlbmRhbnRzIGJyYW5jaCBhbmQgcGFyZW50cy5cblx0XHQgKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMgbm9kZSBoYXMgbG9hZGVkIG5ldyBjaGlsZHJlbiBvciBhZnRlclxuXHRcdCAqIGNoaWxkcmVuIGhhdmUgYmVlbiBtb2RpZmllZCB1c2luZyB0aGUgQVBJLlxuXHRcdCAqL1xuXHRcdGZpeFNlbGVjdGlvbjNGcm9tRW5kTm9kZXM6IGZ1bmN0aW9uKGNhbGxPcHRzKSB7XG5cdFx0XHR2YXIgb3B0cyA9IHRoaXMudHJlZS5vcHRpb25zO1xuXG5cdFx0XHQvLyB0aGlzLmRlYnVnKFwiZml4U2VsZWN0aW9uM0Zyb21FbmROb2RlcygpXCIpO1xuXHRcdFx0X2Fzc2VydChvcHRzLnNlbGVjdE1vZGUgPT09IDMsIFwiZXhwZWN0ZWQgc2VsZWN0TW9kZSAzXCIpO1xuXG5cdFx0XHQvLyBWaXNpdCBhbGwgZW5kIG5vZGVzIGFuZCBhZGp1c3QgdGhlaXIgcGFyZW50J3MgYHNlbGVjdGVkYCBhbmQgYHBhcnRzZWxgXG5cdFx0XHQvLyBhdHRyaWJ1dGVzLiBSZXR1cm4gc2VsZWN0aW9uIHN0YXRlIHRydWUsIGZhbHNlLCBvciB1bmRlZmluZWQuXG5cdFx0XHRmdW5jdGlvbiBfd2Fsayhub2RlKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdGwsXG5cdFx0XHRcdFx0Y2hpbGQsXG5cdFx0XHRcdFx0cyxcblx0XHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0XHRhbGxTZWxlY3RlZCxcblx0XHRcdFx0XHRzb21lU2VsZWN0ZWQsXG5cdFx0XHRcdFx0dW5zZWxJZ25vcmUsXG5cdFx0XHRcdFx0dW5zZWxTdGF0ZSxcblx0XHRcdFx0XHRjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cblx0XHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRcdC8vIGNoZWNrIGFsbCBjaGlsZHJlbiByZWN1cnNpdmVseVxuXHRcdFx0XHRcdGFsbFNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRzb21lU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0XHQvLyB0aGUgc2VsZWN0aW9uIHN0YXRlIG9mIGEgbm9kZSBpcyBub3QgcmVsZXZhbnQ7IHdlIG5lZWQgdGhlIGVuZC1ub2Rlc1xuXHRcdFx0XHRcdFx0cyA9IF93YWxrKGNoaWxkKTtcblx0XHRcdFx0XHRcdC8vIGlmKCAhY2hpbGQudW5zZWxlY3RhYmxlSWdub3JlICkge1xuXHRcdFx0XHRcdFx0dW5zZWxJZ25vcmUgPSBGVC5ldmFsT3B0aW9uKFxuXHRcdFx0XHRcdFx0XHRcInVuc2VsZWN0YWJsZUlnbm9yZVwiLFxuXHRcdFx0XHRcdFx0XHRjaGlsZCxcblx0XHRcdFx0XHRcdFx0Y2hpbGQsXG5cdFx0XHRcdFx0XHRcdG9wdHMsXG5cdFx0XHRcdFx0XHRcdGZhbHNlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWYgKCF1bnNlbElnbm9yZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAocyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRzb21lU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChzICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0YWxsU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcblx0XHRcdFx0XHRzdGF0ZSA9IGFsbFNlbGVjdGVkXG5cdFx0XHRcdFx0XHQ/IHRydWVcblx0XHRcdFx0XHRcdDogc29tZVNlbGVjdGVkXG5cdFx0XHRcdFx0XHQ/IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0OiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGFuIGVuZC1ub2RlOiBzaW1wbHkgcmVwb3J0IHRoZSBzdGF0dXNcblx0XHRcdFx0XHR1bnNlbFN0YXRlID0gRlQuZXZhbE9wdGlvbihcblx0XHRcdFx0XHRcdFwidW5zZWxlY3RhYmxlU3RhdHVzXCIsXG5cdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHRcdG9wdHMsXG5cdFx0XHRcdFx0XHR1bmRlZmluZWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHN0YXRlID0gdW5zZWxTdGF0ZSA9PSBudWxsID8gISFub2RlLnNlbGVjdGVkIDogISF1bnNlbFN0YXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vICM5Mzk6IEtlZXAgYSBgcGFydHNlbGAgZmxhZyB0aGF0IHdhcyBleHBsaWNpdGx5IHNldCBvbiBhIGxhenkgbm9kZVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bm9kZS5wYXJ0c2VsICYmXG5cdFx0XHRcdFx0IW5vZGUuc2VsZWN0ZWQgJiZcblx0XHRcdFx0XHRub2RlLmxhenkgJiZcblx0XHRcdFx0XHRub2RlLmNoaWxkcmVuID09IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0c3RhdGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5fY2hhbmdlU2VsZWN0U3RhdHVzQXR0cnMoc3RhdGUpO1xuXHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRfd2Fsayh0aGlzKTtcblxuXHRcdFx0Ly8gVXBkYXRlIHBhcmVudCdzIHN0YXRlXG5cdFx0XHR0aGlzLnZpc2l0UGFyZW50cyhmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdGwsXG5cdFx0XHRcdFx0Y2hpbGQsXG5cdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0dW5zZWxJZ25vcmUsXG5cdFx0XHRcdFx0dW5zZWxTdGF0ZSxcblx0XHRcdFx0XHRjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXG5cdFx0XHRcdFx0YWxsU2VsZWN0ZWQgPSB0cnVlLFxuXHRcdFx0XHRcdHNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0XHRcdHVuc2VsSWdub3JlID0gRlQuZXZhbE9wdGlvbihcblx0XHRcdFx0XHRcdFwidW5zZWxlY3RhYmxlSWdub3JlXCIsXG5cdFx0XHRcdFx0XHRjaGlsZCxcblx0XHRcdFx0XHRcdGNoaWxkLFxuXHRcdFx0XHRcdFx0b3B0cyxcblx0XHRcdFx0XHRcdGZhbHNlXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAoIXVuc2VsSWdub3JlKSB7XG5cdFx0XHRcdFx0XHR1bnNlbFN0YXRlID0gRlQuZXZhbE9wdGlvbihcblx0XHRcdFx0XHRcdFx0XCJ1bnNlbGVjdGFibGVTdGF0dXNcIixcblx0XHRcdFx0XHRcdFx0Y2hpbGQsXG5cdFx0XHRcdFx0XHRcdGNoaWxkLFxuXHRcdFx0XHRcdFx0XHRvcHRzLFxuXHRcdFx0XHRcdFx0XHR1bmRlZmluZWRcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9XG5cdFx0XHRcdFx0XHRcdHVuc2VsU3RhdGUgPT0gbnVsbFxuXHRcdFx0XHRcdFx0XHRcdD8gISFjaGlsZC5zZWxlY3RlZFxuXHRcdFx0XHRcdFx0XHRcdDogISF1bnNlbFN0YXRlO1xuXHRcdFx0XHRcdFx0Ly8gV2hlbiBmaXhpbmcgdGhlIHBhcmVudHMsIHdlIHRydXN0IHRoZSBzaWJsaW5nIHN0YXR1cyAoaS5lLlxuXHRcdFx0XHRcdFx0Ly8gd2UgZG9uJ3QgcmVjdXJzZSlcblx0XHRcdFx0XHRcdGlmIChzdGF0ZSB8fCBjaGlsZC5wYXJ0c2VsKSB7XG5cdFx0XHRcdFx0XHRcdHNvbWVTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIXN0YXRlKSB7XG5cdFx0XHRcdFx0XHRcdGFsbFNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuXHRcdFx0XHRzdGF0ZSA9IGFsbFNlbGVjdGVkID8gdHJ1ZSA6IHNvbWVTZWxlY3RlZCA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuXHRcdFx0XHRub2RlLl9jaGFuZ2VTZWxlY3RTdGF0dXNBdHRycyhzdGF0ZSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdC8vIFRPRE86IGZvY3VzKClcblx0XHQvKipcblx0XHQgKiBVcGRhdGUgbm9kZSBkYXRhLiBJZiBkaWN0IGNvbnRhaW5zICdjaGlsZHJlbicsIHRoZW4gYWxzbyByZXBsYWNlXG5cdFx0ICogdGhlIGhvbGUgc3ViIHRyZWUuXG5cdFx0ICogQHBhcmFtIHtOb2RlRGF0YX0gZGljdFxuXHRcdCAqXG5cdFx0ICogQHNlZSBGYW5jeXRyZWVOb2RlI2FkZENoaWxkcmVuXG5cdFx0ICogQHNlZSBGYW5jeXRyZWVOb2RlI2FwcGx5UGF0Y2hcblx0XHQgKi9cblx0XHRmcm9tRGljdDogZnVuY3Rpb24oZGljdCkge1xuXHRcdFx0Ly8gY29weSBhbGwgb3RoZXIgYXR0cmlidXRlcyB0byB0aGlzLmRhdGEueHh4XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGRpY3QpIHtcblx0XHRcdFx0aWYgKE5PREVfQVRUUl9NQVBbbmFtZV0pIHtcblx0XHRcdFx0XHQvLyBub2RlLk5BTUUgPSBkaWN0Lk5BTUVcblx0XHRcdFx0XHR0aGlzW25hbWVdID0gZGljdFtuYW1lXTtcblx0XHRcdFx0fSBlbHNlIGlmIChuYW1lID09PSBcImRhdGFcIikge1xuXHRcdFx0XHRcdC8vIG5vZGUuZGF0YSArPSBkaWN0LmRhdGFcblx0XHRcdFx0XHQkLmV4dGVuZCh0aGlzLmRhdGEsIGRpY3QuZGF0YSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0ISQuaXNGdW5jdGlvbihkaWN0W25hbWVdKSAmJlxuXHRcdFx0XHRcdCFOT05FX05PREVfREFUQV9NQVBbbmFtZV1cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gbm9kZS5kYXRhLk5BTUUgPSBkaWN0Lk5BTUVcblx0XHRcdFx0XHR0aGlzLmRhdGFbbmFtZV0gPSBkaWN0W25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGljdC5jaGlsZHJlbikge1xuXHRcdFx0XHQvLyByZWN1cnNpdmVseSBzZXQgY2hpbGRyZW4gYW5kIHJlbmRlclxuXHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oZGljdC5jaGlsZHJlbik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlbmRlclRpdGxlKCk7XG5cdFx0XHQvKlxuXHRcdFx0dmFyIGNoaWxkcmVuID0gZGljdC5jaGlsZHJlbjtcblx0XHRcdGlmKGNoaWxkcmVuID09PSB1bmRlZmluZWQpe1xuXHRcdFx0XHR0aGlzLmRhdGEgPSAkLmV4dGVuZCh0aGlzLmRhdGEsIGRpY3QpO1xuXHRcdFx0XHR0aGlzLnJlbmRlcigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkaWN0ID0gJC5leHRlbmQoe30sIGRpY3QpO1xuXHRcdFx0ZGljdC5jaGlsZHJlbiA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuZGF0YSA9ICQuZXh0ZW5kKHRoaXMuZGF0YSwgZGljdCk7XG5cdFx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0XHR0aGlzLmFkZENoaWxkKGNoaWxkcmVuKTtcblx0XHRcdCovXG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRoZSBsaXN0IG9mIGNoaWxkIG5vZGVzICh1bmRlZmluZWQgZm9yIHVuZXhwYW5kZWQgbGF6eSBub2RlcykuXG5cdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGVbXSB8IHVuZGVmaW5lZH1cblx0XHQgKi9cblx0XHRnZXRDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNDaGlsZHJlbigpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gVE9ETzogb25seSByZXF1aXJlZCBmb3IgbGF6eSBub2Rlcz9cblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDsgLy8gTGF6eSBub2RlOiB1bmxvYWRlZCwgY3VycmVudGx5IGxvYWRpbmcsIG9yIGxvYWQgZXJyb3Jcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmNoaWxkcmVuO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0aGUgZmlyc3QgY2hpbGQgbm9kZSBvciBudWxsLlxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlIHwgbnVsbH1cblx0XHQgKi9cblx0XHRnZXRGaXJzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoaWxkcmVuID8gdGhpcy5jaGlsZHJlblswXSA6IG51bGw7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRoZSAwLWJhc2VkIGNoaWxkIGluZGV4LlxuXHRcdCAqIEByZXR1cm5zIHtpbnR9XG5cdFx0ICovXG5cdFx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkcmVuLmluZGV4T2YodGhpcyk7XG5cdFx0XHRyZXR1cm4gJC5pbkFycmF5KHRoaXMsIHRoaXMucGFyZW50LmNoaWxkcmVuKTsgLy8gaW5kZXhPZiBkb2Vzbid0IHdvcmsgaW4gSUU3XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRoZSBoaWVyYXJjaGljYWwgY2hpbGQgaW5kZXggKDEtYmFzZWQsIGUuZy4gJzMuMi40JykuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9XCIuXCJdXG5cdFx0ICogQHBhcmFtIHtpbnR9IFtkaWdpdHM9MV1cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdGdldEluZGV4SGllcjogZnVuY3Rpb24oc2VwYXJhdG9yLCBkaWdpdHMpIHtcblx0XHRcdHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCBcIi5cIjtcblx0XHRcdHZhciBzLFxuXHRcdFx0XHRyZXMgPSBbXTtcblx0XHRcdCQuZWFjaCh0aGlzLmdldFBhcmVudExpc3QoZmFsc2UsIHRydWUpLCBmdW5jdGlvbihpLCBvKSB7XG5cdFx0XHRcdHMgPSBcIlwiICsgKG8uZ2V0SW5kZXgoKSArIDEpO1xuXHRcdFx0XHRpZiAoZGlnaXRzKSB7XG5cdFx0XHRcdFx0Ly8gcHJlcGVuZCBsZWFkaW5nIHplcm9lc1xuXHRcdFx0XHRcdHMgPSAoXCIwMDAwMDAwXCIgKyBzKS5zdWJzdHIoLWRpZ2l0cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzLnB1c2gocyk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByZXMuam9pbihzZXBhcmF0b3IpO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0aGUgcGFyZW50IGtleXMgc2VwYXJhdGVkIGJ5IG9wdGlvbnMua2V5UGF0aFNlcGFyYXRvciwgZS5nLiBcIi9pZF8xL2lkXzE3L2lkXzMyXCIuXG5cdFx0ICpcblx0XHQgKiAoVW5saWtlIGBub2RlLmdldFBhdGgoKWAsIHRoaXMgbWV0aG9kIHByZXBlbmRzIGEgXCIvXCIgYW5kIGludmVydHMgdGhlIGZpcnN0IGFyZ3VtZW50Lilcblx0XHQgKlxuXHRcdCAqIEBzZWUgRmFuY3l0cmVlTm9kZSNnZXRQYXRoXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZXhjbHVkZVNlbGY9ZmFsc2VdXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHQgKi9cblx0XHRnZXRLZXlQYXRoOiBmdW5jdGlvbihleGNsdWRlU2VsZikge1xuXHRcdFx0dmFyIHNlcCA9IHRoaXMudHJlZS5vcHRpb25zLmtleVBhdGhTZXBhcmF0b3I7XG5cblx0XHRcdHJldHVybiBzZXAgKyB0aGlzLmdldFBhdGgoIWV4Y2x1ZGVTZWxmLCBcImtleVwiLCBzZXApO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0aGUgbGFzdCBjaGlsZCBvZiB0aGlzIG5vZGUgb3IgbnVsbC5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZSB8IG51bGx9XG5cdFx0ICovXG5cdFx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmNoaWxkcmVuXG5cdFx0XHRcdD8gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG5cdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gbm9kZSBkZXB0aC4gMDogU3lzdGVtIHJvb3Qgbm9kZSwgMTogdmlzaWJsZSB0b3AtbGV2ZWwgbm9kZSwgMjogZmlyc3Qgc3ViLWxldmVsLCAuLi4gLlxuXHRcdCAqIEByZXR1cm5zIHtpbnR9XG5cdFx0ICovXG5cdFx0Z2V0TGV2ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGxldmVsID0gMCxcblx0XHRcdFx0ZHRuID0gdGhpcy5wYXJlbnQ7XG5cdFx0XHR3aGlsZSAoZHRuKSB7XG5cdFx0XHRcdGxldmVsKys7XG5cdFx0XHRcdGR0biA9IGR0bi5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGV2ZWw7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRoZSBzdWNjZXNzb3Igbm9kZSAodW5kZXIgdGhlIHNhbWUgcGFyZW50KSBvciBudWxsLlxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlIHwgbnVsbH1cblx0XHQgKi9cblx0XHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBUT0RPOiB1c2UgaW5kZXhPZiwgaWYgYXZhaWxhYmxlOiAobm90IGluIElFNilcblx0XHRcdGlmICh0aGlzLnBhcmVudCkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHRsLFxuXHRcdFx0XHRcdGFjID0gdGhpcy5wYXJlbnQuY2hpbGRyZW47XG5cblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IGFjLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHQvLyB1cCB0byBsZW5ndGgtMiwgc28gbmV4dChsYXN0KSA9IG51bGxcblx0XHRcdFx0XHRpZiAoYWNbaV0gPT09IHRoaXMpIHtcblx0XHRcdFx0XHRcdHJldHVybiBhY1tpICsgMV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdGhlIHBhcmVudCBub2RlIChudWxsIGZvciB0aGUgc3lzdGVtIHJvb3Qgbm9kZSkuXG5cdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGUgfCBudWxsfVxuXHRcdCAqL1xuXHRcdGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBUT0RPOiByZXR1cm4gbnVsbCBmb3IgdG9wLWxldmVsIG5vZGVzP1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50O1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgcGFyZW50IG5vZGVzICh0b3AtZG93bikuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZVJvb3Q9ZmFsc2VdIEluY2x1ZGUgdGhlIGludmlzaWJsZSBzeXN0ZW0gcm9vdCBub2RlLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVTZWxmPWZhbHNlXSBJbmNsdWRlIHRoZSBub2RlIGl0c2VsZi5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZVtdfVxuXHRcdCAqL1xuXHRcdGdldFBhcmVudExpc3Q6IGZ1bmN0aW9uKGluY2x1ZGVSb290LCBpbmNsdWRlU2VsZikge1xuXHRcdFx0dmFyIGwgPSBbXSxcblx0XHRcdFx0ZHRuID0gaW5jbHVkZVNlbGYgPyB0aGlzIDogdGhpcy5wYXJlbnQ7XG5cdFx0XHR3aGlsZSAoZHRuKSB7XG5cdFx0XHRcdGlmIChpbmNsdWRlUm9vdCB8fCBkdG4ucGFyZW50KSB7XG5cdFx0XHRcdFx0bC51bnNoaWZ0KGR0bik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHRuID0gZHRuLnBhcmVudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGhpZXJhY2hpY2FsIG5vZGUgcGF0aCwgZS5nLiBcImEvYi9jXCIuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZVNlbGY9dHJ1ZV1cblx0XHQgKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9ufSBbcGFydD1cInRpdGxlXCJdIG5vZGUgcHJvcGVydHkgbmFtZSBvciBjYWxsYmFja1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPVwiL1wiXVxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICogQHNpbmNlIHYyLjMxXG5cdFx0ICovXG5cdFx0Z2V0UGF0aDogZnVuY3Rpb24oaW5jbHVkZVNlbGYsIHBhcnQsIHNlcGFyYXRvcikge1xuXHRcdFx0aW5jbHVkZVNlbGYgPSBpbmNsdWRlU2VsZiAhPT0gZmFsc2U7XG5cdFx0XHRwYXJ0ID0gcGFydCB8fCBcInRpdGxlXCI7XG5cdFx0XHRzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgXCIvXCI7XG5cblx0XHRcdHZhciB2YWwsXG5cdFx0XHRcdHBhdGggPSBbXSxcblx0XHRcdFx0aXNGdW5jID0gJC5pc0Z1bmN0aW9uKHBhcnQpO1xuXG5cdFx0XHR0aGlzLnZpc2l0UGFyZW50cyhmdW5jdGlvbihuKSB7XG5cdFx0XHRcdGlmIChuLnBhcmVudCkge1xuXHRcdFx0XHRcdHZhbCA9IGlzRnVuYyA/IHBhcnQobikgOiBuW3BhcnRdO1xuXHRcdFx0XHRcdHBhdGgudW5zaGlmdCh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBpbmNsdWRlU2VsZik7XG5cdFx0XHRyZXR1cm4gcGF0aC5qb2luKHNlcGFyYXRvcik7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRoZSBwcmVkZWNlc3NvciBub2RlICh1bmRlciB0aGUgc2FtZSBwYXJlbnQpIG9yIG51bGwuXG5cdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGUgfCBudWxsfVxuXHRcdCAqL1xuXHRcdGdldFByZXZTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnBhcmVudCkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHRsLFxuXHRcdFx0XHRcdGFjID0gdGhpcy5wYXJlbnQuY2hpbGRyZW47XG5cblx0XHRcdFx0Zm9yIChpID0gMSwgbCA9IGFjLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdC8vIHN0YXJ0IHdpdGggMSwgc28gcHJldihmaXJzdCkgPSBudWxsXG5cdFx0XHRcdFx0aWYgKGFjW2ldID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYWNbaSAtIDFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc2VsZWN0ZWQgZGVzY2VuZGFudCBub2Rlcy5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdG9wT25QYXJlbnRzPWZhbHNlXSBvbmx5IHJldHVybiB0aGUgdG9wbW9zdCBzZWxlY3RlZFxuXHRcdCAqICAgICBub2RlICh1c2VmdWwgd2l0aCBzZWxlY3RNb2RlIDMpXG5cdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGVbXX1cblx0XHQgKi9cblx0XHRnZXRTZWxlY3RlZE5vZGVzOiBmdW5jdGlvbihzdG9wT25QYXJlbnRzKSB7XG5cdFx0XHR2YXIgbm9kZUxpc3QgPSBbXTtcblx0XHRcdHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0XHRpZiAobm9kZS5zZWxlY3RlZCkge1xuXHRcdFx0XHRcdG5vZGVMaXN0LnB1c2gobm9kZSk7XG5cdFx0XHRcdFx0aWYgKHN0b3BPblBhcmVudHMgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBcInNraXBcIjsgLy8gc3RvcCBwcm9jZXNzaW5nIHRoaXMgYnJhbmNoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBub2RlTGlzdDtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGhhcyBjaGlsZHJlbi4gUmV0dXJuIHVuZGVmaW5lZCBpZiBub3Qgc3VyZSwgaS5lLiB0aGUgbm9kZSBpcyBsYXp5IGFuZCBub3QgeWV0IGxvYWRlZCkuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWR9XG5cdFx0ICovXG5cdFx0aGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMubGF6eSkge1xuXHRcdFx0XHRpZiAodGhpcy5jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gbnVsbCBvciB1bmRlZmluZWQ6IE5vdCB5ZXQgbG9hZGVkXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIExvYWRlZCwgYnV0IHJlc3BvbnNlIHdhcyBlbXB0eVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHR0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuXHRcdFx0XHRcdHRoaXMuY2hpbGRyZW5bMF0uaXNTdGF0dXNOb2RlKClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gQ3VycmVudGx5IGxvYWRpbmcgb3IgbG9hZCBlcnJvclxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gISEodGhpcy5jaGlsZHJlbiAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGhhcyBgY2xhc3NOYW1lYCBkZWZpbmVkIGluIC5leHRyYUNsYXNzZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIGNsYXNzIG5hbWUgKHNlcGFyYXRlIG11bHRpcGxlIGNsYXNzZXMgYnkgc3BhY2UpXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICpcblx0XHQgKiBAc2luY2UgMi4zMlxuXHRcdCAqL1xuXHRcdGhhc0NsYXNzOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdChcIiBcIiArICh0aGlzLmV4dHJhQ2xhc3NlcyB8fCBcIlwiKSArIFwiIFwiKS5pbmRleE9mKFxuXHRcdFx0XHRcdFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCJcblx0XHRcdFx0KSA+PSAwXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIG5vZGUgaGFzIGtleWJvYXJkIGZvY3VzLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGhhc0ZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyZWUuaGFzRm9jdXMoKSAmJiB0aGlzLnRyZWUuZm9jdXNOb2RlID09PSB0aGlzO1xuXHRcdH0sXG5cdFx0LyoqIFdyaXRlIHRvIGJyb3dzZXIgY29uc29sZSBpZiBkZWJ1Z0xldmVsID49IDMgKHByZXBlbmRpbmcgbm9kZSBpbmZvKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsqfSBtc2cgc3RyaW5nIG9yIG9iamVjdCBvciBhcnJheSBvZiBzdWNoXG5cdFx0ICovXG5cdFx0aW5mbzogZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRpZiAodGhpcy50cmVlLm9wdGlvbnMuZGVidWdMZXZlbCA+PSAzKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRjb25zb2xlQXBwbHkoXCJpbmZvXCIsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgbm9kZSBpcyBhY3RpdmUgKHNlZSBhbHNvIEZhbmN5dHJlZU5vZGUjaXNTZWxlY3RlZCkuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5hY3RpdmVOb2RlID09PSB0aGlzO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIG5vZGUgaXMgdmVydGljYWxseSBiZWxvdyBgb3RoZXJOb2RlYCwgaS5lLiByZW5kZXJlZCBpbiBhIHN1YnNlcXVlbnQgcm93LlxuXHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gb3RoZXJOb2RlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICogQHNpbmNlIDIuMjhcblx0XHQgKi9cblx0XHRpc0JlbG93T2Y6IGZ1bmN0aW9uKG90aGVyTm9kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0SW5kZXhIaWVyKFwiLlwiLCA1KSA+IG90aGVyTm9kZS5nZXRJbmRleEhpZXIoXCIuXCIsIDUpO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIG5vZGUgaXMgYSBkaXJlY3QgY2hpbGQgb2Ygb3RoZXJOb2RlLlxuXHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gb3RoZXJOb2RlXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNDaGlsZE9mOiBmdW5jdGlvbihvdGhlck5vZGUpIHtcblx0XHRcdHJldHVybiB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCA9PT0gb3RoZXJOb2RlO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlLCBpZiBub2RlIGlzIGEgZGlyZWN0IG9yIGluZGlyZWN0IHN1YiBub2RlIG9mIG90aGVyTm9kZS5cblx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZU5vZGV9IG90aGVyTm9kZVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGlzRGVzY2VuZGFudE9mOiBmdW5jdGlvbihvdGhlck5vZGUpIHtcblx0XHRcdGlmICghb3RoZXJOb2RlIHx8IG90aGVyTm9kZS50cmVlICE9PSB0aGlzLnRyZWUpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHAgPSB0aGlzLnBhcmVudDtcblx0XHRcdHdoaWxlIChwKSB7XG5cdFx0XHRcdGlmIChwID09PSBvdGhlck5vZGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocCA9PT0gcC5wYXJlbnQpIHtcblx0XHRcdFx0XHQkLmVycm9yKFwiUmVjdXJzaXZlIHBhcmVudCBsaW5rOiBcIiArIHApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHAgPSBwLnBhcmVudDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGlzIGV4cGFuZGVkLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGlzRXhwYW5kZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5leHBhbmRlZDtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGlzIHRoZSBmaXJzdCBub2RlIG9mIGl0cyBwYXJlbnQncyBjaGlsZHJlbi5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0ZpcnN0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcCA9IHRoaXMucGFyZW50O1xuXHRcdFx0cmV0dXJuICFwIHx8IHAuY2hpbGRyZW5bMF0gPT09IHRoaXM7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgbm9kZSBpcyBhIGZvbGRlciwgaS5lLiBoYXMgdGhlIG5vZGUuZm9sZGVyIGF0dHJpYnV0ZSBzZXQuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNGb2xkZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5mb2xkZXI7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgbm9kZSBpcyB0aGUgbGFzdCBub2RlIG9mIGl0cyBwYXJlbnQncyBjaGlsZHJlbi5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0xhc3RTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwID0gdGhpcy5wYXJlbnQ7XG5cdFx0XHRyZXR1cm4gIXAgfHwgcC5jaGlsZHJlbltwLmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSB0aGlzO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIG5vZGUgaXMgbGF6eSAoZXZlbiBpZiBkYXRhIHdhcyBhbHJlYWR5IGxvYWRlZClcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRpc0xhenk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5sYXp5O1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIG5vZGUgaXMgbGF6eSBhbmQgbG9hZGVkLiBGb3Igbm9uLWxhenkgbm9kZXMgYWx3YXlzIHJldHVybiB0cnVlLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGlzTG9hZGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhdGhpcy5sYXp5IHx8IHRoaXMuaGFzQ2hpbGRyZW4oKSAhPT0gdW5kZWZpbmVkOyAvLyBBbHNvIGNoZWNrcyBpZiB0aGUgb25seSBjaGlsZCBpcyBhIHN0YXR1cyBub2RlXG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgY2hpbGRyZW4gYXJlIGN1cnJlbnRseSBiZWVpbmcgbG9hZGVkLCBpLmUuIGEgQWpheCByZXF1ZXN0IGlzIHBlbmRpbmcuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICovXG5cdFx0aXNMb2FkaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAhIXRoaXMuX2lzTG9hZGluZztcblx0XHR9LFxuXHRcdC8qXG5cdFx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjIuNC4wOiAgVXNlIGlzUm9vdE5vZGUoKSBpbnN0ZWFkXG5cdFx0ICovXG5cdFx0aXNSb290OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzUm9vdE5vZGUoKTtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCAodHJpLXN0YXRlKS5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKiBAc2luY2UgMi4yM1xuXHRcdCAqL1xuXHRcdGlzUGFydHNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuc2VsZWN0ZWQgJiYgISF0aGlzLnBhcnRzZWw7XG5cdFx0fSxcblx0XHQvKiogKGV4cGVyaW1lbnRhbCkgUmV0dXJuIHRydWUgaWYgdGhpcyBpcyBwYXJ0aWFsbHkgbG9hZGVkLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqIEBzaW5jZSAyLjE1XG5cdFx0ICovXG5cdFx0aXNQYXJ0bG9hZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gISF0aGlzLnBhcnRsb2FkO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIHRoaXMgaXMgdGhlIChpbnZpc2libGUpIHN5c3RlbSByb290IG5vZGUuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICogQHNpbmNlIDIuNFxuXHRcdCAqL1xuXHRcdGlzUm9vdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5yb290Tm9kZSA9PT0gdGhpcztcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBpLmUuIGhhcyBhIGNoZWNrbWFyayBzZXQgKHNlZSBhbHNvIEZhbmN5dHJlZU5vZGUjaXNBY3RpdmUpLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5zZWxlY3RlZDtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIG5vZGUgaXMgYSB0ZW1wb3JhcmlseSBnZW5lcmF0ZWQgc3lzdGVtIG5vZGUgbGlrZVxuXHRcdCAqICdsb2FkaW5nJywgJ3BhZ2luZycsIG9yICdlcnJvcicgKG5vZGUuc3RhdHVzTm9kZVR5cGUgY29udGFpbnMgdGhlIHR5cGUpLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGlzU3RhdHVzTm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gISF0aGlzLnN0YXR1c05vZGVUeXBlO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIHRoaXMgbm9kZSBpcyBhIHN0YXR1cyBub2RlIG9mIHR5cGUgJ3BhZ2luZycuXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0ICogQHNpbmNlIDIuMTVcblx0XHQgKi9cblx0XHRpc1BhZ2luZ05vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdHVzTm9kZVR5cGUgPT09IFwicGFnaW5nXCI7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgdGhpcyBhIHRvcCBsZXZlbCBub2RlLCBpLmUuIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSAoaW52aXNpYmxlKSBzeXN0ZW0gcm9vdCBub2RlLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqIEBzaW5jZSAyLjRcblx0XHQgKi9cblx0XHRpc1RvcExldmVsOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyZWUucm9vdE5vZGUgPT09IHRoaXMucGFyZW50O1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIG5vZGUgaXMgbGF6eSBhbmQgbm90IHlldCBsb2FkZWQuIEZvciBub24tbGF6eSBub2RlcyBhbHdheXMgcmV0dXJuIGZhbHNlLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdGlzVW5kZWZpbmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmhhc0NoaWxkcmVuKCkgPT09IHVuZGVmaW5lZDsgLy8gYWxzbyBjaGVja3MgaWYgdGhlIG9ubHkgY2hpbGQgaXMgYSBzdGF0dXMgbm9kZVxuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0cnVlIGlmIGFsbCBwYXJlbnQgbm9kZXMgYXJlIGV4cGFuZGVkLiBOb3RlOiB0aGlzIGRvZXMgbm90IGNoZWNrXG5cdFx0ICogd2hldGhlciB0aGUgbm9kZSBpcyBzY3JvbGxlZCBpbnRvIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlIHNjcmVlbi5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdGwsXG5cdFx0XHRcdG4sXG5cdFx0XHRcdGhhc0ZpbHRlciA9IHRoaXMudHJlZS5lbmFibGVGaWx0ZXIsXG5cdFx0XHRcdHBhcmVudHMgPSB0aGlzLmdldFBhcmVudExpc3QoZmFsc2UsIGZhbHNlKTtcblxuXHRcdFx0Ly8gVE9ETzogY2hlY2sgJChuLnNwYW4pLmlzKFwiOnZpc2libGVcIilcblx0XHRcdC8vIGkuZS4gcmV0dXJuIGZhbHNlIGZvciBub2RlcyAoYnV0IG5vdCBwYXJlbnRzKSB0aGF0IGFyZSBoaWRkZW5cblx0XHRcdC8vIGJ5IGEgZmlsdGVyXG5cdFx0XHRpZiAoaGFzRmlsdGVyICYmICF0aGlzLm1hdGNoICYmICF0aGlzLnN1Yk1hdGNoQ291bnQpIHtcblx0XHRcdFx0Ly8gdGhpcy5kZWJ1ZyggXCJpc1Zpc2libGU6IEhJRERFTiAoXCIgKyBoYXNGaWx0ZXIgKyBcIiwgXCIgKyB0aGlzLm1hdGNoICsgXCIsIFwiICsgdGhpcy5tYXRjaCArIFwiKVwiICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMCwgbCA9IHBhcmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdG4gPSBwYXJlbnRzW2ldO1xuXG5cdFx0XHRcdGlmICghbi5leHBhbmRlZCkge1xuXHRcdFx0XHRcdC8vIHRoaXMuZGVidWcoXCJpc1Zpc2libGU6IEhJRERFTiAocGFyZW50IGNvbGxhcHNlZClcIik7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIChoYXNGaWx0ZXIgJiYgIW4ubWF0Y2ggJiYgIW4uc3ViTWF0Y2hDb3VudCkge1xuXHRcdFx0XHQvLyBcdHRoaXMuZGVidWcoXCJpc1Zpc2libGU6IEhJRERFTiAoXCIgKyBoYXNGaWx0ZXIgKyBcIiwgXCIgKyB0aGlzLm1hdGNoICsgXCIsIFwiICsgdGhpcy5tYXRjaCArIFwiKVwiKTtcblx0XHRcdFx0Ly8gXHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdC8vIH1cblx0XHRcdH1cblx0XHRcdC8vIHRoaXMuZGVidWcoXCJpc1Zpc2libGU6IFZJU0lCTEVcIik7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKiBEZXByZWNhdGVkLlxuXHRcdCAqIEBkZXByZWNhdGVkIHNpbmNlIDIwMTQtMDItMTY6IHVzZSBsb2FkKCkgaW5zdGVhZC5cblx0XHQgKi9cblx0XHRsYXp5TG9hZDogZnVuY3Rpb24oZGlzY2FyZCkge1xuXHRcdFx0dGhpcy53YXJuKFxuXHRcdFx0XHRcIkZhbmN5dHJlZU5vZGUubGF6eUxvYWQoKSBpcyBkZXByZWNhdGVkIHNpbmNlIDIwMTQtMDItMTYuIFVzZSAubG9hZCgpIGluc3RlYWQuXCJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5sb2FkKGRpc2NhcmQpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogTG9hZCBhbGwgY2hpbGRyZW4gb2YgYSBsYXp5IG5vZGUgaWYgbmVjY2Vzc2FyeS4gVGhlIDxpPmV4cGFuZGVkPC9pPiBzdGF0ZSBpcyBtYWludGFpbmVkLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlUmVsb2FkPWZhbHNlXSBQYXNzIHRydWUgdG8gZGlzY2FyZCBhbnkgZXhpc3Rpbmcgbm9kZXMgYmVmb3JlLiBPdGhlcndpc2UgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nIGlmIHRoZSBub2RlIHdhcyBhbHJlYWR5IGxvYWRlZC5cblx0XHQgKiBAcmV0dXJucyB7JC5Qcm9taXNlfVxuXHRcdCAqL1xuXHRcdGxvYWQ6IGZ1bmN0aW9uKGZvcmNlUmVsb2FkKSB7XG5cdFx0XHR2YXIgcmVzLFxuXHRcdFx0XHRzb3VyY2UsXG5cdFx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0XHR3YXNFeHBhbmRlZCA9IHRoaXMuaXNFeHBhbmRlZCgpO1xuXG5cdFx0XHRfYXNzZXJ0KHRoaXMuaXNMYXp5KCksIFwibG9hZCgpIHJlcXVpcmVzIGEgbGF6eSBub2RlXCIpO1xuXHRcdFx0Ly8gX2Fzc2VydCggZm9yY2VSZWxvYWQgfHwgdGhpcy5pc1VuZGVmaW5lZCgpLCBcIlBhc3MgZm9yY2VSZWxvYWQ9dHJ1ZSB0byByZS1sb2FkIGEgbGF6eSBub2RlXCIgKTtcblx0XHRcdGlmICghZm9yY2VSZWxvYWQgJiYgIXRoaXMuaXNVbmRlZmluZWQoKSkge1xuXHRcdFx0XHRyZXR1cm4gX2dldFJlc29sdmVkUHJvbWlzZSh0aGlzKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLmlzTG9hZGVkKCkpIHtcblx0XHRcdFx0dGhpcy5yZXNldExhenkoKTsgLy8gYWxzbyBjb2xsYXBzZXNcblx0XHRcdH1cblx0XHRcdC8vIFRoaXMgbWV0aG9kIGlzIGFsc28gY2FsbGVkIGJ5IHNldEV4cGFuZGVkKCkgYW5kIGxvYWRLZXlQYXRoKCksIHNvIHdlXG5cdFx0XHQvLyBoYXZlIHRvIGF2b2lkIHJlY3Vyc2lvbi5cblx0XHRcdHNvdXJjZSA9IHRoaXMudHJlZS5fdHJpZ2dlck5vZGVFdmVudChcImxhenlMb2FkXCIsIHRoaXMpO1xuXHRcdFx0aWYgKHNvdXJjZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gIzY5XG5cdFx0XHRcdHJldHVybiBfZ2V0UmVzb2x2ZWRQcm9taXNlKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0X2Fzc2VydChcblx0XHRcdFx0dHlwZW9mIHNvdXJjZSAhPT0gXCJib29sZWFuXCIsXG5cdFx0XHRcdFwibGF6eUxvYWQgZXZlbnQgbXVzdCByZXR1cm4gc291cmNlIGluIGRhdGEucmVzdWx0XCJcblx0XHRcdCk7XG5cdFx0XHRyZXMgPSB0aGlzLnRyZWUuX2NhbGxIb29rKFwibm9kZUxvYWRDaGlsZHJlblwiLCB0aGlzLCBzb3VyY2UpO1xuXHRcdFx0aWYgKHdhc0V4cGFuZGVkKSB7XG5cdFx0XHRcdHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuXHRcdFx0XHRyZXMuYWx3YXlzKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYucmVuZGVyKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzLmFsd2F5cyhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnJlbmRlclN0YXR1cygpOyAvLyBmaXggZXhwYW5kZXIgaWNvbiB0byAnbG9hZGVkJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHQvKiogRXhwYW5kIGFsbCBwYXJlbnRzIGFuZCBvcHRpb25hbGx5IHNjcm9sbCBpbnRvIHZpc2libGUgYXJlYSBhcyBuZWNjZXNzYXJ5LlxuXHRcdCAqIFByb21pc2UgaXMgcmVzb2x2ZWQsIHdoZW4gbGF6eSBsb2FkaW5nIGFuZCBhbmltYXRpb25zIGFyZSBkb25lLlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gcGFzc2VkIHRvIGBzZXRFeHBhbmRlZCgpYC5cblx0XHQgKiAgICAgRGVmYXVsdHMgdG8ge25vQW5pbWF0aW9uOiBmYWxzZSwgbm9FdmVudHM6IGZhbHNlLCBzY3JvbGxJbnRvVmlldzogdHJ1ZX1cblx0XHQgKiBAcmV0dXJucyB7JC5Qcm9taXNlfVxuXHRcdCAqL1xuXHRcdG1ha2VWaXNpYmxlOiBmdW5jdGlvbihvcHRzKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRcdGRlZmVycmVkcyA9IFtdLFxuXHRcdFx0XHRkZmQgPSBuZXcgJC5EZWZlcnJlZCgpLFxuXHRcdFx0XHRwYXJlbnRzID0gdGhpcy5nZXRQYXJlbnRMaXN0KGZhbHNlLCBmYWxzZSksXG5cdFx0XHRcdGxlbiA9IHBhcmVudHMubGVuZ3RoLFxuXHRcdFx0XHRlZmZlY3RzID0gIShvcHRzICYmIG9wdHMubm9BbmltYXRpb24gPT09IHRydWUpLFxuXHRcdFx0XHRzY3JvbGwgPSAhKG9wdHMgJiYgb3B0cy5zY3JvbGxJbnRvVmlldyA9PT0gZmFsc2UpO1xuXG5cdFx0XHQvLyBFeHBhbmQgYm90dG9tLXVwLCBzbyBvbmx5IHRoZSB0b3Agbm9kZSBpcyBhbmltYXRlZFxuXHRcdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0Ly8gc2VsZi5kZWJ1ZyhcInB1c2hleHBhbmRcIiArIHBhcmVudHNbaV0pO1xuXHRcdFx0XHRkZWZlcnJlZHMucHVzaChwYXJlbnRzW2ldLnNldEV4cGFuZGVkKHRydWUsIG9wdHMpKTtcblx0XHRcdH1cblx0XHRcdCQud2hlbi5hcHBseSgkLCBkZWZlcnJlZHMpLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIEFsbCBleHBhbmRzIGhhdmUgZmluaXNoZWRcblx0XHRcdFx0Ly8gc2VsZi5kZWJ1ZyhcImV4cGFuZCBET05FXCIsIHNjcm9sbCk7XG5cdFx0XHRcdGlmIChzY3JvbGwpIHtcblx0XHRcdFx0XHRzZWxmLnNjcm9sbEludG9WaWV3KGVmZmVjdHMpLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQvLyBzZWxmLmRlYnVnKFwic2Nyb2xsIERPTkVcIik7XG5cdFx0XHRcdFx0XHRkZmQucmVzb2x2ZSgpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRmZC5yZXNvbHZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIGRmZC5wcm9taXNlKCk7XG5cdFx0fSxcblx0XHQvKiogTW92ZSB0aGlzIG5vZGUgdG8gdGFyZ2V0Tm9kZS5cblx0XHQgKiAgQHBhcmFtIHtGYW5jeXRyZWVOb2RlfSB0YXJnZXROb2RlXG5cdFx0ICogIEBwYXJhbSB7c3RyaW5nfSBtb2RlIDxwcmU+XG5cdFx0ICogICAgICAnY2hpbGQnOiBhcHBlbmQgdGhpcyBub2RlIGFzIGxhc3QgY2hpbGQgb2YgdGFyZ2V0Tm9kZS5cblx0XHQgKiAgICAgICAgICAgICAgIFRoaXMgaXMgdGhlIGRlZmF1bHQuIFRvIGJlIGNvbXBhdGJsZSB3aXRoIHRoZSBEJ24nZFxuXHRcdCAqICAgICAgICAgICAgICAgaGl0TW9kZSwgd2UgYWxzbyBhY2NlcHQgJ292ZXInLlxuXHRcdCAqICAgICAgJ2ZpcnN0Q2hpbGQnOiBhZGQgdGhpcyBub2RlIGFzIGZpcnN0IGNoaWxkIG9mIHRhcmdldE5vZGUuXG5cdFx0ICogICAgICAnYmVmb3JlJzogYWRkIHRoaXMgbm9kZSBhcyBzaWJsaW5nIGJlZm9yZSB0YXJnZXROb2RlLlxuXHRcdCAqICAgICAgJ2FmdGVyJzogYWRkIHRoaXMgbm9kZSBhcyBzaWJsaW5nIGFmdGVyIHRhcmdldE5vZGUuPC9wcmU+XG5cdFx0ICogIEBwYXJhbSB7ZnVuY3Rpb259IFttYXBdIG9wdGlvbmFsIGNhbGxiYWNrKEZhbmN5dHJlZU5vZGUpIHRvIGFsbG93IG1vZGlmY2F0aW9uc1xuXHRcdCAqL1xuXHRcdG1vdmVUbzogZnVuY3Rpb24odGFyZ2V0Tm9kZSwgbW9kZSwgbWFwKSB7XG5cdFx0XHRpZiAobW9kZSA9PT0gdW5kZWZpbmVkIHx8IG1vZGUgPT09IFwib3ZlclwiKSB7XG5cdFx0XHRcdG1vZGUgPSBcImNoaWxkXCI7XG5cdFx0XHR9IGVsc2UgaWYgKG1vZGUgPT09IFwiZmlyc3RDaGlsZFwiKSB7XG5cdFx0XHRcdGlmICh0YXJnZXROb2RlLmNoaWxkcmVuICYmIHRhcmdldE5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0bW9kZSA9IFwiYmVmb3JlXCI7XG5cdFx0XHRcdFx0dGFyZ2V0Tm9kZSA9IHRhcmdldE5vZGUuY2hpbGRyZW5bMF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bW9kZSA9IFwiY2hpbGRcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHBvcyxcblx0XHRcdFx0dHJlZSA9IHRoaXMudHJlZSxcblx0XHRcdFx0cHJldlBhcmVudCA9IHRoaXMucGFyZW50LFxuXHRcdFx0XHR0YXJnZXRQYXJlbnQgPVxuXHRcdFx0XHRcdG1vZGUgPT09IFwiY2hpbGRcIiA/IHRhcmdldE5vZGUgOiB0YXJnZXROb2RlLnBhcmVudDtcblxuXHRcdFx0aWYgKHRoaXMgPT09IHRhcmdldE5vZGUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmICghdGhpcy5wYXJlbnQpIHtcblx0XHRcdFx0JC5lcnJvcihcIkNhbm5vdCBtb3ZlIHN5c3RlbSByb290XCIpO1xuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXRQYXJlbnQuaXNEZXNjZW5kYW50T2YodGhpcykpIHtcblx0XHRcdFx0JC5lcnJvcihcIkNhbm5vdCBtb3ZlIGEgbm9kZSB0byBpdHMgb3duIGRlc2NlbmRhbnRcIik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGFyZ2V0UGFyZW50ICE9PSBwcmV2UGFyZW50KSB7XG5cdFx0XHRcdHByZXZQYXJlbnQudHJpZ2dlck1vZGlmeUNoaWxkKFwicmVtb3ZlXCIsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVW5saW5rIHRoaXMgbm9kZSBmcm9tIGN1cnJlbnQgcGFyZW50XG5cdFx0XHRpZiAodGhpcy5wYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGlmICh0aGlzLnBhcmVudCA9PT0gdGFyZ2V0UGFyZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuOyAvLyAjMjU4XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wYXJlbnQuY2hpbGRyZW4gPSB0aGlzLnBhcmVudC5sYXp5ID8gW10gOiBudWxsO1xuXHRcdFx0XHR0aGlzLnBhcmVudC5leHBhbmRlZCA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHRoaXMsIHRoaXMucGFyZW50LmNoaWxkcmVuKTtcblx0XHRcdFx0X2Fzc2VydChwb3MgPj0gMCwgXCJpbnZhbGlkIHNvdXJjZSBwYXJlbnRcIik7XG5cdFx0XHRcdHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShwb3MsIDEpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIGZyb20gc291cmNlIERPTSBwYXJlbnRcblx0XHRcdC8vIGlmKHRoaXMucGFyZW50LnVsKXtcblx0XHRcdC8vIFx0dGhpcy5wYXJlbnQudWwucmVtb3ZlQ2hpbGQodGhpcy5saSk7XG5cdFx0XHQvLyB9XG5cblx0XHRcdC8vIEluc2VydCB0aGlzIG5vZGUgdG8gdGFyZ2V0IHBhcmVudCdzIGNoaWxkIGxpc3Rcblx0XHRcdHRoaXMucGFyZW50ID0gdGFyZ2V0UGFyZW50O1xuXHRcdFx0aWYgKHRhcmdldFBhcmVudC5oYXNDaGlsZHJlbigpKSB7XG5cdFx0XHRcdHN3aXRjaCAobW9kZSkge1xuXHRcdFx0XHRcdGNhc2UgXCJjaGlsZFwiOlxuXHRcdFx0XHRcdFx0Ly8gQXBwZW5kIHRvIGV4aXN0aW5nIHRhcmdldCBjaGlsZHJlblxuXHRcdFx0XHRcdFx0dGFyZ2V0UGFyZW50LmNoaWxkcmVuLnB1c2godGhpcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XG5cdFx0XHRcdFx0XHQvLyBJbnNlcnQgdGhpcyBub2RlIGJlZm9yZSB0YXJnZXQgbm9kZVxuXHRcdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHRhcmdldE5vZGUsIHRhcmdldFBhcmVudC5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRfYXNzZXJ0KHBvcyA+PSAwLCBcImludmFsaWQgdGFyZ2V0IHBhcmVudFwiKTtcblx0XHRcdFx0XHRcdHRhcmdldFBhcmVudC5jaGlsZHJlbi5zcGxpY2UocG9zLCAwLCB0aGlzKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJhZnRlclwiOlxuXHRcdFx0XHRcdFx0Ly8gSW5zZXJ0IHRoaXMgbm9kZSBhZnRlciB0YXJnZXQgbm9kZVxuXHRcdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHRhcmdldE5vZGUsIHRhcmdldFBhcmVudC5jaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRfYXNzZXJ0KHBvcyA+PSAwLCBcImludmFsaWQgdGFyZ2V0IHBhcmVudFwiKTtcblx0XHRcdFx0XHRcdHRhcmdldFBhcmVudC5jaGlsZHJlbi5zcGxpY2UocG9zICsgMSwgMCwgdGhpcyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0JC5lcnJvcihcIkludmFsaWQgbW9kZSBcIiArIG1vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRQYXJlbnQuY2hpbGRyZW4gPSBbdGhpc107XG5cdFx0XHR9XG5cdFx0XHQvLyBQYXJlbnQgaGFzIG5vIDx1bD4gdGFnIHlldDpcblx0XHRcdC8vIGlmKCAhdGFyZ2V0UGFyZW50LnVsICkge1xuXHRcdFx0Ly8gXHQvLyBUaGlzIGlzIHRoZSBwYXJlbnQncyBmaXJzdCBjaGlsZDogY3JlYXRlIFVMIHRhZ1xuXHRcdFx0Ly8gXHQvLyAoSGlkZGVuLCBiZWNhdXNlIGl0IHdpbGwgYmVcblx0XHRcdC8vIFx0dGFyZ2V0UGFyZW50LnVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuXHRcdFx0Ly8gXHR0YXJnZXRQYXJlbnQudWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0Ly8gXHR0YXJnZXRQYXJlbnQubGkuYXBwZW5kQ2hpbGQodGFyZ2V0UGFyZW50LnVsKTtcblx0XHRcdC8vIH1cblx0XHRcdC8vIC8vIElzc3VlIDMxOTogQWRkIHRvIHRhcmdldCBET00gcGFyZW50IChvbmx5IGlmIG5vZGUgd2FzIGFscmVhZHkgcmVuZGVyZWQoZXhwYW5kZWQpKVxuXHRcdFx0Ly8gaWYodGhpcy5saSl7XG5cdFx0XHQvLyBcdHRhcmdldFBhcmVudC51bC5hcHBlbmRDaGlsZCh0aGlzLmxpKTtcblx0XHRcdC8vIH1cblxuXHRcdFx0Ly8gTGV0IGNhbGxlciBtb2RpZnkgdGhlIG5vZGVzXG5cdFx0XHRpZiAobWFwKSB7XG5cdFx0XHRcdHRhcmdldE5vZGUudmlzaXQobWFwLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdGlmICh0YXJnZXRQYXJlbnQgPT09IHByZXZQYXJlbnQpIHtcblx0XHRcdFx0dGFyZ2V0UGFyZW50LnRyaWdnZXJNb2RpZnlDaGlsZChcIm1vdmVcIiwgdGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBwcmV2UGFyZW50LnRyaWdnZXJNb2RpZnlDaGlsZChcInJlbW92ZVwiLCB0aGlzKTtcblx0XHRcdFx0dGFyZ2V0UGFyZW50LnRyaWdnZXJNb2RpZnlDaGlsZChcImFkZFwiLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBjcm9zcy10cmVlIG1vdmVzXG5cdFx0XHRpZiAodHJlZSAhPT0gdGFyZ2V0Tm9kZS50cmVlKSB7XG5cdFx0XHRcdC8vIEZpeCBub2RlLnRyZWUgZm9yIGFsbCBzb3VyY2Ugbm9kZXNcblx0XHRcdFx0Ly8gXHRfYXNzZXJ0KGZhbHNlLCBcIkNyb3NzLXRyZWUgbW92ZSBpcyBub3QgeWV0IGltcGxlbWVudGVkLlwiKTtcblx0XHRcdFx0dGhpcy53YXJuKFwiQ3Jvc3MtdHJlZSBtb3ZlVG8gaXMgZXhwZXJpbWVudGFsIVwiKTtcblx0XHRcdFx0dGhpcy52aXNpdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdFx0Ly8gVE9ETzogZml4IHNlbGVjdGlvbiBzdGF0ZSBhbmQgYWN0aXZhdGlvbiwgLi4uXG5cdFx0XHRcdFx0bi50cmVlID0gdGFyZ2V0Tm9kZS50cmVlO1xuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQSBjb2xsYXBvc2VkIG5vZGUgd29uJ3QgcmUtcmVuZGVyIGNoaWxkcmVuLCBzbyB3ZSBoYXZlIHRvIHJlbW92ZSBpdCBtYW51YWxseVxuXHRcdFx0Ly8gaWYoICF0YXJnZXRQYXJlbnQuZXhwYW5kZWQgKXtcblx0XHRcdC8vICAgcHJldlBhcmVudC51bC5yZW1vdmVDaGlsZCh0aGlzLmxpKTtcblx0XHRcdC8vIH1cblx0XHRcdHRyZWUuX2NhbGxIb29rKFwidHJlZVN0cnVjdHVyZUNoYW5nZWRcIiwgdHJlZSwgXCJtb3ZlVG9cIik7XG5cblx0XHRcdC8vIFVwZGF0ZSBIVE1MIG1hcmt1cFxuXHRcdFx0aWYgKCFwcmV2UGFyZW50LmlzRGVzY2VuZGFudE9mKHRhcmdldFBhcmVudCkpIHtcblx0XHRcdFx0cHJldlBhcmVudC5yZW5kZXIoKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0IXRhcmdldFBhcmVudC5pc0Rlc2NlbmRhbnRPZihwcmV2UGFyZW50KSAmJlxuXHRcdFx0XHR0YXJnZXRQYXJlbnQgIT09IHByZXZQYXJlbnRcblx0XHRcdCkge1xuXHRcdFx0XHR0YXJnZXRQYXJlbnQucmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUT0RPOiBmaXggc2VsZWN0aW9uIHN0YXRlXG5cdFx0XHQvLyBUT0RPOiBmaXggYWN0aXZlIHN0YXRlXG5cblx0XHRcdC8qXG5cdFx0XHR2YXIgdHJlZSA9IHRoaXMudHJlZTtcblx0XHRcdHZhciBvcHRzID0gdHJlZS5vcHRpb25zO1xuXHRcdFx0dmFyIHBlcnMgPSB0cmVlLnBlcnNpc3RlbmNlO1xuXG5cdFx0XHQvLyBBbHdheXMgZXhwYW5kLCBpZiBpdCdzIGJlbG93IG1pbkV4cGFuZExldmVsXG5cdFx0XHQvLyB0cmVlLmxvZ0RlYnVnIChcIiVzLl9hZGRDaGlsZE5vZGUoJW8pLCBsPSVvXCIsIHRoaXMsIGZ0bm9kZSwgZnRub2RlLmdldExldmVsKCkpO1xuXHRcdFx0aWYgKCBvcHRzLm1pbkV4cGFuZExldmVsID49IGZ0bm9kZS5nZXRMZXZlbCgpICkge1xuXHRcdFx0XHQvLyB0cmVlLmxvZ0RlYnVnIChcIkZvcmNlIGV4cGFuZCBmb3IgJW9cIiwgZnRub2RlKTtcblx0XHRcdFx0dGhpcy5iRXhwYW5kZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbiBtdWx0aS1oaWVyIG1vZGUsIHVwZGF0ZSB0aGUgcGFyZW50cyBzZWxlY3Rpb24gc3RhdGVcblx0XHRcdC8vIERUIGlzc3VlICM4Mjogb25seSBpZiBub3QgaW5pdGlhbGl6aW5nLCBiZWNhdXNlIHRoZSBjaGlsZHJlbiBtYXkgbm90IGV4aXN0IHlldFxuXHRcdFx0Ly8gaWYoICFmdG5vZGUuZGF0YS5pc1N0YXR1c05vZGUoKSAmJiBvcHRzLnNlbGVjdE1vZGU9PTMgJiYgIWlzSW5pdGlhbGl6aW5nIClcblx0XHRcdC8vIFx0ZnRub2RlLl9maXhTZWxlY3Rpb25TdGF0ZSgpO1xuXG5cdFx0XHQvLyBJbiBtdWx0aS1oaWVyIG1vZGUsIHVwZGF0ZSB0aGUgcGFyZW50cyBzZWxlY3Rpb24gc3RhdGVcblx0XHRcdGlmKCBmdG5vZGUuYlNlbGVjdGVkICYmIG9wdHMuc2VsZWN0TW9kZT09MyApIHtcblx0XHRcdFx0dmFyIHAgPSB0aGlzO1xuXHRcdFx0XHR3aGlsZSggcCApIHtcblx0XHRcdFx0XHRpZiggIXAuaGFzU3ViU2VsIClcblx0XHRcdFx0XHRcdHAuX3NldFN1YlNlbCh0cnVlKTtcblx0XHRcdFx0XHRwID0gcC5wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHJlbmRlciB0aGlzIG5vZGUgYW5kIHRoZSBuZXcgY2hpbGRcblx0XHRcdGlmICggdHJlZS5iRW5hYmxlVXBkYXRlIClcblx0XHRcdFx0dGhpcy5yZW5kZXIoKTtcblx0XHRcdHJldHVybiBmdG5vZGU7XG5cdFx0XHQqL1xuXHRcdH0sXG5cdFx0LyoqIFNldCBmb2N1cyByZWxhdGl2ZSB0byB0aGlzIG5vZGUgYW5kIG9wdGlvbmFsbHkgYWN0aXZhdGUuXG5cdFx0ICpcblx0XHQgKiAnbGVmdCcgY29sbGFwc2VzIHRoZSBub2RlIGlmIGl0IGlzIGV4cGFuZGVkLCBvciBtb3ZlIHRvIHRoZSBwYXJlbnRcblx0XHQgKiBvdGhlcndpc2UuXG5cdFx0ICogJ3JpZ2h0JyBleHBhbmRzIHRoZSBub2RlIGlmIGl0IGlzIGNvbGxhcHNlZCwgb3IgbW92ZSB0byB0aGUgZmlyc3Rcblx0XHQgKiBjaGlsZCBvdGhlcndpc2UuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHdoZXJlICdkb3duJywgJ2ZpcnN0JywgJ2xhc3QnLCAnbGVmdCcsICdwYXJlbnQnLCAncmlnaHQnLCBvciAndXAnLlxuXHRcdCAqICAgKEFsdGVybmF0aXZlbHkgdGhlIGtleUNvZGUgdGhhdCB3b3VsZCBub3JtYWxseSB0cmlnZ2VyIHRoaXMgbW92ZSxcblx0XHQgKiAgIGUuZy4gYCQudWkua2V5Q29kZS5MRUZUYCA9ICdsZWZ0Jy5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmF0ZT10cnVlXVxuXHRcdCAqIEByZXR1cm5zIHskLlByb21pc2V9XG5cdFx0ICovXG5cdFx0bmF2aWdhdGU6IGZ1bmN0aW9uKHdoZXJlLCBhY3RpdmF0ZSkge1xuXHRcdFx0dmFyIG5vZGUsXG5cdFx0XHRcdEtDID0gJC51aS5rZXlDb2RlO1xuXG5cdFx0XHQvLyBIYW5kbGUgb3B0aW9uYWwgZXhwYW5kL2NvbGxhcHNlIGFjdGlvbiBmb3IgTEVGVC9SSUdIVFxuXHRcdFx0c3dpdGNoICh3aGVyZSkge1xuXHRcdFx0XHRjYXNlIFwibGVmdFwiOlxuXHRcdFx0XHRjYXNlIEtDLkxFRlQ6XG5cdFx0XHRcdFx0aWYgKHRoaXMuZXhwYW5kZWQpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldEV4cGFuZGVkKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJyaWdodFwiOlxuXHRcdFx0XHRjYXNlIEtDLlJJR0hUOlxuXHRcdFx0XHRcdGlmICghdGhpcy5leHBhbmRlZCAmJiAodGhpcy5jaGlsZHJlbiB8fCB0aGlzLmxhenkpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRFeHBhbmRlZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdC8vIE90aGVyd2lzZSBhY3RpdmF0ZSBvciBmb2N1cyB0aGUgcmVsYXRlZCBub2RlXG5cdFx0XHRub2RlID0gdGhpcy5maW5kUmVsYXRlZE5vZGUod2hlcmUpO1xuXHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0Ly8gc2V0Rm9jdXMvc2V0QWN0aXZlIHdpbGwgc2Nyb2xsIGxhdGVyIChpZiBhdXRvU2Nyb2xsIGlzIHNwZWNpZmllZClcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRub2RlLm1ha2VWaXNpYmxlKHsgc2Nyb2xsSW50b1ZpZXc6IGZhbHNlIH0pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7fSAvLyAjMjcyXG5cdFx0XHRcdGlmIChhY3RpdmF0ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRub2RlLnNldEZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRSZXNvbHZlZFByb21pc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9kZS5zZXRBY3RpdmUoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMud2FybihcIkNvdWxkIG5vdCBmaW5kIHJlbGF0ZWQgbm9kZSAnXCIgKyB3aGVyZSArIFwiJy5cIik7XG5cdFx0XHRyZXR1cm4gX2dldFJlc29sdmVkUHJvbWlzZSgpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIHRoaXMgbm9kZSAobm90IGFsbG93ZWQgZm9yIHN5c3RlbSByb290KS5cblx0XHQgKi9cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogUmVtb3ZlIGNoaWxkTm9kZSBmcm9tIGxpc3Qgb2YgZGlyZWN0IGNoaWxkcmVuLlxuXHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gY2hpbGROb2RlXG5cdFx0ICovXG5cdFx0cmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5fY2FsbEhvb2soXCJub2RlUmVtb3ZlQ2hpbGRcIiwgdGhpcywgY2hpbGROb2RlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhbGwgY2hpbGQgbm9kZXMgYW5kIGRlc2NlbmRlbnRzLiBUaGlzIGNvbnZlcnRzIHRoZSBub2RlIGludG8gYSBsZWFmLjxicj5cblx0XHQgKiBJZiB0aGlzIHdhcyBhIGxhenkgbm9kZSwgaXQgaXMgc3RpbGwgY29uc2lkZXJlZCAnbG9hZGVkJzsgY2FsbCBub2RlLnJlc2V0TGF6eSgpXG5cdFx0ICogaW4gb3JkZXIgdG8gdHJpZ2dlciBsYXp5TG9hZCBvbiBuZXh0IGV4cGFuZC5cblx0XHQgKi9cblx0XHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLl9jYWxsSG9vayhcIm5vZGVSZW1vdmVDaGlsZHJlblwiLCB0aGlzKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBjbGFzcyBmcm9tIG5vZGUncyBzcGFuIHRhZyBhbmQgLmV4dHJhQ2xhc3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgY2xhc3MgbmFtZVxuXHRcdCAqXG5cdFx0ICogQHNpbmNlIDIuMTdcblx0XHQgKi9cblx0XHRyZW1vdmVDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc05hbWUsIGZhbHNlKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgbWV0aG9kIHJlbmRlcnMgYW5kIHVwZGF0ZXMgYWxsIEhUTUwgbWFya3VwIHRoYXQgaXMgcmVxdWlyZWRcblx0XHQgKiB0byBkaXNwbGF5IHRoaXMgbm9kZSBpbiBpdHMgY3VycmVudCBzdGF0ZS48YnI+XG5cdFx0ICogTm90ZTpcblx0XHQgKiA8dWw+XG5cdFx0ICogPGxpPkl0IHNob3VsZCBvbmx5IGJlIG5lY2Nlc3NhcnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBhZnRlciB0aGUgbm9kZSBvYmplY3Rcblx0XHQgKiAgICAgd2FzIG1vZGlmaWVkIGJ5IGRpcmVjdCBhY2Nlc3MgdG8gaXRzIHByb3BlcnRpZXMsIGJlY2F1c2UgdGhlIGNvbW1vblxuXHRcdCAqICAgICBBUEkgbWV0aG9kcyAobm9kZS5zZXRUaXRsZSgpLCBtb3ZlVG8oKSwgYWRkQ2hpbGRyZW4oKSwgcmVtb3ZlKCksIC4uLilcblx0XHQgKiAgICAgYWxyZWFkeSBoYW5kbGUgdGhpcy5cblx0XHQgKiA8bGk+IHtAbGluayBGYW5jeXRyZWVOb2RlI3JlbmRlclRpdGxlfSBhbmQge0BsaW5rIEZhbmN5dHJlZU5vZGUjcmVuZGVyU3RhdHVzfVxuXHRcdCAqICAgICBhcmUgaW1wbGllZC4gSWYgY2hhbmdlcyBhcmUgbW9yZSBsb2NhbCwgY2FsbGluZyBvbmx5IHJlbmRlclRpdGxlKCkgb3Jcblx0XHQgKiAgICAgcmVuZGVyU3RhdHVzKCkgbWF5IGJlIHN1ZmZpY2llbnQgYW5kIGZhc3Rlci5cblx0XHQgKiA8L3VsPlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIHJlLXJlbmRlciwgZXZlbiBpZiBodG1sIG1hcmt1cCB3YXMgYWxyZWFkeSBjcmVhdGVkXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV0gYWxzbyByZW5kZXIgYWxsIGRlc2NlbmRhbnRzLCBldmVuIGlmIHBhcmVudCBpcyBjb2xsYXBzZWRcblx0XHQgKi9cblx0XHRyZW5kZXI6IGZ1bmN0aW9uKGZvcmNlLCBkZWVwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLl9jYWxsSG9vayhcIm5vZGVSZW5kZXJcIiwgdGhpcywgZm9yY2UsIGRlZXApO1xuXHRcdH0sXG5cdFx0LyoqIENyZWF0ZSBIVE1MIG1hcmt1cCBmb3IgdGhlIG5vZGUncyBvdXRlciBgPHNwYW4+YCAoZXhwYW5kZXIsIGNoZWNrYm94LCBpY29uLCBhbmQgdGl0bGUpLlxuXHRcdCAqIEltcGxpZXMge0BsaW5rIEZhbmN5dHJlZU5vZGUjcmVuZGVyU3RhdHVzfS5cblx0XHQgKiBAc2VlIEZhbmN5dHJlZV9Ib29rcyNub2RlUmVuZGVyVGl0bGVcblx0XHQgKi9cblx0XHRyZW5kZXJUaXRsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLl9jYWxsSG9vayhcIm5vZGVSZW5kZXJUaXRsZVwiLCB0aGlzKTtcblx0XHR9LFxuXHRcdC8qKiBVcGRhdGUgZWxlbWVudCdzIENTUyBjbGFzc2VzIGFjY29yZGluZyB0byBub2RlIHN0YXRlLlxuXHRcdCAqIEBzZWUgRmFuY3l0cmVlX0hvb2tzI25vZGVSZW5kZXJTdGF0dXNcblx0XHQgKi9cblx0XHRyZW5kZXJTdGF0dXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5fY2FsbEhvb2soXCJub2RlUmVuZGVyU3RhdHVzXCIsIHRoaXMpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogKGV4cGVyaW1lbnRhbCkgUmVwbGFjZSB0aGlzIG5vZGUgd2l0aCBgc291cmNlYC5cblx0XHQgKiAoQ3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGZvciBwYWdpbmcgbm9kZXMuKVxuXHRcdCAqIEBwYXJhbSB7Tm9kZURhdGFbXX0gc291cmNlIExpc3Qgb2YgY2hpbGQgbm9kZSBkZWZpbml0aW9uc1xuXHRcdCAqIEBzaW5jZSAyLjE1XG5cdFx0ICovXG5cdFx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0dmFyIHJlcyxcblx0XHRcdFx0cGFyZW50ID0gdGhpcy5wYXJlbnQsXG5cdFx0XHRcdHBvcyA9ICQuaW5BcnJheSh0aGlzLCBwYXJlbnQuY2hpbGRyZW4pLFxuXHRcdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdFx0X2Fzc2VydChcblx0XHRcdFx0dGhpcy5pc1BhZ2luZ05vZGUoKSxcblx0XHRcdFx0XCJyZXBsYWNlV2l0aCgpIGN1cnJlbnRseSByZXF1aXJlcyBhIHBhZ2luZyBzdGF0dXMgbm9kZVwiXG5cdFx0XHQpO1xuXG5cdFx0XHRyZXMgPSB0aGlzLnRyZWUuX2NhbGxIb29rKFwibm9kZUxvYWRDaGlsZHJlblwiLCB0aGlzLCBzb3VyY2UpO1xuXHRcdFx0cmVzLmRvbmUoZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XHQvLyBOZXcgbm9kZXMgYXJlIGN1cnJlbnRseSBjaGlsZHJlbiBvZiBgdGhpc2AuXG5cdFx0XHRcdHZhciBjaGlsZHJlbiA9IHNlbGYuY2hpbGRyZW47XG5cdFx0XHRcdC8vIFByZXBlbmQgbmV3bHkgbG9hZGVkIGNoaWxkIG5vZGVzIHRvIGB0aGlzYFxuXHRcdFx0XHQvLyBNb3ZlIG5ldyBjaGlsZHJlbiBhZnRlciBzZWxmXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLnBhcmVudCA9IHBhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnQuY2hpbGRyZW4uc3BsaWNlLmFwcGx5KFxuXHRcdFx0XHRcdHBhcmVudC5jaGlsZHJlbixcblx0XHRcdFx0XHRbcG9zICsgMSwgMF0uY29uY2F0KGNoaWxkcmVuKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBzZWxmXG5cdFx0XHRcdHNlbGYuY2hpbGRyZW4gPSBudWxsO1xuXHRcdFx0XHRzZWxmLnJlbW92ZSgpO1xuXHRcdFx0XHQvLyBSZWRyYXcgbmV3IG5vZGVzXG5cdFx0XHRcdHBhcmVudC5yZW5kZXIoKTtcblx0XHRcdFx0Ly8gVE9ETzogc2V0IG5vZGUucGFydGxvYWQgPSBmYWxzZSBpZiB0aGlzIHdhcyB0aGEgbGFzdCBwYWdpbmcgbm9kZT9cblx0XHRcdFx0Ly8gcGFyZW50LmFkZFBhZ2luZ05vZGUoZmFsc2UpO1xuXHRcdFx0fSkuZmFpbChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5zZXRFeHBhbmRlZCgpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0Ly8gJC5lcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogcmVwbGFjZVdpdGgoKVwiKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZSBhbGwgY2hpbGRyZW4sIGNvbGxhcHNlLCBhbmQgc2V0IHRoZSBsYXp5LWZsYWcsIHNvIHRoYXQgdGhlIGxhenlMb2FkXG5cdFx0ICogZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIG5leHQgZXhwYW5kLlxuXHRcdCAqL1xuXHRcdHJlc2V0TGF6eTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0XHR0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG5cdFx0XHR0aGlzLmxhenkgPSB0cnVlO1xuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMucmVuZGVyU3RhdHVzKCk7XG5cdFx0fSxcblx0XHQvKiogU2NoZWR1bGUgYWN0aXZpdHkgZm9yIGRlbGF5ZWQgZXhlY3V0aW9uIChjYW5jZWwgYW55IHBlbmRpbmcgcmVxdWVzdCkuXG5cdFx0ICogIHNjaGVkdWxlQWN0aW9uKCdjYW5jZWwnKSB3aWxsIG9ubHkgY2FuY2VsIGEgcGVuZGluZyByZXF1ZXN0IChpZiBhbnkpLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IG1zXG5cdFx0ICovXG5cdFx0c2NoZWR1bGVBY3Rpb246IGZ1bmN0aW9uKG1vZGUsIG1zKSB7XG5cdFx0XHRpZiAodGhpcy50cmVlLnRpbWVyKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRyZWUudGltZXIpO1xuXHRcdFx0XHR0aGlzLnRyZWUuZGVidWcoXCJjbGVhclRpbWVvdXQoJW8pXCIsIHRoaXMudHJlZS50aW1lcik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyZWUudGltZXIgPSBudWxsO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzOyAvLyByZXF1aXJlZCBmb3IgY2xvc3VyZXNcblx0XHRcdHN3aXRjaCAobW9kZSkge1xuXHRcdFx0XHRjYXNlIFwiY2FuY2VsXCI6XG5cdFx0XHRcdFx0Ly8gU2ltcGx5IG1hZGUgc3VyZSB0aGF0IHRpbWVyIHdhcyBjbGVhcmVkXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJleHBhbmRcIjpcblx0XHRcdFx0XHR0aGlzLnRyZWUudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c2VsZi50cmVlLmRlYnVnKFwic2V0VGltZW91dDogdHJpZ2dlciBleHBhbmRcIik7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEV4cGFuZGVkKHRydWUpO1xuXHRcdFx0XHRcdH0sIG1zKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImFjdGl2YXRlXCI6XG5cdFx0XHRcdFx0dGhpcy50cmVlLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHNlbGYudHJlZS5kZWJ1ZyhcInNldFRpbWVvdXQ6IHRyaWdnZXIgYWN0aXZhdGVcIik7XG5cdFx0XHRcdFx0XHRzZWxmLnNldEFjdGl2ZSh0cnVlKTtcblx0XHRcdFx0XHR9LCBtcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0JC5lcnJvcihcIkludmFsaWQgbW9kZSBcIiArIG1vZGUpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdGhpcy50cmVlLmRlYnVnKFwic2V0VGltZW91dCglcywgJXMpOiAlc1wiLCBtb2RlLCBtcywgdGhpcy50cmVlLnRpbWVyKTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFuIHwgUGxhaW5PYmplY3R9IFtlZmZlY3RzPWZhbHNlXSBhbmltYXRpb24gb3B0aW9ucy5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9bnVsbF0ge3RvcE5vZGU6IG51bGwsIGVmZmVjdHM6IC4uLiwgcGFyZW50OiAuLi59IHRoaXMgbm9kZSB3aWxsIHJlbWFpbiB2aXNpYmxlIGluXG5cdFx0ICogICAgIGFueSBjYXNlLCBldmVuIGlmIGB0aGlzYCBpcyBvdXRzaWRlIHRoZSBzY3JvbGwgcGFuZS5cblx0XHQgKiBAcmV0dXJucyB7JC5Qcm9taXNlfVxuXHRcdCAqL1xuXHRcdHNjcm9sbEludG9WaWV3OiBmdW5jdGlvbihlZmZlY3RzLCBvcHRpb25zKSB7XG5cdFx0XHRpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIF9pc05vZGUob3B0aW9ucykpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdFx0XCJzY3JvbGxJbnRvVmlldygpIHdpdGggJ3RvcE5vZGUnIG9wdGlvbiBpcyBkZXByZWNhdGVkIHNpbmNlIDIwMTQtMDUtMDguIFVzZSAnb3B0aW9ucy50b3BOb2RlJyBpbnN0ZWFkLlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaGUgc2Nyb2xsIHBhcmVudCBpcyB0eXBpY2FsbHkgdGhlIHBsYWluIHRyZWUncyA8VUw+IGNvbnRhaW5lci5cblx0XHRcdC8vIEZvciBleHQtdGFibGUsIHdlIGNob29zZSB0aGUgbmVhcmVzdCBwYXJlbnQgdGhhdCBoYXMgYHBvc2l0aW9uOiByZWxhdGl2ZWBcblx0XHRcdC8vIGFuZCBgb3ZlcmZsb3dgIHNldC5cblx0XHRcdC8vIChUaGlzIGRlZmF1bHQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGxvY2FsIG9yIGdsb2JhbCBgc2Nyb2xsUGFyZW50YCBvcHRpb24uKVxuXHRcdFx0dmFyIG9wdHMgPSAkLmV4dGVuZChcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlZmZlY3RzOlxuXHRcdFx0XHRcdFx0XHRlZmZlY3RzID09PSB0cnVlXG5cdFx0XHRcdFx0XHRcdFx0PyB7IGR1cmF0aW9uOiAyMDAsIHF1ZXVlOiBmYWxzZSB9XG5cdFx0XHRcdFx0XHRcdFx0OiBlZmZlY3RzLFxuXHRcdFx0XHRcdFx0c2Nyb2xsT2ZzOiB0aGlzLnRyZWUub3B0aW9ucy5zY3JvbGxPZnMsXG5cdFx0XHRcdFx0XHRzY3JvbGxQYXJlbnQ6IHRoaXMudHJlZS5vcHRpb25zLnNjcm9sbFBhcmVudCxcblx0XHRcdFx0XHRcdHRvcE5vZGU6IG51bGwsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRvcHRpb25zXG5cdFx0XHRcdCksXG5cdFx0XHRcdCRzY3JvbGxQYXJlbnQgPSBvcHRzLnNjcm9sbFBhcmVudCxcblx0XHRcdFx0JGNvbnRhaW5lciA9IHRoaXMudHJlZS4kY29udGFpbmVyLFxuXHRcdFx0XHRvdmVyZmxvd1kgPSAkY29udGFpbmVyLmNzcyhcIm92ZXJmbG93LXlcIik7XG5cblx0XHRcdGlmICghJHNjcm9sbFBhcmVudCkge1xuXHRcdFx0XHRpZiAodGhpcy50cmVlLnRib2R5KSB7XG5cdFx0XHRcdFx0JHNjcm9sbFBhcmVudCA9ICRjb250YWluZXIuc2Nyb2xsUGFyZW50KCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob3ZlcmZsb3dZID09PSBcInNjcm9sbFwiIHx8IG92ZXJmbG93WSA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHQkc2Nyb2xsUGFyZW50ID0gJGNvbnRhaW5lcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyAjOTIyIHBsYWluIHRyZWUgaW4gYSBub24tZml4ZWQtc2l6ZWQgVUwgc2Nyb2xscyBpbnNpZGUgaXRzIHBhcmVudFxuXHRcdFx0XHRcdCRzY3JvbGxQYXJlbnQgPSAkY29udGFpbmVyLnNjcm9sbFBhcmVudCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCEkc2Nyb2xsUGFyZW50LmpxdWVyeSkge1xuXHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0JHNjcm9sbFBhcmVudCA9ICQoJHNjcm9sbFBhcmVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCRzY3JvbGxQYXJlbnRbMF0gPT09IGRvY3VtZW50IHx8XG5cdFx0XHRcdCRzY3JvbGxQYXJlbnRbMF0gPT09IGRvY3VtZW50LmJvZHlcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBgZG9jdW1lbnRgIG1heSBiZSByZXR1cm5lZCBieSAkKCkuc2Nyb2xsUGFyZW50KCksIGlmIG5vdGhpbmcgaXMgZm91bmQsXG5cdFx0XHRcdC8vIGJ1dCB3b3VsZCBub3Qgd29yazogKHNlZSAjODk0KVxuXHRcdFx0XHR0aGlzLmRlYnVnKFxuXHRcdFx0XHRcdFwic2Nyb2xsSW50b1ZpZXcoKTogbm9ybWFsaXppbmcgc2Nyb2xsUGFyZW50IHRvICd3aW5kb3cnOlwiLFxuXHRcdFx0XHRcdCRzY3JvbGxQYXJlbnRbMF1cblx0XHRcdFx0KTtcblx0XHRcdFx0JHNjcm9sbFBhcmVudCA9ICQod2luZG93KTtcblx0XHRcdH1cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBvbmUtdmFyXG5cdFx0XHR2YXIgdG9wTm9kZVksXG5cdFx0XHRcdG5vZGVZLFxuXHRcdFx0XHRob3J6U2Nyb2xsYmFySGVpZ2h0LFxuXHRcdFx0XHRjb250YWluZXJPZmZzZXRUb3AsXG5cdFx0XHRcdGRmZCA9IG5ldyAkLkRlZmVycmVkKCksXG5cdFx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRub2RlSGVpZ2h0ID0gJCh0aGlzLnNwYW4pLmhlaWdodCgpLFxuXHRcdFx0XHR0b3BPZnMgPSBvcHRzLnNjcm9sbE9mcy50b3AgfHwgMCxcblx0XHRcdFx0Ym90dG9tT2ZzID0gb3B0cy5zY3JvbGxPZnMuYm90dG9tIHx8IDAsXG5cdFx0XHRcdGNvbnRhaW5lckhlaWdodCA9ICRzY3JvbGxQYXJlbnQuaGVpZ2h0KCksXG5cdFx0XHRcdHNjcm9sbFRvcCA9ICRzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdCRhbmltYXRlVGFyZ2V0ID0gJHNjcm9sbFBhcmVudCxcblx0XHRcdFx0aXNQYXJlbnRXaW5kb3cgPSAkc2Nyb2xsUGFyZW50WzBdID09PSB3aW5kb3csXG5cdFx0XHRcdHRvcE5vZGUgPSBvcHRzLnRvcE5vZGUgfHwgbnVsbCxcblx0XHRcdFx0bmV3U2Nyb2xsVG9wID0gbnVsbDtcblxuXHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcInNjcm9sbEludG9WaWV3KCksIHNjcm9sbFRvcD1cIiArIHNjcm9sbFRvcCwgb3B0cy5zY3JvbGxPZnMpO1xuXHRcdFx0Ly8gX2Fzc2VydCgkKHRoaXMuc3BhbikuaXMoXCI6dmlzaWJsZVwiKSwgXCJzY3JvbGxJbnRvVmlldyBub2RlIGlzIGludmlzaWJsZVwiKTsgLy8gb3RoZXJ3aXNlIHdlIGNhbm5vdCBjYWxjIG9mZnNldHNcblx0XHRcdGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHQvLyBXZSBjYW5ub3QgY2FsYyBvZmZzZXRzIGZvciBoaWRkZW4gZWxlbWVudHNcblx0XHRcdFx0dGhpcy53YXJuKFwic2Nyb2xsSW50b1ZpZXcoKTogbm9kZSBpcyBpbnZpc2libGUuXCIpO1xuXHRcdFx0XHRyZXR1cm4gX2dldFJlc29sdmVkUHJvbWlzZSgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzUGFyZW50V2luZG93KSB7XG5cdFx0XHRcdG5vZGVZID0gJCh0aGlzLnNwYW4pLm9mZnNldCgpLnRvcDtcblx0XHRcdFx0dG9wTm9kZVkgPVxuXHRcdFx0XHRcdHRvcE5vZGUgJiYgdG9wTm9kZS5zcGFuID8gJCh0b3BOb2RlLnNwYW4pLm9mZnNldCgpLnRvcCA6IDA7XG5cdFx0XHRcdCRhbmltYXRlVGFyZ2V0ID0gJChcImh0bWwsYm9keVwiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9hc3NlcnQoXG5cdFx0XHRcdFx0JHNjcm9sbFBhcmVudFswXSAhPT0gZG9jdW1lbnQgJiZcblx0XHRcdFx0XHRcdCRzY3JvbGxQYXJlbnRbMF0gIT09IGRvY3VtZW50LmJvZHksXG5cdFx0XHRcdFx0XCJzY3JvbGxQYXJlbnQgc2hvdWxkIGJlIGEgc2ltcGxlIGVsZW1lbnQgb3IgYHdpbmRvd2AsIG5vdCBkb2N1bWVudCBvciBib2R5LlwiXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Y29udGFpbmVyT2Zmc2V0VG9wID0gJHNjcm9sbFBhcmVudC5vZmZzZXQoKS50b3A7XG5cdFx0XHRcdG5vZGVZID1cblx0XHRcdFx0XHQkKHRoaXMuc3Bhbikub2Zmc2V0KCkudG9wIC0gY29udGFpbmVyT2Zmc2V0VG9wICsgc2Nyb2xsVG9wOyAvLyByZWxhdGl2ZSB0byBzY3JvbGwgcGFyZW50XG5cdFx0XHRcdHRvcE5vZGVZID0gdG9wTm9kZVxuXHRcdFx0XHRcdD8gJCh0b3BOb2RlLnNwYW4pLm9mZnNldCgpLnRvcCAtXG5cdFx0XHRcdFx0ICBjb250YWluZXJPZmZzZXRUb3AgK1xuXHRcdFx0XHRcdCAgc2Nyb2xsVG9wXG5cdFx0XHRcdFx0OiAwO1xuXHRcdFx0XHRob3J6U2Nyb2xsYmFySGVpZ2h0ID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQkc2Nyb2xsUGFyZW50LmlubmVySGVpZ2h0KCkgLSAkc2Nyb2xsUGFyZW50WzBdLmNsaWVudEhlaWdodFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb250YWluZXJIZWlnaHQgLT0gaG9yelNjcm9sbGJhckhlaWdodDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcIiAgICBzY3JvbGxJbnRvVmlldygpLCBub2RlWT1cIiArIG5vZGVZICsgXCIsIGNvbnRhaW5lckhlaWdodD1cIiArIGNvbnRhaW5lckhlaWdodCk7XG5cdFx0XHRpZiAobm9kZVkgPCBzY3JvbGxUb3AgKyB0b3BPZnMpIHtcblx0XHRcdFx0Ly8gTm9kZSBpcyBhYm92ZSB2aXNpYmxlIGNvbnRhaW5lciBhcmVhXG5cdFx0XHRcdG5ld1Njcm9sbFRvcCA9IG5vZGVZIC0gdG9wT2ZzO1xuXHRcdFx0XHQvLyB0aGlzLmRlYnVnKFwiICAgIHNjcm9sbEludG9WaWV3KCksIFVQUEVSIG5ld1Njcm9sbFRvcD1cIiArIG5ld1Njcm9sbFRvcCk7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRub2RlWSArIG5vZGVIZWlnaHQgPlxuXHRcdFx0XHRzY3JvbGxUb3AgKyBjb250YWluZXJIZWlnaHQgLSBib3R0b21PZnNcblx0XHRcdCkge1xuXHRcdFx0XHRuZXdTY3JvbGxUb3AgPSBub2RlWSArIG5vZGVIZWlnaHQgLSBjb250YWluZXJIZWlnaHQgKyBib3R0b21PZnM7XG5cdFx0XHRcdC8vIHRoaXMuZGVidWcoXCIgICAgc2Nyb2xsSW50b1ZpZXcoKSwgTE9XRVIgbmV3U2Nyb2xsVG9wPVwiICsgbmV3U2Nyb2xsVG9wKTtcblx0XHRcdFx0Ly8gSWYgYSB0b3BOb2RlIHdhcyBwYXNzZWQsIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIG5ldmVyIHNjcm9sbGVkXG5cdFx0XHRcdC8vIG91dHNpZGUgdGhlIHVwcGVyIGJvcmRlclxuXHRcdFx0XHRpZiAodG9wTm9kZSkge1xuXHRcdFx0XHRcdF9hc3NlcnQoXG5cdFx0XHRcdFx0XHR0b3BOb2RlLmlzUm9vdE5vZGUoKSB8fCB0b3BOb2RlLmlzVmlzaWJsZSgpLFxuXHRcdFx0XHRcdFx0XCJ0b3BOb2RlIG11c3QgYmUgdmlzaWJsZVwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAodG9wTm9kZVkgPCBuZXdTY3JvbGxUb3ApIHtcblx0XHRcdFx0XHRcdG5ld1Njcm9sbFRvcCA9IHRvcE5vZGVZIC0gdG9wT2ZzO1xuXHRcdFx0XHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcIiAgICBzY3JvbGxJbnRvVmlldygpLCBUT1AgbmV3U2Nyb2xsVG9wPVwiICsgbmV3U2Nyb2xsVG9wKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld1Njcm9sbFRvcCA9PT0gbnVsbCkge1xuXHRcdFx0XHRkZmQucmVzb2x2ZVdpdGgodGhpcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0aGlzLmRlYnVnKFwiICAgIHNjcm9sbEludG9WaWV3KCksIFNFVCBuZXdTY3JvbGxUb3A9XCIgKyBuZXdTY3JvbGxUb3ApO1xuXHRcdFx0XHRpZiAob3B0cy5lZmZlY3RzKSB7XG5cdFx0XHRcdFx0b3B0cy5lZmZlY3RzLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRkZmQucmVzb2x2ZVdpdGgoc2VsZik7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHQkYW5pbWF0ZVRhcmdldC5zdG9wKHRydWUpLmFuaW1hdGUoXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHNjcm9sbFRvcDogbmV3U2Nyb2xsVG9wLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG9wdHMuZWZmZWN0c1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JGFuaW1hdGVUYXJnZXRbMF0uc2Nyb2xsVG9wID0gbmV3U2Nyb2xsVG9wO1xuXHRcdFx0XHRcdGRmZC5yZXNvbHZlV2l0aCh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRmZC5wcm9taXNlKCk7XG5cdFx0fSxcblxuXHRcdC8qKkFjdGl2YXRlIHRoaXMgbm9kZS5cblx0XHQgKlxuXHRcdCAqIFRoZSBgY2VsbGAgb3B0aW9uIHJlcXVpcmVzIHRoZSBleHQtdGFibGUgYW5kIGV4dC1hcmlhZ3JpZCBleHRlbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhZz10cnVlXSBwYXNzIGZhbHNlIHRvIGRlYWN0aXZhdGVcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIGFkZGl0aW9uYWwgb3B0aW9ucy4gRGVmYXVsdHMgdG8ge25vRXZlbnRzOiBmYWxzZSwgbm9Gb2N1czogZmFsc2UsIGNlbGw6IG51bGx9XG5cdFx0ICogQHJldHVybnMgeyQuUHJvbWlzZX1cblx0XHQgKi9cblx0XHRzZXRBY3RpdmU6IGZ1bmN0aW9uKGZsYWcsIG9wdHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyZWUuX2NhbGxIb29rKFwibm9kZVNldEFjdGl2ZVwiLCB0aGlzLCBmbGFnLCBvcHRzKTtcblx0XHR9LFxuXHRcdC8qKkV4cGFuZCBvciBjb2xsYXBzZSB0aGlzIG5vZGUuIFByb21pc2UgaXMgcmVzb2x2ZWQsIHdoZW4gbGF6eSBsb2FkaW5nIGFuZCBhbmltYXRpb25zIGFyZSBkb25lLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV0gcGFzcyBmYWxzZSB0byBjb2xsYXBzZVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gYWRkaXRpb25hbCBvcHRpb25zLiBEZWZhdWx0cyB0byB7bm9BbmltYXRpb246IGZhbHNlLCBub0V2ZW50czogZmFsc2V9XG5cdFx0ICogQHJldHVybnMgeyQuUHJvbWlzZX1cblx0XHQgKi9cblx0XHRzZXRFeHBhbmRlZDogZnVuY3Rpb24oZmxhZywgb3B0cykge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5fY2FsbEhvb2soXCJub2RlU2V0RXhwYW5kZWRcIiwgdGhpcywgZmxhZywgb3B0cyk7XG5cdFx0fSxcblx0XHQvKipTZXQga2V5Ym9hcmQgZm9jdXMgdG8gdGhpcyBub2RlLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV0gcGFzcyBmYWxzZSB0byBibHVyXG5cdFx0ICogQHNlZSBGYW5jeXRyZWUjc2V0Rm9jdXNcblx0XHQgKi9cblx0XHRzZXRGb2N1czogZnVuY3Rpb24oZmxhZykge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5fY2FsbEhvb2soXCJub2RlU2V0Rm9jdXNcIiwgdGhpcywgZmxhZyk7XG5cdFx0fSxcblx0XHQvKipTZWxlY3QgdGhpcyBub2RlLCBpLmUuIGNoZWNrIHRoZSBjaGVja2JveC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbGFnPXRydWVdIHBhc3MgZmFsc2UgdG8gZGVzZWxlY3Rcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIGFkZGl0aW9uYWwgb3B0aW9ucy4gRGVmYXVsdHMgdG8ge25vRXZlbnRzOiBmYWxzZSwgcFxuXHRcdCAqICAgICBwcm9wYWdhdGVEb3duOiBudWxsLCBwcm9wYWdhdGVVcDogbnVsbCwgY2FsbGJhY2s6IG51bGwgfVxuXHRcdCAqL1xuXHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihmbGFnLCBvcHRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50cmVlLl9jYWxsSG9vayhcIm5vZGVTZXRTZWxlY3RlZFwiLCB0aGlzLCBmbGFnLCBvcHRzKTtcblx0XHR9LFxuXHRcdC8qKk1hcmsgYSBsYXp5IG5vZGUgYXMgJ2Vycm9yJywgJ2xvYWRpbmcnLCAnbm9kYXRhJywgb3IgJ29rJy5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzICdlcnJvcid8J2VtcHR5J3wnb2snXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFttZXNzYWdlXVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbZGV0YWlsc11cblx0XHQgKi9cblx0XHRzZXRTdGF0dXM6IGZ1bmN0aW9uKHN0YXR1cywgbWVzc2FnZSwgZGV0YWlscykge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5fY2FsbEhvb2soXG5cdFx0XHRcdFwibm9kZVNldFN0YXR1c1wiLFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRzdGF0dXMsXG5cdFx0XHRcdG1lc3NhZ2UsXG5cdFx0XHRcdGRldGFpbHNcblx0XHRcdCk7XG5cdFx0fSxcblx0XHQvKipSZW5hbWUgdGhpcyBub2RlLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxuXHRcdCAqL1xuXHRcdHNldFRpdGxlOiBmdW5jdGlvbih0aXRsZSkge1xuXHRcdFx0dGhpcy50aXRsZSA9IHRpdGxlO1xuXHRcdFx0dGhpcy5yZW5kZXJUaXRsZSgpO1xuXHRcdFx0dGhpcy50cmlnZ2VyTW9kaWZ5KFwicmVuYW1lXCIpO1xuXHRcdH0sXG5cdFx0LyoqU29ydCBjaGlsZCBsaXN0IGJ5IHRpdGxlLlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjbXBdIGN1c3RvbSBjb21wYXJlIGZ1bmN0aW9uKGEsIGIpIHRoYXQgcmV0dXJucyAtMSwgMCwgb3IgMSAoZGVmYXVsdHMgdG8gc29ydCBieSB0aXRsZSkuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZGVlcD1mYWxzZV0gcGFzcyB0cnVlIHRvIHNvcnQgYWxsIGRlc2NlbmRhbnQgbm9kZXNcblx0XHQgKi9cblx0XHRzb3J0Q2hpbGRyZW46IGZ1bmN0aW9uKGNtcCwgZGVlcCkge1xuXHRcdFx0dmFyIGksXG5cdFx0XHRcdGwsXG5cdFx0XHRcdGNsID0gdGhpcy5jaGlsZHJlbjtcblxuXHRcdFx0aWYgKCFjbCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjbXAgPVxuXHRcdFx0XHRjbXAgfHxcblx0XHRcdFx0ZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHZhciB4ID0gYS50aXRsZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0eSA9IGIudGl0bGUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuXHRcdFx0XHRcdHJldHVybiB4ID09PSB5ID8gMCA6IHggPiB5ID8gMSA6IC0xO1xuXHRcdFx0XHR9O1xuXHRcdFx0Y2wuc29ydChjbXApO1xuXHRcdFx0aWYgKGRlZXApIHtcblx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IGNsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmIChjbFtpXS5jaGlsZHJlbikge1xuXHRcdFx0XHRcdFx0Y2xbaV0uc29ydENoaWxkcmVuKGNtcCwgXCIkbm9yZW5kZXIkXCIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGRlZXAgIT09IFwiJG5vcmVuZGVyJFwiKSB7XG5cdFx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRyaWdnZXJNb2RpZnlDaGlsZChcInNvcnRcIik7XG5cdFx0fSxcblx0XHQvKiogQ29udmVydCBub2RlIChvciB3aG9sZSBicmFuY2gpIGludG8gYSBwbGFpbiBvYmplY3QuXG5cdFx0ICpcblx0XHQgKiBUaGUgcmVzdWx0IGlzIGNvbXBhdGlibGUgd2l0aCBub2RlLmFkZENoaWxkcmVuKCkuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWN1cnNpdmU9ZmFsc2VdIGluY2x1ZGUgY2hpbGQgbm9kZXNcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrKGRpY3QsIG5vZGUpIGlzIGNhbGxlZCBmb3IgZXZlcnkgbm9kZSwgaW4gb3JkZXIgdG8gYWxsb3cgbW9kaWZpY2F0aW9ucy5cblx0XHQgKiAgICAgUmV0dXJuIGBmYWxzZWAgdG8gaWdub3JlIHRoaXMgbm9kZSBvciBcInNraXBcIiB0byBpbmNsdWRlIHRoaXMgbm9kZSB3aXRob3V0IGl0cyBjaGlsZHJlbi5cblx0XHQgKiBAcmV0dXJucyB7Tm9kZURhdGF9XG5cdFx0ICovXG5cdFx0dG9EaWN0OiBmdW5jdGlvbihyZWN1cnNpdmUsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0bCxcblx0XHRcdFx0bm9kZSxcblx0XHRcdFx0cmVzLFxuXHRcdFx0XHRkaWN0ID0ge30sXG5cdFx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0XHQkLmVhY2goTk9ERV9BVFRSUywgZnVuY3Rpb24oaSwgYSkge1xuXHRcdFx0XHRpZiAoc2VsZlthXSB8fCBzZWxmW2FdID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGRpY3RbYV0gPSBzZWxmW2FdO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KHRoaXMuZGF0YSkpIHtcblx0XHRcdFx0ZGljdC5kYXRhID0gJC5leHRlbmQoe30sIHRoaXMuZGF0YSk7XG5cdFx0XHRcdGlmICgkLmlzRW1wdHlPYmplY3QoZGljdC5kYXRhKSkge1xuXHRcdFx0XHRcdGRlbGV0ZSBkaWN0LmRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0XHRyZXMgPSBjYWxsYmFjayhkaWN0LCBzZWxmKTtcblx0XHRcdFx0aWYgKHJlcyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7IC8vIERvbid0IGluY2x1ZGUgdGhpcyBub2RlIG5vciBpdHMgY2hpbGRyZW5cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzID09PSBcInNraXBcIikge1xuXHRcdFx0XHRcdHJlY3Vyc2l2ZSA9IGZhbHNlOyAvLyBJbmNsdWRlIHRoaXMgbm9kZSwgYnV0IG5vdCB0aGUgY2hpbGRyZW5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHJlY3Vyc2l2ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG5cdFx0XHRcdFx0ZGljdC5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHRoaXMuY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0XHRpZiAoIW5vZGUuaXNTdGF0dXNOb2RlKCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzID0gbm9kZS50b0RpY3QodHJ1ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdFx0XHRpZiAocmVzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRcdGRpY3QuY2hpbGRyZW4ucHVzaChyZXMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGljdDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFNldCwgY2xlYXIsIG9yIHRvZ2dsZSBjbGFzcyBvZiBub2RlJ3Mgc3BhbiB0YWcgYW5kIC5leHRyYUNsYXNzZXMuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIGNsYXNzIG5hbWUgKHNlcGFyYXRlIG11bHRpcGxlIGNsYXNzZXMgYnkgc3BhY2UpXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhZ10gdHJ1ZS9mYWxzZSB0byBhZGQvcmVtb3ZlIGNsYXNzLiBJZiBvbWl0dGVkLCBjbGFzcyBpcyB0b2dnbGVkLlxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGEgY2xhc3Mgd2FzIGFkZGVkXG5cdFx0ICpcblx0XHQgKiBAc2luY2UgMi4xN1xuXHRcdCAqL1xuXHRcdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbih2YWx1ZSwgZmxhZykge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSxcblx0XHRcdFx0aGFzQ2xhc3MsXG5cdFx0XHRcdHJub3R3aGl0ZSA9IC9cXFMrL2csXG5cdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaChybm90d2hpdGUpIHx8IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0d2FzQWRkZWQgPSBmYWxzZSxcblx0XHRcdFx0c3RhdHVzRWxlbSA9IHRoaXNbdGhpcy50cmVlLnN0YXR1c0NsYXNzUHJvcE5hbWVdLFxuXHRcdFx0XHRjdXJDbGFzc2VzID0gXCIgXCIgKyAodGhpcy5leHRyYUNsYXNzZXMgfHwgXCJcIikgKyBcIiBcIjtcblxuXHRcdFx0Ly8gdGhpcy5pbmZvKFwidG9nZ2xlQ2xhc3MoJ1wiICsgdmFsdWUgKyBcIicsIFwiICsgZmxhZyArIFwiKVwiLCBjdXJDbGFzc2VzKTtcblx0XHRcdC8vIE1vZGlmeSBET00gZWxlbWVudCBkaXJlY3RseSBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuXHRcdFx0aWYgKHN0YXR1c0VsZW0pIHtcblx0XHRcdFx0JChzdGF0dXNFbGVtKS50b2dnbGVDbGFzcyh2YWx1ZSwgZmxhZyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBNb2RpZnkgbm9kZS5leHRyYUNsYXNzZXMgdG8gbWFrZSB0aGlzIGNoYW5nZSBwZXJzaXN0ZW50XG5cdFx0XHQvLyBUb2dnbGUgaWYgZmxhZyB3YXMgbm90IHBhc3NlZFxuXHRcdFx0d2hpbGUgKChjbGFzc05hbWUgPSBjbGFzc05hbWVzW2krK10pKSB7XG5cdFx0XHRcdGhhc0NsYXNzID0gY3VyQ2xhc3Nlcy5pbmRleE9mKFwiIFwiICsgY2xhc3NOYW1lICsgXCIgXCIpID49IDA7XG5cdFx0XHRcdGZsYWcgPSBmbGFnID09PSB1bmRlZmluZWQgPyAhaGFzQ2xhc3MgOiAhIWZsYWc7XG5cdFx0XHRcdGlmIChmbGFnKSB7XG5cdFx0XHRcdFx0aWYgKCFoYXNDbGFzcykge1xuXHRcdFx0XHRcdFx0Y3VyQ2xhc3NlcyArPSBjbGFzc05hbWUgKyBcIiBcIjtcblx0XHRcdFx0XHRcdHdhc0FkZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2hpbGUgKGN1ckNsYXNzZXMuaW5kZXhPZihcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiKSA+IC0xKSB7XG5cdFx0XHRcdFx0XHRjdXJDbGFzc2VzID0gY3VyQ2xhc3Nlcy5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0XHRcIiBcIiArIGNsYXNzTmFtZSArIFwiIFwiLFxuXHRcdFx0XHRcdFx0XHRcIiBcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuZXh0cmFDbGFzc2VzID0gJC50cmltKGN1ckNsYXNzZXMpO1xuXHRcdFx0Ly8gdGhpcy5pbmZvKFwiLT4gdG9nZ2xlQ2xhc3MoJ1wiICsgdmFsdWUgKyBcIicsIFwiICsgZmxhZyArIFwiKTogJ1wiICsgdGhpcy5leHRyYUNsYXNzZXMgKyBcIidcIik7XG5cdFx0XHRyZXR1cm4gd2FzQWRkZWQ7XG5cdFx0fSxcblx0XHQvKiogRmxpcCBleHBhbmRlZCBzdGF0dXMuICovXG5cdFx0dG9nZ2xlRXhwYW5kZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudHJlZS5fY2FsbEhvb2soXCJub2RlVG9nZ2xlRXhwYW5kZWRcIiwgdGhpcyk7XG5cdFx0fSxcblx0XHQvKiogRmxpcCBzZWxlY3Rpb24gc3RhdHVzLiAqL1xuXHRcdHRvZ2dsZVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnRyZWUuX2NhbGxIb29rKFwibm9kZVRvZ2dsZVNlbGVjdGVkXCIsIHRoaXMpO1xuXHRcdH0sXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFwiRmFuY3l0cmVlTm9kZUBcIiArIHRoaXMua2V5ICsgXCJbdGl0bGU9J1wiICsgdGhpcy50aXRsZSArIFwiJ11cIjtcblx0XHRcdC8vIHJldHVybiBcIjxGYW5jeXRyZWVOb2RlKCNcIiArIHRoaXMua2V5ICsgXCIsICdcIiArIHRoaXMudGl0bGUgKyBcIicpPlwiO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlciBgbW9kaWZ5Q2hpbGRgIGV2ZW50IG9uIGEgcGFyZW50IHRvIHNpZ25hbCB0aGF0IGEgY2hpbGQgd2FzIG1vZGlmaWVkLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRpb24gVHlwZSBvZiBjaGFuZ2U6ICdhZGQnLCAncmVtb3ZlJywgJ3JlbmFtZScsICdtb3ZlJywgJ2RhdGEnLCAuLi5cblx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZU5vZGV9IFtjaGlsZE5vZGVdXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtleHRyYV1cblx0XHQgKi9cblx0XHR0cmlnZ2VyTW9kaWZ5Q2hpbGQ6IGZ1bmN0aW9uKG9wZXJhdGlvbiwgY2hpbGROb2RlLCBleHRyYSkge1xuXHRcdFx0dmFyIGRhdGEsXG5cdFx0XHRcdG1vZGlmeUNoaWxkID0gdGhpcy50cmVlLm9wdGlvbnMubW9kaWZ5Q2hpbGQ7XG5cblx0XHRcdGlmIChtb2RpZnlDaGlsZCkge1xuXHRcdFx0XHRpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5wYXJlbnQgIT09IHRoaXMpIHtcblx0XHRcdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcdFx0XCJjaGlsZE5vZGUgXCIgKyBjaGlsZE5vZGUgKyBcIiBpcyBub3QgYSBjaGlsZCBvZiBcIiArIHRoaXNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGEgPSB7XG5cdFx0XHRcdFx0bm9kZTogdGhpcyxcblx0XHRcdFx0XHR0cmVlOiB0aGlzLnRyZWUsXG5cdFx0XHRcdFx0b3BlcmF0aW9uOiBvcGVyYXRpb24sXG5cdFx0XHRcdFx0Y2hpbGROb2RlOiBjaGlsZE5vZGUgfHwgbnVsbCxcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGV4dHJhKSB7XG5cdFx0XHRcdFx0JC5leHRlbmQoZGF0YSwgZXh0cmEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1vZGlmeUNoaWxkKHsgdHlwZTogXCJtb2RpZnlDaGlsZFwiIH0sIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlciBgbW9kaWZ5Q2hpbGRgIGV2ZW50IG9uIG5vZGUucGFyZW50KCEpLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBvcGVyYXRpb24gVHlwZSBvZiBjaGFuZ2U6ICdhZGQnLCAncmVtb3ZlJywgJ3JlbmFtZScsICdtb3ZlJywgJ2RhdGEnLCAuLi5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW2V4dHJhXVxuXHRcdCAqL1xuXHRcdHRyaWdnZXJNb2RpZnk6IGZ1bmN0aW9uKG9wZXJhdGlvbiwgZXh0cmEpIHtcblx0XHRcdHRoaXMucGFyZW50LnRyaWdnZXJNb2RpZnlDaGlsZChvcGVyYXRpb24sIHRoaXMsIGV4dHJhKTtcblx0XHR9LFxuXHRcdC8qKiBDYWxsIGZuKG5vZGUpIGZvciBhbGwgY2hpbGQgbm9kZXMgaW4gaGllcmFyY2hpY2FsIG9yZGVyIChkZXB0aC1maXJzdCkuPGJyPlxuXHRcdCAqIFN0b3AgaXRlcmF0aW9uLCBpZiBmbigpIHJldHVybnMgZmFsc2UuIFNraXAgY3VycmVudCBicmFuY2gsIGlmIGZuKCkgcmV0dXJucyBcInNraXBcIi48YnI+XG5cdFx0ICogUmV0dXJuIGZhbHNlIGlmIGl0ZXJhdGlvbiB3YXMgc3RvcHBlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0XHQgKiAgICAgUmV0dXJuIGZhbHNlIHRvIHN0b3AgaXRlcmF0aW9uLCByZXR1cm4gXCJza2lwXCIgdG8gc2tpcCB0aGlzIG5vZGUgYW5kXG5cdFx0ICogICAgIGl0cyBjaGlsZHJlbiBvbmx5LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVTZWxmPWZhbHNlXVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdHZpc2l0OiBmdW5jdGlvbihmbiwgaW5jbHVkZVNlbGYpIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRsLFxuXHRcdFx0XHRyZXMgPSB0cnVlLFxuXHRcdFx0XHRjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cblx0XHRcdGlmIChpbmNsdWRlU2VsZiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRyZXMgPSBmbih0aGlzKTtcblx0XHRcdFx0aWYgKHJlcyA9PT0gZmFsc2UgfHwgcmVzID09PSBcInNraXBcIikge1xuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0cmVzID0gY2hpbGRyZW5baV0udmlzaXQoZm4sIHRydWUpO1xuXHRcdFx0XHRcdGlmIChyZXMgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHQvKiogQ2FsbCBmbihub2RlKSBmb3IgYWxsIGNoaWxkIG5vZGVzIGFuZCByZWN1cnNpdmVseSBsb2FkIGxhenkgY2hpbGRyZW4uPGJyPlxuXHRcdCAqIDxiPk5vdGU6PC9iPiBJZiB5b3UgbmVlZCB0aGlzIG1ldGhvZCwgeW91IHByb2JhYmx5IHNob3VsZCBjb25zaWRlciB0byByZXZpZXdcblx0XHQgKiB5b3VyIGFyY2hpdGVjdHVyZSEgUmVjdXJzaXZsZXkgbG9hZGluZyBub2RlcyBpcyBhIHBlcmZlY3Qgd2F5IGZvciBsYXp5XG5cdFx0ICogcHJvZ3JhbW1lcnMgdG8gZmxvb2QgdGhlIHNlcnZlciB3aXRoIHJlcXVlc3RzIDstKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbi5cblx0XHQgKiAgICAgUmV0dXJuIGZhbHNlIHRvIHN0b3AgaXRlcmF0aW9uLCByZXR1cm4gXCJza2lwXCIgdG8gc2tpcCB0aGlzIG5vZGUgYW5kXG5cdFx0ICogICAgIGl0cyBjaGlsZHJlbiBvbmx5LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVTZWxmPWZhbHNlXVxuXHRcdCAqIEByZXR1cm5zIHskLlByb21pc2V9XG5cdFx0ICogQHNpbmNlIDIuNFxuXHRcdCAqL1xuXHRcdHZpc2l0QW5kTG9hZDogZnVuY3Rpb24oZm4sIGluY2x1ZGVTZWxmLCBfcmVjdXJzaW9uKSB7XG5cdFx0XHR2YXIgZGZkLFxuXHRcdFx0XHRyZXMsXG5cdFx0XHRcdGxvYWRlcnMsXG5cdFx0XHRcdG5vZGUgPSB0aGlzO1xuXG5cdFx0XHQvLyBub2RlLmRlYnVnKFwidmlzaXRBbmRMb2FkXCIpO1xuXHRcdFx0aWYgKGZuICYmIGluY2x1ZGVTZWxmID09PSB0cnVlKSB7XG5cdFx0XHRcdHJlcyA9IGZuKG5vZGUpO1xuXHRcdFx0XHRpZiAocmVzID09PSBmYWxzZSB8fCByZXMgPT09IFwic2tpcFwiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9yZWN1cnNpb24gPyByZXMgOiBfZ2V0UmVzb2x2ZWRQcm9taXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghbm9kZS5jaGlsZHJlbiAmJiAhbm9kZS5sYXp5KSB7XG5cdFx0XHRcdHJldHVybiBfZ2V0UmVzb2x2ZWRQcm9taXNlKCk7XG5cdFx0XHR9XG5cdFx0XHRkZmQgPSBuZXcgJC5EZWZlcnJlZCgpO1xuXHRcdFx0bG9hZGVycyA9IFtdO1xuXHRcdFx0Ly8gbm9kZS5kZWJ1ZyhcImxvYWQoKS4uLlwiKTtcblx0XHRcdG5vZGUubG9hZCgpLmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIG5vZGUuZGVidWcoXCJsb2FkKCkuLi4gZG9uZS5cIik7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRyZXMgPSBub2RlLmNoaWxkcmVuW2ldLnZpc2l0QW5kTG9hZChmbiwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0XHRcdFx0aWYgKHJlcyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGRmZC5yZWplY3QoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAocmVzICE9PSBcInNraXBcIikge1xuXHRcdFx0XHRcdFx0bG9hZGVycy5wdXNoKHJlcyk7IC8vIEFkZCBwcm9taXNlIHRvIHRoZSBsaXN0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCQud2hlbi5hcHBseSh0aGlzLCBsb2FkZXJzKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRmZC5yZXNvbHZlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gZGZkLnByb21pc2UoKTtcblx0XHR9LFxuXHRcdC8qKiBDYWxsIGZuKG5vZGUpIGZvciBhbGwgcGFyZW50IG5vZGVzLCBib3R0b20tdXAsIGluY2x1ZGluZyBpbnZpc2libGUgc3lzdGVtIHJvb3QuPGJyPlxuXHRcdCAqIFN0b3AgaXRlcmF0aW9uLCBpZiBmbigpIHJldHVybnMgZmFsc2UuPGJyPlxuXHRcdCAqIFJldHVybiBmYWxzZSBpZiBpdGVyYXRpb24gd2FzIHN0b3BwZWQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdFx0ICogICAgIFJldHVybiBmYWxzZSB0byBzdG9wIGl0ZXJhdGlvbiwgcmV0dXJuIFwic2tpcFwiIHRvIHNraXAgdGhpcyBub2RlIGFuZCBjaGlsZHJlbiBvbmx5LlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVTZWxmPWZhbHNlXVxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdCAqL1xuXHRcdHZpc2l0UGFyZW50czogZnVuY3Rpb24oZm4sIGluY2x1ZGVTZWxmKSB7XG5cdFx0XHQvLyBWaXNpdCBwYXJlbnQgbm9kZXMgKGJvdHRvbSB1cClcblx0XHRcdGlmIChpbmNsdWRlU2VsZiAmJiBmbih0aGlzKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHAgPSB0aGlzLnBhcmVudDtcblx0XHRcdHdoaWxlIChwKSB7XG5cdFx0XHRcdGlmIChmbihwKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cCA9IHAucGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHQvKiogQ2FsbCBmbihub2RlKSBmb3IgYWxsIHNpYmxpbmcgbm9kZXMuPGJyPlxuXHRcdCAqIFN0b3AgaXRlcmF0aW9uLCBpZiBmbigpIHJldHVybnMgZmFsc2UuPGJyPlxuXHRcdCAqIFJldHVybiBmYWxzZSBpZiBpdGVyYXRpb24gd2FzIHN0b3BwZWQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdFx0ICogICAgIFJldHVybiBmYWxzZSB0byBzdG9wIGl0ZXJhdGlvbi5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlU2VsZj1mYWxzZV1cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHR2aXNpdFNpYmxpbmdzOiBmdW5jdGlvbihmbiwgaW5jbHVkZVNlbGYpIHtcblx0XHRcdHZhciBpLFxuXHRcdFx0XHRsLFxuXHRcdFx0XHRuLFxuXHRcdFx0XHRhYyA9IHRoaXMucGFyZW50LmNoaWxkcmVuO1xuXG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gYWMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdG4gPSBhY1tpXTtcblx0XHRcdFx0aWYgKGluY2x1ZGVTZWxmIHx8IG4gIT09IHRoaXMpIHtcblx0XHRcdFx0XHRpZiAoZm4obikgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKiBXcml0ZSB3YXJuaW5nIHRvIGJyb3dzZXIgY29uc29sZSBpZiBkZWJ1Z0xldmVsID49IDIgKHByZXBlbmRpbmcgbm9kZSBpbmZvKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHsqfSBtc2cgc3RyaW5nIG9yIG9iamVjdCBvciBhcnJheSBvZiBzdWNoXG5cdFx0ICovXG5cdFx0d2FybjogZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRpZiAodGhpcy50cmVlLm9wdGlvbnMuZGVidWdMZXZlbCA+PSAyKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRjb25zb2xlQXBwbHkoXCJ3YXJuXCIsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIEZhbmN5dHJlZVxuXHQgKi9cblx0LyoqXG5cdCAqIENvbnN0cnVjdCBhIG5ldyB0cmVlIG9iamVjdC5cblx0ICpcblx0ICogQGNsYXNzIEZhbmN5dHJlZVxuXHQgKiBAY2xhc3NkZXNjIFRoZSBjb250cm9sbGVyIGJlaGluZCBhIGZhbmN5dHJlZS5cblx0ICogVGhpcyBjbGFzcyBhbHNvIGNvbnRhaW5zICdob29rIG1ldGhvZHMnOiBzZWUge0BsaW5rIEZhbmN5dHJlZV9Ib29rc30uXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2lkZ2V0fSB3aWRnZXRcblx0ICpcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IF9pZCBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1bmlxdWUgdHJlZSBpbnN0YW5jZSBJRCwgZS5nLiBcIjFcIi5cblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IF9ucyBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCB1bmlxdWUgdHJlZSBuYW1lc3BhY2UsIGUuZy4gXCIuZmFuY3l0cmVlLTFcIi5cblx0ICogQHByb3BlcnR5IHtGYW5jeXRyZWVOb2RlfSBhY3RpdmVOb2RlIEN1cnJlbnRseSBhY3RpdmUgbm9kZSBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gYXJpYVByb3BOYW1lIFByb3BlcnR5IG5hbWUgb2YgRmFuY3l0cmVlTm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50IHdoaWNoIHdpbGwgcmVjZWl2ZSB0aGUgYXJpYSBhdHRyaWJ1dGVzLlxuXHQgKiAgICAgVHlwaWNhbGx5IFwibGlcIiwgYnV0IFwidHJcIiBmb3IgdGFibGUgZXh0ZW5zaW9uLlxuXHQgKiBAcHJvcGVydHkge2pRdWVyeU9iamVjdH0gJGNvbnRhaW5lciBPdXRlciBgPHVsPmAgZWxlbWVudCAob3IgYDx0YWJsZT5gIGVsZW1lbnQgZm9yIGV4dC10YWJsZSkuXG5cdCAqIEBwcm9wZXJ0eSB7alF1ZXJ5T2JqZWN0fSAkZGl2IEEgalF1ZXJ5IG9iamVjdCBjb250YWluaW5nIHRoZSBlbGVtZW50IHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIHRyZWUgd2lkZ2V0IChgd2lkZ2V0LmVsZW1lbnRgKVxuXHQgKiBAcHJvcGVydHkge29iamVjdHxhcnJheX0gY29sdW1ucyBSZWNvbW1lbmRlZCBwbGFjZSB0byBzdG9yZSBzaGFyZWQgY29sdW1uIG1ldGEgZGF0YS4gQHNpbmNlIDIuMjdcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgTWV0YWRhdGEsIGkuZS4gcHJvcGVydGllcyB0aGF0IG1heSBiZSBwYXNzZWQgdG8gYHNvdXJjZWAgaW4gYWRkaXRpb24gdG8gYSBjaGlsZHJlbiBhcnJheS5cblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGV4dCBIYXNoIG9mIGFsbCBhY3RpdmUgcGx1Z2luIGluc3RhbmNlcy5cblx0ICogQHByb3BlcnR5IHtGYW5jeXRyZWVOb2RlfSBmb2N1c05vZGUgQ3VycmVudGx5IGZvY3VzZWQgbm9kZSBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge0ZhbmN5dHJlZU5vZGV9IGxhc3RTZWxlY3RlZE5vZGUgVXNlZCB0byBpbXBsZW1lbnQgc2VsZWN0TW9kZSAxIChzaW5nbGUgc2VsZWN0KVxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gbm9kZUNvbnRhaW5lckF0dHJOYW1lIFByb3BlcnR5IG5hbWUgb2YgRmFuY3l0cmVlTm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBvdXRlciBlbGVtZW50IG9mIHNpbmdsZSBub2Rlcy5cblx0ICogICAgIFR5cGljYWxseSBcImxpXCIsIGJ1dCBcInRyXCIgZm9yIHRhYmxlIGV4dGVuc2lvbi5cblx0ICogQHByb3BlcnR5IHtGYW5jeXRyZWVPcHRpb25zfSBvcHRpb25zIEN1cnJlbnQgb3B0aW9ucywgaS5lLiBkZWZhdWx0IG9wdGlvbnMgKyBvcHRpb25zIHBhc3NlZCB0byBjb25zdHJ1Y3Rvci5cblx0ICogQHByb3BlcnR5IHtGYW5jeXRyZWVOb2RlfSByb290Tm9kZSBJbnZpc2libGUgc3lzdGVtIHJvb3Qgbm9kZS5cblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IHN0YXR1c0NsYXNzUHJvcE5hbWUgUHJvcGVydHkgbmFtZSBvZiBGYW5jeXRyZWVOb2RlIHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBzdGF0dXMgY2xhc3Nlcy5cblx0ICogICAgIFR5cGljYWxseSBcInNwYW5cIiwgYnV0IFwidHJcIiBmb3IgdGFibGUgZXh0ZW5zaW9uLlxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gdHlwZXMgTWFwIGZvciBzaGFyZWQgdHlwZSBzcGVjaWZpYyBtZXRhIGRhdGEsIHVzZWQgd2l0aCBub2RlLnR5cGUgYXR0cmlidXRlLiBAc2luY2UgMi4yN1xuXHQgKiBAcHJvcGVydHkge29iamVjdH0gdmlld3BvcnQgU2VlIGV4dC12aWVwb3J0LiBAc2luY2UgdjIuMzFcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHdpZGdldCBCYXNlIHdpZGdldCBpbnN0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIEZhbmN5dHJlZSh3aWRnZXQpIHtcblx0XHR0aGlzLndpZGdldCA9IHdpZGdldDtcblx0XHR0aGlzLiRkaXYgPSB3aWRnZXQuZWxlbWVudDtcblx0XHR0aGlzLm9wdGlvbnMgPSB3aWRnZXQub3B0aW9ucztcblx0XHRpZiAodGhpcy5vcHRpb25zKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmxhenlsb2FkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0JC5lcnJvcihcblx0XHRcdFx0XHRcIlRoZSAnbGF6eWxvYWQnIGV2ZW50IGlzIGRlcHJlY2F0ZWQgc2luY2UgMjAxNC0wMi0yNS4gVXNlICdsYXp5TG9hZCcgKHdpdGggdXBwZXJjYXNlIEwpIGluc3RlYWQuXCJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMubG9hZGVycm9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0JC5lcnJvcihcblx0XHRcdFx0XHRcIlRoZSAnbG9hZGVycm9yJyBldmVudCB3YXMgcmVuYW1lZCBzaW5jZSAyMDE0LTA3LTAzLiBVc2UgJ2xvYWRFcnJvcicgKHdpdGggdXBwZXJjYXNlIEUpIGluc3RlYWQuXCJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZnggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcdFwiVGhlICdmeCcgb3B0aW9uIHdhcyByZXBsYWNlZCBieSAndG9nZ2xlRWZmZWN0JyBzaW5jZSAyMDE0LTExLTMwLlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnJlbW92ZU5vZGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcdFwiVGhlICdyZW1vdmVOb2RlJyBldmVudCB3YXMgcmVwbGFjZWQgYnkgJ21vZGlmeUNoaWxkJyBzaW5jZSAyLjIwICgyMDE2LTA5LTEwKS5cIlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLmV4dCA9IHt9OyAvLyBBY3RpdmUgZXh0ZW5zaW9uIGluc3RhbmNlc1xuXHRcdHRoaXMudHlwZXMgPSB7fTtcblx0XHR0aGlzLmNvbHVtbnMgPSB7fTtcblx0XHQvLyBhbGxvdyB0byBpbml0IHRyZWUuZGF0YS5mb28gZnJvbSA8ZGl2IGRhdGEtZm9vPScnPlxuXHRcdHRoaXMuZGF0YSA9IF9nZXRFbGVtZW50RGF0YUFzRGljdCh0aGlzLiRkaXYpO1xuXHRcdC8vIFRPRE86IHVzZSB3aWRnZXQudXVpZCBpbnN0ZWFkP1xuXHRcdHRoaXMuX2lkID0gXCJcIiArICh0aGlzLm9wdGlvbnMudHJlZUlkIHx8ICQudWkuZmFuY3l0cmVlLl9uZXh0SWQrKyk7XG5cdFx0Ly8gVE9ETzogdXNlIHdpZGdldC5ldmVudE5hbWVzcGFjZSBpbnN0ZWFkP1xuXHRcdHRoaXMuX25zID0gXCIuZmFuY3l0cmVlLVwiICsgdGhpcy5faWQ7IC8vIGFwcGVuZCBmb3IgbmFtZXNwYWNlZCBldmVudHNcblx0XHR0aGlzLmFjdGl2ZU5vZGUgPSBudWxsO1xuXHRcdHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcblx0XHR0aGlzLl9oYXNGb2N1cyA9IG51bGw7XG5cdFx0dGhpcy5fdGVtcENhY2hlID0ge307XG5cdFx0dGhpcy5fbGFzdE1vdXNlZG93bk5vZGUgPSBudWxsO1xuXHRcdHRoaXMuX2VuYWJsZVVwZGF0ZSA9IHRydWU7XG5cdFx0dGhpcy5sYXN0U2VsZWN0ZWROb2RlID0gbnVsbDtcblx0XHR0aGlzLnN5c3RlbUZvY3VzRWxlbWVudCA9IG51bGw7XG5cdFx0dGhpcy5sYXN0UXVpY2tzZWFyY2hUZXJtID0gXCJcIjtcblx0XHR0aGlzLmxhc3RRdWlja3NlYXJjaFRpbWUgPSAwO1xuXHRcdHRoaXMudmlld3BvcnQgPSBudWxsOyAvLyBleHQtZ3JpZFxuXG5cdFx0dGhpcy5zdGF0dXNDbGFzc1Byb3BOYW1lID0gXCJzcGFuXCI7XG5cdFx0dGhpcy5hcmlhUHJvcE5hbWUgPSBcImxpXCI7XG5cdFx0dGhpcy5ub2RlQ29udGFpbmVyQXR0ck5hbWUgPSBcImxpXCI7XG5cblx0XHQvLyBSZW1vdmUgcHJldmlvdXMgbWFya3VwIGlmIGFueVxuXHRcdHRoaXMuJGRpdi5maW5kKFwiPnVsLmZhbmN5dHJlZS1jb250YWluZXJcIikucmVtb3ZlKCk7XG5cblx0XHQvLyBDcmVhdGUgYSBub2RlIHdpdGhvdXQgcGFyZW50LlxuXHRcdHZhciBmYWtlUGFyZW50ID0geyB0cmVlOiB0aGlzIH0sXG5cdFx0XHQkdWw7XG5cdFx0dGhpcy5yb290Tm9kZSA9IG5ldyBGYW5jeXRyZWVOb2RlKGZha2VQYXJlbnQsIHtcblx0XHRcdHRpdGxlOiBcInJvb3RcIixcblx0XHRcdGtleTogXCJyb290X1wiICsgdGhpcy5faWQsXG5cdFx0XHRjaGlsZHJlbjogbnVsbCxcblx0XHRcdGV4cGFuZGVkOiB0cnVlLFxuXHRcdH0pO1xuXHRcdHRoaXMucm9vdE5vZGUucGFyZW50ID0gbnVsbDtcblxuXHRcdC8vIENyZWF0ZSByb290IG1hcmt1cFxuXHRcdCR1bCA9ICQoXCI8dWw+XCIsIHtcblx0XHRcdGlkOiBcImZ0LWlkLVwiICsgdGhpcy5faWQsXG5cdFx0XHRjbGFzczogXCJ1aS1mYW5jeXRyZWUgZmFuY3l0cmVlLWNvbnRhaW5lciBmYW5jeXRyZWUtcGxhaW5cIixcblx0XHR9KS5hcHBlbmRUbyh0aGlzLiRkaXYpO1xuXHRcdHRoaXMuJGNvbnRhaW5lciA9ICR1bDtcblx0XHR0aGlzLnJvb3ROb2RlLnVsID0gJHVsWzBdO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5kZWJ1Z0xldmVsID09IG51bGwpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5kZWJ1Z0xldmVsID0gRlQuZGVidWdMZXZlbDtcblx0XHR9XG5cdFx0Ly8gLy8gQWRkIGNvbnRhaW5lciB0byB0aGUgVEFCIGNoYWluXG5cdFx0Ly8gLy8gU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLXByYWN0aWNlcy8jZm9jdXNfYWN0aXZlZGVzY2VuZGFudFxuXHRcdC8vIC8vICM1Nzc6IEFsbG93IHRvIHNldCB0YWJpbmRleCB0byBcIjBcIiwgXCItMVwiIGFuZCBcIlwiXG5cdFx0Ly8gdGhpcy4kY29udGFpbmVyLmF0dHIoXCJ0YWJpbmRleFwiLCB0aGlzLm9wdGlvbnMudGFiaW5kZXgpO1xuXG5cdFx0Ly8gaWYoIHRoaXMub3B0aW9ucy5ydGwgKSB7XG5cdFx0Ly8gXHR0aGlzLiRjb250YWluZXIuYXR0cihcIkRJUlwiLCBcIlJUTFwiKS5hZGRDbGFzcyhcImZhbmN5dHJlZS1ydGxcIik7XG5cdFx0Ly8gLy8gfWVsc2V7XG5cdFx0Ly8gLy9cdHRoaXMuJGNvbnRhaW5lci5hdHRyKFwiRElSXCIsIG51bGwpLnJlbW92ZUNsYXNzKFwiZmFuY3l0cmVlLXJ0bFwiKTtcblx0XHQvLyB9XG5cdFx0Ly8gaWYodGhpcy5vcHRpb25zLmFyaWEpe1xuXHRcdC8vIFx0dGhpcy4kY29udGFpbmVyLmF0dHIoXCJyb2xlXCIsIFwidHJlZVwiKTtcblx0XHQvLyBcdGlmKCB0aGlzLm9wdGlvbnMuc2VsZWN0TW9kZSAhPT0gMSApIHtcblx0XHQvLyBcdFx0dGhpcy4kY29udGFpbmVyLmF0dHIoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLCB0cnVlKTtcblx0XHQvLyBcdH1cblx0XHQvLyB9XG5cdH1cblxuXHRGYW5jeXRyZWUucHJvdG90eXBlID0gLyoqIEBsZW5kcyBGYW5jeXRyZWUjICovIHtcblx0XHQvKiBSZXR1cm4gYSBjb250ZXh0IG9iamVjdCB0aGF0IGNhbiBiZSByZS11c2VkIGZvciBfY2FsbEhvb2soKS5cblx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZSB8IEZhbmN5dHJlZU5vZGUgfCBFdmVudERhdGF9IG9ialxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IG9yaWdpbmFsRXZlbnRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFcblx0XHQgKiBAcmV0dXJucyB7RXZlbnREYXRhfVxuXHRcdCAqL1xuXHRcdF9tYWtlSG9va0NvbnRleHQ6IGZ1bmN0aW9uKG9iaiwgb3JpZ2luYWxFdmVudCwgZXh0cmEpIHtcblx0XHRcdHZhciBjdHgsIHRyZWU7XG5cdFx0XHRpZiAob2JqLm5vZGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHQvLyBvYmogaXMgYWxyZWFkeSBhIGNvbnRleHQgb2JqZWN0XG5cdFx0XHRcdGlmIChvcmlnaW5hbEV2ZW50ICYmIG9iai5vcmlnaW5hbEV2ZW50ICE9PSBvcmlnaW5hbEV2ZW50KSB7XG5cdFx0XHRcdFx0JC5lcnJvcihcImludmFsaWQgYXJnc1wiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjdHggPSBvYmo7XG5cdFx0XHR9IGVsc2UgaWYgKG9iai50cmVlKSB7XG5cdFx0XHRcdC8vIG9iaiBpcyBhIEZhbmN5dHJlZU5vZGVcblx0XHRcdFx0dHJlZSA9IG9iai50cmVlO1xuXHRcdFx0XHRjdHggPSB7XG5cdFx0XHRcdFx0bm9kZTogb2JqLFxuXHRcdFx0XHRcdHRyZWU6IHRyZWUsXG5cdFx0XHRcdFx0d2lkZ2V0OiB0cmVlLndpZGdldCxcblx0XHRcdFx0XHRvcHRpb25zOiB0cmVlLndpZGdldC5vcHRpb25zLFxuXHRcdFx0XHRcdG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnQsXG5cdFx0XHRcdFx0dHlwZUluZm86IHRyZWUudHlwZXNbb2JqLnR5cGVdIHx8IHt9LFxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChvYmoud2lkZ2V0KSB7XG5cdFx0XHRcdC8vIG9iaiBpcyBhIEZhbmN5dHJlZVxuXHRcdFx0XHRjdHggPSB7XG5cdFx0XHRcdFx0bm9kZTogbnVsbCxcblx0XHRcdFx0XHR0cmVlOiBvYmosXG5cdFx0XHRcdFx0d2lkZ2V0OiBvYmoud2lkZ2V0LFxuXHRcdFx0XHRcdG9wdGlvbnM6IG9iai53aWRnZXQub3B0aW9ucyxcblx0XHRcdFx0XHRvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JC5lcnJvcihcImludmFsaWQgYXJnc1wiKTtcblx0XHRcdH1cblx0XHRcdGlmIChleHRyYSkge1xuXHRcdFx0XHQkLmV4dGVuZChjdHgsIGV4dHJhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjdHg7XG5cdFx0fSxcblx0XHQvKiBUcmlnZ2VyIGEgaG9vayBmdW5jdGlvbjogZnVuY05hbWUoY3R4LCBbLi4uXSkuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gZnVuY05hbWVcblx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZXxGYW5jeXRyZWVOb2RlfEV2ZW50RGF0YX0gY29udGV4dE9iamVjdFxuXHRcdCAqIEBwYXJhbSB7YW55fSAgW19leHRyYUFyZ3NdIG9wdGlvbmFsIGFkZGl0aW9uYWwgYXJndW1lbnRzXG5cdFx0ICogQHJldHVybnMge2FueX1cblx0XHQgKi9cblx0XHRfY2FsbEhvb2s6IGZ1bmN0aW9uKGZ1bmNOYW1lLCBjb250ZXh0T2JqZWN0LCBfZXh0cmFBcmdzKSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fbWFrZUhvb2tDb250ZXh0KGNvbnRleHRPYmplY3QpLFxuXHRcdFx0XHRmbiA9IHRoaXNbZnVuY05hbWVdLFxuXHRcdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcblx0XHRcdGlmICghJC5pc0Z1bmN0aW9uKGZuKSkge1xuXHRcdFx0XHQkLmVycm9yKFwiX2NhbGxIb29rKCdcIiArIGZ1bmNOYW1lICsgXCInKSBpcyBub3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdH1cblx0XHRcdGFyZ3MudW5zaGlmdChjdHgpO1xuXHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcIl9ob29rXCIsIGZ1bmNOYW1lLCBjdHgubm9kZSAmJiBjdHgubm9kZS50b1N0cmluZygpIHx8IGN0eC50cmVlLnRvU3RyaW5nKCksIGFyZ3MpO1xuXHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH0sXG5cdFx0X3NldEV4cGlyaW5nVmFsdWU6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG1zKSB7XG5cdFx0XHR0aGlzLl90ZW1wQ2FjaGVba2V5XSA9IHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRleHBpcmU6IERhdGUubm93KCkgKyAoK21zIHx8IDUwKSxcblx0XHRcdH07XG5cdFx0fSxcblx0XHRfZ2V0RXhwaXJpbmdWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl90ZW1wQ2FjaGVba2V5XTtcblx0XHRcdGlmIChlbnRyeSAmJiBlbnRyeS5leHBpcmUgPiBEYXRlLm5vdygpKSB7XG5cdFx0XHRcdHJldHVybiBlbnRyeS52YWx1ZTtcblx0XHRcdH1cblx0XHRcdGRlbGV0ZSB0aGlzLl90ZW1wQ2FjaGVba2V5XTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0LyogQ2hlY2sgaWYgY3VycmVudCBleHRlbnNpb25zIGRlcGVuZGVuY2llcyBhcmUgbWV0IGFuZCB0aHJvdyBhbiBlcnJvciBpZiBub3QuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIGluc2lkZSB0aGUgYHRyZWVJbml0YCBob29rIGZvciBjdXN0b20gZXh0ZW5zaW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gbmFtZSBvZiB0aGUgcmVxdWlyZWQgZXh0ZW5zaW9uXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZWQ9dHJ1ZV0gcGFzcyBgZmFsc2VgIGlmIHRoZSBleHRlbnNpb24gaXMgb3B0aW9uYWwsIGJ1dCB3ZSB3YW50IHRvIGNoZWNrIGZvciBvcmRlciBpZiBpdCBpcyBwcmVzZW50XG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbYmVmb3JlXSBgdHJ1ZWAgaWYgYG5hbWVgIG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIHRoaXMsIGBmYWxzZWAgb3RoZXJ3aXNlICh1c2UgYG51bGxgIGlmIG9yZGVyIGRvZXNuJ3QgbWF0dGVyKVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgZXJyb3IgbWVzc2FnZSAoZGVmYXVsdHMgdG8gYSBkZXNjcmlwdHZlIGVycm9yIG1lc3NhZ2UpXG5cdFx0ICovXG5cdFx0X3JlcXVpcmVFeHRlbnNpb246IGZ1bmN0aW9uKG5hbWUsIHJlcXVpcmVkLCBiZWZvcmUsIG1lc3NhZ2UpIHtcblx0XHRcdGlmIChiZWZvcmUgIT0gbnVsbCkge1xuXHRcdFx0XHRiZWZvcmUgPSAhIWJlZm9yZTtcblx0XHRcdH1cblx0XHRcdHZhciB0aGlzTmFtZSA9IHRoaXMuX2xvY2FsLm5hbWUsXG5cdFx0XHRcdGV4dExpc3QgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyxcblx0XHRcdFx0aXNCZWZvcmUgPVxuXHRcdFx0XHRcdCQuaW5BcnJheShuYW1lLCBleHRMaXN0KSA8ICQuaW5BcnJheSh0aGlzTmFtZSwgZXh0TGlzdCksXG5cdFx0XHRcdGlzTWlzc2luZyA9IHJlcXVpcmVkICYmIHRoaXMuZXh0W25hbWVdID09IG51bGwsXG5cdFx0XHRcdGJhZE9yZGVyID0gIWlzTWlzc2luZyAmJiBiZWZvcmUgIT0gbnVsbCAmJiBiZWZvcmUgIT09IGlzQmVmb3JlO1xuXG5cdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHR0aGlzTmFtZSAmJiB0aGlzTmFtZSAhPT0gbmFtZSxcblx0XHRcdFx0XCJpbnZhbGlkIG9yIHNhbWUgbmFtZSAnXCIgKyB0aGlzTmFtZSArIFwiJyAocmVxdWlyZSB5b3Vyc2VsZj8pXCJcblx0XHRcdCk7XG5cblx0XHRcdGlmIChpc01pc3NpbmcgfHwgYmFkT3JkZXIpIHtcblx0XHRcdFx0aWYgKCFtZXNzYWdlKSB7XG5cdFx0XHRcdFx0aWYgKGlzTWlzc2luZyB8fCByZXF1aXJlZCkge1xuXHRcdFx0XHRcdFx0bWVzc2FnZSA9XG5cdFx0XHRcdFx0XHRcdFwiJ1wiICtcblx0XHRcdFx0XHRcdFx0dGhpc05hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIicgZXh0ZW5zaW9uIHJlcXVpcmVzICdcIiArXG5cdFx0XHRcdFx0XHRcdG5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIidcIjtcblx0XHRcdFx0XHRcdGlmIChiYWRPcmRlcikge1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlICs9XG5cdFx0XHRcdFx0XHRcdFx0XCIgdG8gYmUgcmVnaXN0ZXJlZCBcIiArXG5cdFx0XHRcdFx0XHRcdFx0KGJlZm9yZSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpICtcblx0XHRcdFx0XHRcdFx0XHRcIiBpdHNlbGZcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWVzc2FnZSA9XG5cdFx0XHRcdFx0XHRcdFwiSWYgdXNlZCB0b2dldGhlciwgYFwiICtcblx0XHRcdFx0XHRcdFx0bmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiYCBtdXN0IGJlIHJlZ2lzdGVyZWQgXCIgK1xuXHRcdFx0XHRcdFx0XHQoYmVmb3JlID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIikgK1xuXHRcdFx0XHRcdFx0XHRcIiBgXCIgK1xuXHRcdFx0XHRcdFx0XHR0aGlzTmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiYFwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQkLmVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXHRcdC8qKiBBY3RpdmF0ZSBub2RlIHdpdGggYSBnaXZlbiBrZXkgYW5kIGZpcmUgZm9jdXMgYW5kIGFjdGl2YXRlIGV2ZW50cy5cblx0XHQgKlxuXHRcdCAqIEEgcHJldmlvdXNseSBhY3RpdmF0ZWQgbm9kZSB3aWxsIGJlIGRlYWN0aXZhdGVkLlxuXHRcdCAqIElmIGFjdGl2ZVZpc2libGUgb3B0aW9uIGlzIHNldCwgYWxsIHBhcmVudHMgd2lsbCBiZSBleHBhbmRlZCBhcyBuZWNlc3NhcnkuXG5cdFx0ICogUGFzcyBrZXkgPSBmYWxzZSwgdG8gZGVhY3RpdmF0ZSB0aGUgY3VycmVudCBub2RlIG9ubHkuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGtleVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gYWRkaXRpb25hbCBvcHRpb25zLiBEZWZhdWx0cyB0byB7bm9FdmVudHM6IGZhbHNlLCBub0ZvY3VzOiBmYWxzZX1cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX0gYWN0aXZhdGVkIG5vZGUgKG51bGwsIGlmIG5vdCBmb3VuZClcblx0XHQgKi9cblx0XHRhY3RpdmF0ZUtleTogZnVuY3Rpb24oa2V5LCBvcHRzKSB7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZUJ5S2V5KGtleSk7XG5cdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRub2RlLnNldEFjdGl2ZSh0cnVlLCBvcHRzKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5hY3RpdmVOb2RlKSB7XG5cdFx0XHRcdHRoaXMuYWN0aXZlTm9kZS5zZXRBY3RpdmUoZmFsc2UsIG9wdHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0fSxcblx0XHQvKiogKGV4cGVyaW1lbnRhbCkgQWRkIGNoaWxkIHN0YXR1cyBub2RlcyB0aGF0IGluZGljYXRlICdNb3JlLi4uJywgLi4uLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbnxvYmplY3R9IG5vZGUgb3B0aW9uYWwgbm9kZSBkZWZpbml0aW9uLiBQYXNzIGBmYWxzZWAgdG8gcmVtb3ZlIGFsbCBwYWdpbmcgbm9kZXMuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlPSdhcHBlbmQnXSAnY2hpbGQnfGZpcnN0Q2hpbGQnXG5cdFx0ICogQHNpbmNlIDIuMTVcblx0XHQgKi9cblx0XHRhZGRQYWdpbmdOb2RlOiBmdW5jdGlvbihub2RlLCBtb2RlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yb290Tm9kZS5hZGRQYWdpbmdOb2RlKG5vZGUsIG1vZGUpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogKGV4cGVyaW1lbnRhbCkgQXBwbHkgYSBtb2RpZmljYXRpb24gKG9yIG5hdmlnYXRpb24pIG9wZXJhdGlvbi5cblx0XHQgKlxuXHRcdCAqIFZhbGlkIGNvbW1hbmRzOlxuXHRcdCAqICAgLSAnbW92ZVVwJywgJ21vdmVEb3duJ1xuXHRcdCAqICAgLSAnaW5kZW50JywgJ291dGRlbnQnXG5cdFx0ICogICAtICdyZW1vdmUnXG5cdFx0ICogICAtICdlZGl0JywgJ2FkZENoaWxkJywgJ2FkZFNpYmxpbmcnOiAocmVxaXJlcyBleHQtZWRpdCBleHRlbnNpb24pXG5cdFx0ICogICAtICdjdXQnLCAnY29weScsICdwYXN0ZSc6ICh1c2UgYW4gaW50ZXJuYWwgc2luZ2xldG9uICdjbGlwYm9hcmQnKVxuXHRcdCAqICAgLSAnZG93bicsICdmaXJzdCcsICdsYXN0JywgJ2xlZnQnLCAncGFyZW50JywgJ3JpZ2h0JywgJ3VwJzogbmF2aWdhdGVcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbWRcblx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZU5vZGV9IFtub2RlPWFjdGl2ZV9ub2RlXVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gQ3VycmVudGx5IHVudXNlZFxuXHRcdCAqXG5cdFx0ICogQHNpbmNlIDIuMzJcblx0XHQgKi9cblx0XHRhcHBseUNvbW1hbmQ6IGZ1bmN0aW9uKGNtZCwgbm9kZSwgb3B0c18pIHtcblx0XHRcdHZhciAvLyBjbGlwYm9hcmQsXG5cdFx0XHRcdHJlZk5vZGU7XG5cdFx0XHQvLyBvcHRzID0gJC5leHRlbmQoXG5cdFx0XHQvLyBcdHsgc2V0QWN0aXZlOiB0cnVlLCBjbGlwYm9hcmQ6IENMSVBCT0FSRCB9LFxuXHRcdFx0Ly8gXHRvcHRzX1xuXHRcdFx0Ly8gKTtcblxuXHRcdFx0bm9kZSA9IG5vZGUgfHwgdGhpcy5nZXRBY3RpdmVOb2RlKCk7XG5cdFx0XHQvLyBjbGlwYm9hcmQgPSBvcHRzLmNsaXBib2FyZDtcblxuXHRcdFx0c3dpdGNoIChjbWQpIHtcblx0XHRcdFx0Ly8gU29ydGluZyBhbmQgaW5kZW50YXRpb246XG5cdFx0XHRcdGNhc2UgXCJtb3ZlVXBcIjpcblx0XHRcdFx0XHRyZWZOb2RlID0gbm9kZS5nZXRQcmV2U2libGluZygpO1xuXHRcdFx0XHRcdGlmIChyZWZOb2RlKSB7XG5cdFx0XHRcdFx0XHRub2RlLm1vdmVUbyhyZWZOb2RlLCBcImJlZm9yZVwiKTtcblx0XHRcdFx0XHRcdG5vZGUuc2V0QWN0aXZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwibW92ZURvd25cIjpcblx0XHRcdFx0XHRyZWZOb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuXHRcdFx0XHRcdGlmIChyZWZOb2RlKSB7XG5cdFx0XHRcdFx0XHRub2RlLm1vdmVUbyhyZWZOb2RlLCBcImFmdGVyXCIpO1xuXHRcdFx0XHRcdFx0bm9kZS5zZXRBY3RpdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJpbmRlbnRcIjpcblx0XHRcdFx0XHRyZWZOb2RlID0gbm9kZS5nZXRQcmV2U2libGluZygpO1xuXHRcdFx0XHRcdGlmIChyZWZOb2RlKSB7XG5cdFx0XHRcdFx0XHRub2RlLm1vdmVUbyhyZWZOb2RlLCBcImNoaWxkXCIpO1xuXHRcdFx0XHRcdFx0cmVmTm9kZS5zZXRFeHBhbmRlZCgpO1xuXHRcdFx0XHRcdFx0bm9kZS5zZXRBY3RpdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJvdXRkZW50XCI6XG5cdFx0XHRcdFx0aWYgKCFub2RlLmlzVG9wTGV2ZWwoKSkge1xuXHRcdFx0XHRcdFx0bm9kZS5tb3ZlVG8obm9kZS5nZXRQYXJlbnQoKSwgXCJhZnRlclwiKTtcblx0XHRcdFx0XHRcdG5vZGUuc2V0QWN0aXZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHQvLyBSZW1vdmU6XG5cdFx0XHRcdGNhc2UgXCJyZW1vdmVcIjpcblx0XHRcdFx0XHRyZWZOb2RlID0gbm9kZS5nZXRQcmV2U2libGluZygpIHx8IG5vZGUuZ2V0UGFyZW50KCk7XG5cdFx0XHRcdFx0bm9kZS5yZW1vdmUoKTtcblx0XHRcdFx0XHRpZiAocmVmTm9kZSkge1xuXHRcdFx0XHRcdFx0cmVmTm9kZS5zZXRBY3RpdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdC8vIEFkZCwgZWRpdCAocmVxdWlyZXMgZXh0LWVkaXQpOlxuXHRcdFx0XHRjYXNlIFwiYWRkQ2hpbGRcIjpcblx0XHRcdFx0XHRub2RlLmVkaXRDcmVhdGVOb2RlKFwiY2hpbGRcIiwgXCJcIik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJhZGRTaWJsaW5nXCI6XG5cdFx0XHRcdFx0bm9kZS5lZGl0Q3JlYXRlTm9kZShcImFmdGVyXCIsIFwiXCIpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicmVuYW1lXCI6XG5cdFx0XHRcdFx0bm9kZS5lZGl0U3RhcnQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Ly8gU2ltcGxlIGNsaXBib2FyZCBzaW11bGF0aW9uOlxuXHRcdFx0XHQvLyBjYXNlIFwiY3V0XCI6XG5cdFx0XHRcdC8vIFx0Y2xpcGJvYXJkID0geyBtb2RlOiBjbWQsIGRhdGE6IG5vZGUgfTtcblx0XHRcdFx0Ly8gXHRicmVhaztcblx0XHRcdFx0Ly8gY2FzZSBcImNvcHlcIjpcblx0XHRcdFx0Ly8gXHRjbGlwYm9hcmQgPSB7XG5cdFx0XHRcdC8vIFx0XHRtb2RlOiBjbWQsXG5cdFx0XHRcdC8vIFx0XHRkYXRhOiBub2RlLnRvRGljdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdC8vIFx0XHRcdGRlbGV0ZSBuLmtleTtcblx0XHRcdFx0Ly8gXHRcdH0pLFxuXHRcdFx0XHQvLyBcdH07XG5cdFx0XHRcdC8vIFx0YnJlYWs7XG5cdFx0XHRcdC8vIGNhc2UgXCJjbGVhclwiOlxuXHRcdFx0XHQvLyBcdGNsaXBib2FyZCA9IG51bGw7XG5cdFx0XHRcdC8vIFx0YnJlYWs7XG5cdFx0XHRcdC8vIGNhc2UgXCJwYXN0ZVwiOlxuXHRcdFx0XHQvLyBcdGlmIChjbGlwYm9hcmQubW9kZSA9PT0gXCJjdXRcIikge1xuXHRcdFx0XHQvLyBcdFx0Ly8gcmVmTm9kZSA9IG5vZGUuZ2V0UHJldlNpYmxpbmcoKTtcblx0XHRcdFx0Ly8gXHRcdGNsaXBib2FyZC5kYXRhLm1vdmVUbyhub2RlLCBcImNoaWxkXCIpO1xuXHRcdFx0XHQvLyBcdFx0Y2xpcGJvYXJkLmRhdGEuc2V0QWN0aXZlKCk7XG5cdFx0XHRcdC8vIFx0fSBlbHNlIGlmIChjbGlwYm9hcmQubW9kZSA9PT0gXCJjb3B5XCIpIHtcblx0XHRcdFx0Ly8gXHRcdG5vZGUuYWRkQ2hpbGRyZW4oY2xpcGJvYXJkLmRhdGEpLnNldEFjdGl2ZSgpO1xuXHRcdFx0XHQvLyBcdH1cblx0XHRcdFx0Ly8gXHRicmVhaztcblx0XHRcdFx0Ly8gTmF2aWdhdGlvbiBjb21tYW5kczpcblx0XHRcdFx0Y2FzZSBcImRvd25cIjpcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdGNhc2UgXCJsYXN0XCI6XG5cdFx0XHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0XHRcdGNhc2UgXCJwYXJlbnRcIjpcblx0XHRcdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0XHRcdGNhc2UgXCJ1cFwiOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLm5hdmlnYXRlKGNtZCk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0JC5lcnJvcihcIlVuaGFuZGxlZCBjb21tYW5kOiAnXCIgKyBjbWQgKyBcIidcIik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiogKGV4cGVyaW1lbnRhbCkgTW9kaWZ5IGV4aXN0aW5nIGRhdGEgbW9kZWwuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBwYXRjaExpc3QgYXJyYXkgb2YgW2tleSwgTm9kZVBhdGNoXSBhcnJheXNcblx0XHQgKiBAcmV0dXJucyB7JC5Qcm9taXNlfSByZXNvbHZlZCwgd2hlbiBhbGwgcGF0Y2hlcyBoYXZlIGJlZW4gYXBwbGllZFxuXHRcdCAqIEBzZWUgVHJlZVBhdGNoXG5cdFx0ICovXG5cdFx0YXBwbHlQYXRjaDogZnVuY3Rpb24ocGF0Y2hMaXN0KSB7XG5cdFx0XHR2YXIgZGZkLFxuXHRcdFx0XHRpLFxuXHRcdFx0XHRwMixcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXRjaCxcblx0XHRcdFx0bm9kZSxcblx0XHRcdFx0cGF0Y2hDb3VudCA9IHBhdGNoTGlzdC5sZW5ndGgsXG5cdFx0XHRcdGRlZmVycmVkTGlzdCA9IFtdO1xuXG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGF0Y2hDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHAyID0gcGF0Y2hMaXN0W2ldO1xuXHRcdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHRcdHAyLmxlbmd0aCA9PT0gMixcblx0XHRcdFx0XHRcInBhdGNoTGlzdCBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aC0yLWFycmF5c1wiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGtleSA9IHAyWzBdO1xuXHRcdFx0XHRwYXRjaCA9IHAyWzFdO1xuXHRcdFx0XHRub2RlID0ga2V5ID09PSBudWxsID8gdGhpcy5yb290Tm9kZSA6IHRoaXMuZ2V0Tm9kZUJ5S2V5KGtleSk7XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0ZGZkID0gbmV3ICQuRGVmZXJyZWQoKTtcblx0XHRcdFx0XHRkZWZlcnJlZExpc3QucHVzaChkZmQpO1xuXHRcdFx0XHRcdG5vZGUuYXBwbHlQYXRjaChwYXRjaCkuYWx3YXlzKF9tYWtlUmVzb2x2ZUZ1bmMoZGZkLCBub2RlKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy53YXJuKFwiY291bGQgbm90IGZpbmQgbm9kZSB3aXRoIGtleSAnXCIgKyBrZXkgKyBcIidcIik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFJldHVybiBhIHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCwgd2hlbiBBTEwgcGF0Y2hlcyB3ZXJlIGFwcGxpZWRcblx0XHRcdHJldHVybiAkLndoZW4uYXBwbHkoJCwgZGVmZXJyZWRMaXN0KS5wcm9taXNlKCk7XG5cdFx0fSxcblx0XHQvKiBUT0RPOiBpbXBsZW1lbnQgaW4gZG5kIGV4dGVuc2lvblxuXHRcdGNhbmNlbERyYWc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGQgPSAkLnVpLmRkbWFuYWdlci5jdXJyZW50O1xuXHRcdFx0XHRpZihkZCl7XG5cdFx0XHRcdFx0ZGQuY2FuY2VsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0Ki9cblx0XHQvKiogUmVtb3ZlIGFsbCBub2Rlcy5cblx0XHQgKiBAc2luY2UgMi4xNFxuXHRcdCAqL1xuXHRcdGNsZWFyOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHRoaXMuX2NhbGxIb29rKFwidHJlZUNsZWFyXCIsIHRoaXMpO1xuXHRcdH0sXG5cdFx0LyoqIFJldHVybiB0aGUgbnVtYmVyIG9mIG5vZGVzLlxuXHRcdCAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuXHRcdCAqL1xuXHRcdGNvdW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnJvb3ROb2RlLmNvdW50Q2hpbGRyZW4oKTtcblx0XHR9LFxuXHRcdC8qKiBXcml0ZSB0byBicm93c2VyIGNvbnNvbGUgaWYgZGVidWdMZXZlbCA+PSA0IChwcmVwZW5kaW5nIHRyZWUgbmFtZSlcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Kn0gbXNnIHN0cmluZyBvciBvYmplY3Qgb3IgYXJyYXkgb2Ygc3VjaFxuXHRcdCAqL1xuXHRcdGRlYnVnOiBmdW5jdGlvbihtc2cpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZGVidWdMZXZlbCA+PSA0KSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRjb25zb2xlQXBwbHkoXCJsb2dcIiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKiBFbmFibGUgKG9yIGRpc2FibGUpIHRoZSB0cmVlIGNvbnRyb2wuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbGFnPXRydWVdIHBhc3MgZmFsc2UgdG8gZGlzYWJsZVxuXHRcdCAqIEBzaW5jZSAyLjMwXG5cdFx0ICovXG5cdFx0ZW5hYmxlOiBmdW5jdGlvbihmbGFnKSB7XG5cdFx0XHRpZiAoZmxhZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy53aWRnZXQuZGlzYWJsZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy53aWRnZXQuZW5hYmxlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiogVGVtcG9yYXJpbHkgc3VwcHJlc3MgcmVuZGVyaW5nIHRvIGltcHJvdmUgcGVyZm9ybWFuY2Ugb24gYnVsay11cGRhdGVzLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBmbGFnXG5cdFx0ICogQHJldHVybnMge2Jvb2xlYW59IHByZXZpb3VzIHN0YXR1c1xuXHRcdCAqIEBzaW5jZSAyLjE5XG5cdFx0ICovXG5cdFx0ZW5hYmxlVXBkYXRlOiBmdW5jdGlvbihmbGFnKSB7XG5cdFx0XHRmbGFnID0gZmxhZyAhPT0gZmFsc2U7XG5cdFx0XHRpZiAoISF0aGlzLl9lbmFibGVVcGRhdGUgPT09ICEhZmxhZykge1xuXHRcdFx0XHRyZXR1cm4gZmxhZztcblx0XHRcdH1cblx0XHRcdHRoaXMuX2VuYWJsZVVwZGF0ZSA9IGZsYWc7XG5cdFx0XHRpZiAoZmxhZykge1xuXHRcdFx0XHR0aGlzLmRlYnVnKFwiZW5hYmxlVXBkYXRlKHRydWUpOiByZWRyYXcgXCIpOyAvLywgdGhpcy5fZGlydHlSb290cyk7XG5cdFx0XHRcdHRoaXMuX2NhbGxIb29rKFwidHJlZVN0cnVjdHVyZUNoYW5nZWRcIiwgdGhpcywgXCJlbmFibGVVcGRhdGVcIik7XG5cdFx0XHRcdHRoaXMucmVuZGVyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBcdHRoaXMuX2RpcnR5Um9vdHMgPSBudWxsO1xuXHRcdFx0XHR0aGlzLmRlYnVnKFwiZW5hYmxlVXBkYXRlKGZhbHNlKS4uLlwiKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZmxhZzsgLy8gcmV0dXJuIHByZXZpb3VzIHZhbHVlXG5cdFx0fSxcblx0XHQvKiogV3JpdGUgZXJyb3IgdG8gYnJvd3NlciBjb25zb2xlIGlmIGRlYnVnTGV2ZWwgPj0gMSAocHJlcGVuZGluZyB0cmVlIGluZm8pXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0geyp9IG1zZyBzdHJpbmcgb3Igb2JqZWN0IG9yIGFycmF5IG9mIHN1Y2hcblx0XHQgKi9cblx0XHRlcnJvcjogZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRlYnVnTGV2ZWwgPj0gMSkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUudW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgdGhpcy50b1N0cmluZygpKTtcblx0XHRcdFx0Y29uc29sZUFwcGx5KFwiZXJyb3JcIiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdC8qKiBFeHBhbmQgKG9yIGNvbGxhcHNlKSBhbGwgcGFyZW50IG5vZGVzLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBjb252ZW5pZW5jZSBtZXRob2QgdXNlcyBgdHJlZS52aXNpdCgpYCBhbmQgYHRyZWUuc2V0RXhwYW5kZWQoKWBcblx0XHQgKiBpbnRlcm5hbGx5LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhZz10cnVlXSBwYXNzIGZhbHNlIHRvIGNvbGxhcHNlXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSBwYXNzZWQgdG8gc2V0RXhwYW5kZWQoKVxuXHRcdCAqIEBzaW5jZSAyLjMwXG5cdFx0ICovXG5cdFx0ZXhwYW5kQWxsOiBmdW5jdGlvbihmbGFnLCBvcHRzKSB7XG5cdFx0XHR2YXIgcHJldiA9IHRoaXMuZW5hYmxlVXBkYXRlKGZhbHNlKTtcblxuXHRcdFx0ZmxhZyA9IGZsYWcgIT09IGZhbHNlO1xuXHRcdFx0dGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRub2RlLmhhc0NoaWxkcmVuKCkgIT09IGZhbHNlICYmXG5cdFx0XHRcdFx0bm9kZS5pc0V4cGFuZGVkKCkgIT09IGZsYWdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0bm9kZS5zZXRFeHBhbmRlZChmbGFnLCBvcHRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmVuYWJsZVVwZGF0ZShwcmV2KTtcblx0XHR9LFxuXHRcdC8qKkZpbmQgYWxsIG5vZGVzIHRoYXQgbWF0Y2hlcyBjb25kaXRpb24uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZyB8IGZ1bmN0aW9uKG5vZGUpfSBtYXRjaCB0aXRsZSBzdHJpbmcgdG8gc2VhcmNoIGZvciwgb3IgYVxuXHRcdCAqICAgICBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIGEgbm9kZSBpcyBtYXRjaGVkLlxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlW119IGFycmF5IG9mIG5vZGVzIChtYXkgYmUgZW1wdHkpXG5cdFx0ICogQHNlZSBGYW5jeXRyZWVOb2RlI2ZpbmRBbGxcblx0XHQgKiBAc2luY2UgMi4xMlxuXHRcdCAqL1xuXHRcdGZpbmRBbGw6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yb290Tm9kZS5maW5kQWxsKG1hdGNoKTtcblx0XHR9LFxuXHRcdC8qKkZpbmQgZmlyc3Qgbm9kZSB0aGF0IG1hdGNoZXMgY29uZGl0aW9uLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmcgfCBmdW5jdGlvbihub2RlKX0gbWF0Y2ggdGl0bGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IsIG9yIGFcblx0XHQgKiAgICAgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB0cnVlYCBpZiBhIG5vZGUgaXMgbWF0Y2hlZC5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX0gbWF0Y2hpbmcgbm9kZSBvciBudWxsXG5cdFx0ICogQHNlZSBGYW5jeXRyZWVOb2RlI2ZpbmRGaXJzdFxuXHRcdCAqIEBzaW5jZSAyLjEyXG5cdFx0ICovXG5cdFx0ZmluZEZpcnN0OiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucm9vdE5vZGUuZmluZEZpcnN0KG1hdGNoKTtcblx0XHR9LFxuXHRcdC8qKiBGaW5kIHRoZSBuZXh0IHZpc2libGUgbm9kZSB0aGF0IHN0YXJ0cyB3aXRoIGBtYXRjaGAsIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgXG5cdFx0ICogYW5kIHdyYXAtYXJvdW5kIGF0IHRoZSBlbmQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbn0gbWF0Y2hcblx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZU5vZGV9IFtzdGFydE5vZGVdIGRlZmF1bHRzIHRvIGZpcnN0IG5vZGVcblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX0gbWF0Y2hpbmcgbm9kZSBvciBudWxsXG5cdFx0ICovXG5cdFx0ZmluZE5leHROb2RlOiBmdW5jdGlvbihtYXRjaCwgc3RhcnROb2RlKSB7XG5cdFx0XHQvLywgdmlzaWJsZU9ubHkpIHtcblx0XHRcdHZhciByZXMgPSBudWxsLFxuXHRcdFx0XHRmaXJzdE5vZGUgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblxuXHRcdFx0bWF0Y2ggPVxuXHRcdFx0XHR0eXBlb2YgbWF0Y2ggPT09IFwic3RyaW5nXCJcblx0XHRcdFx0XHQ/IF9tYWtlTm9kZVRpdGxlU3RhcnRNYXRjaGVyKG1hdGNoKVxuXHRcdFx0XHRcdDogbWF0Y2g7XG5cdFx0XHRzdGFydE5vZGUgPSBzdGFydE5vZGUgfHwgZmlyc3ROb2RlO1xuXG5cdFx0XHRmdW5jdGlvbiBfY2hlY2tOb2RlKG4pIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJfY2hlY2sgXCIgKyBuKVxuXHRcdFx0XHRpZiAobWF0Y2gobikpIHtcblx0XHRcdFx0XHRyZXMgPSBuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXMgfHwgbiA9PT0gc3RhcnROb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnZpc2l0Um93cyhfY2hlY2tOb2RlLCB7XG5cdFx0XHRcdHN0YXJ0OiBzdGFydE5vZGUsXG5cdFx0XHRcdGluY2x1ZGVTZWxmOiBmYWxzZSxcblx0XHRcdH0pO1xuXHRcdFx0Ly8gV3JhcCBhcm91bmQgc2VhcmNoXG5cdFx0XHRpZiAoIXJlcyAmJiBzdGFydE5vZGUgIT09IGZpcnN0Tm9kZSkge1xuXHRcdFx0XHR0aGlzLnZpc2l0Um93cyhfY2hlY2tOb2RlLCB7XG5cdFx0XHRcdFx0c3RhcnQ6IGZpcnN0Tm9kZSxcblx0XHRcdFx0XHRpbmNsdWRlU2VsZjogdHJ1ZSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cdFx0LyoqIEZpbmQgYSBub2RlIHJlbGF0aXZlIHRvIGFub3RoZXIgbm9kZS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gbm9kZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gd2hlcmUgJ2Rvd24nLCAnZmlyc3QnLCAnbGFzdCcsICdsZWZ0JywgJ3BhcmVudCcsICdyaWdodCcsIG9yICd1cCcuXG5cdFx0ICogICAoQWx0ZXJuYXRpdmVseSB0aGUga2V5Q29kZSB0aGF0IHdvdWxkIG5vcm1hbGx5IHRyaWdnZXIgdGhpcyBtb3ZlLFxuXHRcdCAqICAgZS5nLiBgJC51aS5rZXlDb2RlLkxFRlRgID0gJ2xlZnQnLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVIaWRkZW49ZmFsc2VdIE5vdCB5ZXQgaW1wbGVtZW50ZWRcblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZXxudWxsfVxuXHRcdCAqIEBzaW5jZSB2Mi4zMVxuXHRcdCAqL1xuXHRcdGZpbmRSZWxhdGVkTm9kZTogZnVuY3Rpb24obm9kZSwgd2hlcmUsIGluY2x1ZGVIaWRkZW4pIHtcblx0XHRcdHZhciByZXMgPSBudWxsLFxuXHRcdFx0XHRLQyA9ICQudWkua2V5Q29kZTtcblxuXHRcdFx0c3dpdGNoICh3aGVyZSkge1xuXHRcdFx0XHRjYXNlIFwicGFyZW50XCI6XG5cdFx0XHRcdGNhc2UgS0MuQkFDS1NQQUNFOlxuXHRcdFx0XHRcdGlmIChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5wYXJlbnQpIHtcblx0XHRcdFx0XHRcdHJlcyA9IG5vZGUucGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XG5cdFx0XHRcdGNhc2UgS0MuSE9NRTpcblx0XHRcdFx0XHQvLyBGaXJzdCB2aXNpYmxlIG5vZGVcblx0XHRcdFx0XHR0aGlzLnZpc2l0KGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0XHRcdGlmIChuLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0XHRcdHJlcyA9IG47XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcblx0XHRcdFx0Y2FzZSBLQy5FTkQ6XG5cdFx0XHRcdFx0dGhpcy52aXNpdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdFx0XHQvLyBsYXN0IHZpc2libGUgbm9kZVxuXHRcdFx0XHRcdFx0aWYgKG4uaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzID0gbjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImxlZnRcIjpcblx0XHRcdFx0Y2FzZSBLQy5MRUZUOlxuXHRcdFx0XHRcdGlmIChub2RlLmV4cGFuZGVkKSB7XG5cdFx0XHRcdFx0XHRub2RlLnNldEV4cGFuZGVkKGZhbHNlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnBhcmVudCkge1xuXHRcdFx0XHRcdFx0cmVzID0gbm9kZS5wYXJlbnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwicmlnaHRcIjpcblx0XHRcdFx0Y2FzZSBLQy5SSUdIVDpcblx0XHRcdFx0XHRpZiAoIW5vZGUuZXhwYW5kZWQgJiYgKG5vZGUuY2hpbGRyZW4gfHwgbm9kZS5sYXp5KSkge1xuXHRcdFx0XHRcdFx0bm9kZS5zZXRFeHBhbmRlZCgpO1xuXHRcdFx0XHRcdFx0cmVzID0gbm9kZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHJlcyA9IG5vZGUuY2hpbGRyZW5bMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwidXBcIjpcblx0XHRcdFx0Y2FzZSBLQy5VUDpcblx0XHRcdFx0XHR0aGlzLnZpc2l0Um93cyhcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0XHRcdFx0cmVzID0gbjtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHsgc3RhcnQ6IG5vZGUsIHJldmVyc2U6IHRydWUsIGluY2x1ZGVTZWxmOiBmYWxzZSB9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRvd25cIjpcblx0XHRcdFx0Y2FzZSBLQy5ET1dOOlxuXHRcdFx0XHRcdHRoaXMudmlzaXRSb3dzKFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24obikge1xuXHRcdFx0XHRcdFx0XHRyZXMgPSBuO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0eyBzdGFydDogbm9kZSwgaW5jbHVkZVNlbGY6IGZhbHNlIH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRoaXMudHJlZS53YXJuKFwiVW5rbm93biByZWxhdGlvbiAnXCIgKyB3aGVyZSArIFwiJy5cIik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cdFx0Ly8gVE9ETzogZnJvbURpY3Rcblx0XHQvKipcblx0XHQgKiBHZW5lcmF0ZSBJTlBVVCBlbGVtZW50cyB0aGF0IGNhbiBiZSBzdWJtaXR0ZWQgd2l0aCBodG1sIGZvcm1zLlxuXHRcdCAqXG5cdFx0ICogSW4gc2VsZWN0TW9kZSAzIG9ubHkgdGhlIHRvcG1vc3Qgc2VsZWN0ZWQgbm9kZXMgYXJlIGNvbnNpZGVyZWQsIHVubGVzc1xuXHRcdCAqIGBvcHRzLnN0b3BPblBhcmVudHM6IGZhbHNlYCBpcyBwYXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIEdlbmVyYXRlIGlucHV0IGVsZW1lbnRzIGZvciBhY3RpdmUgYW5kIHNlbGVjdGVkIG5vZGVzXG5cdFx0ICogdHJlZS5nZW5lcmF0ZUZvcm1FbGVtZW50cygpO1xuXHRcdCAqIC8vIEdlbmVyYXRlIGlucHV0IGVsZW1lbnRzIHNlbGVjdGVkIG5vZGVzLCB1c2luZyBhIGN1c3RvbSBgbmFtZWAgYXR0cmlidXRlXG5cdFx0ICogdHJlZS5nZW5lcmF0ZUZvcm1FbGVtZW50cyhcImN1c3Rfc2VsXCIsIGZhbHNlKTtcblx0XHQgKiAvLyBHZW5lcmF0ZSBpbnB1dCBlbGVtZW50cyB1c2luZyBhIGN1c3RvbSBmaWx0ZXJcblx0XHQgKiB0cmVlLmdlbmVyYXRlRm9ybUVsZW1lbnRzKHRydWUsIHRydWUsIHsgZmlsdGVyOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0ICogICAgIHJldHVybiBub2RlLmlzU2VsZWN0ZWQoKSAmJiBub2RlLmRhdGEueWVzO1xuXHRcdCAqIH19KTtcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbiB8IHN0cmluZ30gW3NlbGVjdGVkPXRydWVdIFBhc3MgZmFsc2UgdG8gZGlzYWJsZSwgcGFzcyBhIHN0cmluZyB0byBvdmVycmlkZSB0aGUgZmllbGQgbmFtZSAoZGVmYXVsdDogJ2Z0X0lEW10nKVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbiB8IHN0cmluZ30gW2FjdGl2ZT10cnVlXSBQYXNzIGZhbHNlIHRvIGRpc2FibGUsIHBhc3MgYSBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIGZpZWxkIG5hbWUgKGRlZmF1bHQ6ICdmdF9JRF9hY3RpdmUnKVxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gZGVmYXVsdCB7IGZpbHRlcjogbnVsbCwgc3RvcE9uUGFyZW50czogdHJ1ZSB9XG5cdFx0ICovXG5cdFx0Z2VuZXJhdGVGb3JtRWxlbWVudHM6IGZ1bmN0aW9uKHNlbGVjdGVkLCBhY3RpdmUsIG9wdHMpIHtcblx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdFx0XHR2YXIgbm9kZUxpc3QsXG5cdFx0XHRcdHNlbGVjdGVkTmFtZSA9XG5cdFx0XHRcdFx0dHlwZW9mIHNlbGVjdGVkID09PSBcInN0cmluZ1wiXG5cdFx0XHRcdFx0XHQ/IHNlbGVjdGVkXG5cdFx0XHRcdFx0XHQ6IFwiZnRfXCIgKyB0aGlzLl9pZCArIFwiW11cIixcblx0XHRcdFx0YWN0aXZlTmFtZSA9XG5cdFx0XHRcdFx0dHlwZW9mIGFjdGl2ZSA9PT0gXCJzdHJpbmdcIlxuXHRcdFx0XHRcdFx0PyBhY3RpdmVcblx0XHRcdFx0XHRcdDogXCJmdF9cIiArIHRoaXMuX2lkICsgXCJfYWN0aXZlXCIsXG5cdFx0XHRcdGlkID0gXCJmYW5jeXRyZWVfcmVzdWx0X1wiICsgdGhpcy5faWQsXG5cdFx0XHRcdCRyZXN1bHQgPSAkKFwiI1wiICsgaWQpLFxuXHRcdFx0XHRzdG9wT25QYXJlbnRzID1cblx0XHRcdFx0XHR0aGlzLm9wdGlvbnMuc2VsZWN0TW9kZSA9PT0gMyAmJlxuXHRcdFx0XHRcdG9wdHMuc3RvcE9uUGFyZW50cyAhPT0gZmFsc2U7XG5cblx0XHRcdGlmICgkcmVzdWx0Lmxlbmd0aCkge1xuXHRcdFx0XHQkcmVzdWx0LmVtcHR5KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkcmVzdWx0ID0gJChcIjxkaXY+XCIsIHtcblx0XHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmhpZGUoKVxuXHRcdFx0XHRcdC5pbnNlcnRBZnRlcih0aGlzLiRjb250YWluZXIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFjdGl2ZSAhPT0gZmFsc2UgJiYgdGhpcy5hY3RpdmVOb2RlKSB7XG5cdFx0XHRcdCRyZXN1bHQuYXBwZW5kKFxuXHRcdFx0XHRcdCQoXCI8aW5wdXQ+XCIsIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwicmFkaW9cIixcblx0XHRcdFx0XHRcdG5hbWU6IGFjdGl2ZU5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdGhpcy5hY3RpdmVOb2RlLmtleSxcblx0XHRcdFx0XHRcdGNoZWNrZWQ6IHRydWUsXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIF9hcHBlbmRlcihub2RlKSB7XG5cdFx0XHRcdCRyZXN1bHQuYXBwZW5kKFxuXHRcdFx0XHRcdCQoXCI8aW5wdXQ+XCIsIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiY2hlY2tib3hcIixcblx0XHRcdFx0XHRcdG5hbWU6IHNlbGVjdGVkTmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiBub2RlLmtleSxcblx0XHRcdFx0XHRcdGNoZWNrZWQ6IHRydWUsXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdGlmIChvcHRzLmZpbHRlcikge1xuXHRcdFx0XHR0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdFx0XHR2YXIgcmVzID0gb3B0cy5maWx0ZXIobm9kZSk7XG5cdFx0XHRcdFx0aWYgKHJlcyA9PT0gXCJza2lwXCIpIHtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChyZXMgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRfYXBwZW5kZXIobm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoc2VsZWN0ZWQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdG5vZGVMaXN0ID0gdGhpcy5nZXRTZWxlY3RlZE5vZGVzKHN0b3BPblBhcmVudHMpO1xuXHRcdFx0XHQkLmVhY2gobm9kZUxpc3QsIGZ1bmN0aW9uKGlkeCwgbm9kZSkge1xuXHRcdFx0XHRcdF9hcHBlbmRlcihub2RlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbm9kZSBvciBudWxsLlxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlfVxuXHRcdCAqL1xuXHRcdGdldEFjdGl2ZU5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWN0aXZlTm9kZTtcblx0XHR9LFxuXHRcdC8qKiBSZXR1cm4gdGhlIGZpcnN0IHRvcCBsZXZlbCBub2RlIGlmIGFueSAobm90IHRoZSBpbnZpc2libGUgcm9vdCBub2RlKS5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZSB8IG51bGx9XG5cdFx0ICovXG5cdFx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yb290Tm9kZS5nZXRGaXJzdENoaWxkKCk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gbm9kZSB0aGF0IGhhcyBrZXlib2FyZCBmb2N1cyBvciBudWxsLlxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlfVxuXHRcdCAqL1xuXHRcdGdldEZvY3VzTm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mb2N1c05vZGU7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gY3VycmVudCBvcHRpb24gdmFsdWUuXG5cdFx0ICogKE5vdGU6IHRoaXMgaXMgdGhlIHByZWZlcnJlZCB2YXJpYW50IG9mIGAkKCkuZmFuY3l0cmVlKFwib3B0aW9uXCIsIFwiS0VZXCIpYClcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9wdGlvbiBuYW1lIChtYXkgY29udGFpbiAnLicpXG5cdFx0ICogQHJldHVybnMge2FueX1cblx0XHQgKi9cblx0XHRnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLndpZGdldC5vcHRpb24ob3B0aW9uTmFtZSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gbm9kZSB3aXRoIGEgZ2l2ZW4ga2V5IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGtleVxuXHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gW3NlYXJjaFJvb3RdIG9ubHkgc2VhcmNoIGJlbG93IHRoaXMgbm9kZVxuXHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWVOb2RlIHwgbnVsbH1cblx0XHQgKi9cblx0XHRnZXROb2RlQnlLZXk6IGZ1bmN0aW9uKGtleSwgc2VhcmNoUm9vdCkge1xuXHRcdFx0Ly8gU2VhcmNoIHRoZSBET00gYnkgZWxlbWVudCBJRCAoYXNzdW1pbmcgdGhpcyBpcyBmYXN0ZXIgdGhhbiB0cmF2ZXJzaW5nIGFsbCBub2RlcykuXG5cdFx0XHR2YXIgZWwsIG1hdGNoO1xuXHRcdFx0Ly8gVE9ETzogdXNlIHRyZWUua2V5TWFwIGlmIGF2YWlsYWJsZVxuXHRcdFx0Ly8gVE9ETzogY2hlY2sgb3B0cy5nZW5lcmF0ZUlkcyA9PT0gdHJ1ZVxuXHRcdFx0aWYgKCFzZWFyY2hSb290KSB7XG5cdFx0XHRcdGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5vcHRpb25zLmlkUHJlZml4ICsga2V5KTtcblx0XHRcdFx0aWYgKGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsLmZ0bm9kZSA/IGVsLmZ0bm9kZSA6IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE5vdCBmb3VuZCBpbiB0aGUgRE9NLCBidXQgc3RpbGwgbWF5IGJlIGluIGFuIHVucmVuZGVyZWQgcGFydCBvZiB0cmVlXG5cdFx0XHRzZWFyY2hSb290ID0gc2VhcmNoUm9vdCB8fCB0aGlzLnJvb3ROb2RlO1xuXHRcdFx0bWF0Y2ggPSBudWxsO1xuXHRcdFx0c2VhcmNoUm9vdC52aXNpdChmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdGlmIChub2RlLmtleSA9PT0ga2V5KSB7XG5cdFx0XHRcdFx0bWF0Y2ggPSBub2RlO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gU3RvcCBpdGVyYXRpb25cblx0XHRcdFx0fVxuXHRcdFx0fSwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRoZSBpbnZpc2libGUgc3lzdGVtIHJvb3Qgbm9kZS5cblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX1cblx0XHQgKi9cblx0XHRnZXRSb290Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yb290Tm9kZTtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBhbiBhcnJheSBvZiBzZWxlY3RlZCBub2Rlcy5cblx0XHQgKlxuXHRcdCAqIE5vdGU6IHlvdSBjYW5ub3Qgc2VuZCB0aGlzIHJlc3VsdCB2aWEgQWpheCBkaXJlY3RseS4gSW5zdGVhZCB0aGVcblx0XHQgKiBub2RlIG9iamVjdCBuZWVkIHRvIGJlIGNvbnZlcnRlZCB0byBwbGFpbiBvYmplY3RzLCBmb3IgZXhhbXBsZVxuXHRcdCAqIGJ5IHVzaW5nIGAkLm1hcCgpYCBhbmQgYG5vZGUudG9EaWN0KClgLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3N0b3BPblBhcmVudHM9ZmFsc2VdIG9ubHkgcmV0dXJuIHRoZSB0b3Btb3N0IHNlbGVjdGVkXG5cdFx0ICogICAgIG5vZGUgKHVzZWZ1bCB3aXRoIHNlbGVjdE1vZGUgMylcblx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZVtdfVxuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGVkTm9kZXM6IGZ1bmN0aW9uKHN0b3BPblBhcmVudHMpIHtcblx0XHRcdHJldHVybiB0aGlzLnJvb3ROb2RlLmdldFNlbGVjdGVkTm9kZXMoc3RvcE9uUGFyZW50cyk7XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgdGhlIHRyZWUgY29udHJvbCBoYXMga2V5Ym9hcmQgZm9jdXNcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKi9cblx0XHRoYXNGb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gISF0aGlzLl9oYXNGb2N1cztcblx0XHR9LFxuXHRcdC8qKiBXcml0ZSB0byBicm93c2VyIGNvbnNvbGUgaWYgZGVidWdMZXZlbCA+PSAzIChwcmVwZW5kaW5nIHRyZWUgbmFtZSlcblx0XHQgKiBAcGFyYW0geyp9IG1zZyBzdHJpbmcgb3Igb2JqZWN0IG9yIGFycmF5IG9mIHN1Y2hcblx0XHQgKi9cblx0XHRpbmZvOiBmdW5jdGlvbihtc2cpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZGVidWdMZXZlbCA+PSAzKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCB0aGlzLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHRjb25zb2xlQXBwbHkoXCJpbmZvXCIsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiogUmV0dXJuIHRydWUgaWYgYW55IG5vZGUgaXMgY3VycmVudGx5IGJlZWluZyBsb2FkZWQsIGkuZS4gYSBBamF4IHJlcXVlc3QgaXMgcGVuZGluZy5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHQgKiBAc2luY2UgMi4zMlxuXHRcdCAqL1xuXHRcdGlzTG9hZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gZmFsc2U7XG5cblx0XHRcdHRoaXMucm9vdE5vZGUudmlzaXQoZnVuY3Rpb24obikge1xuXHRcdFx0XHQvLyBhbHNvIHZpc2l0IHJvb3ROb2RlXG5cdFx0XHRcdGlmIChuLl9pc0xvYWRpbmcgfHwgbi5fcmVxdWVzdElkKSB7XG5cdFx0XHRcdFx0cmVzID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRydWUpO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXHRcdC8qXG5cdFx0VE9ETzogaXNJbml0aWFsaXppbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICggdGhpcy5waGFzZT09XCJpbml0XCIgfHwgdGhpcy5waGFzZT09XCJwb3N0SW5pdFwiICk7XG5cdFx0fSxcblx0XHRUT0RPOiBpc1JlbG9hZGluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzLnBoYXNlPT1cImluaXRcIiB8fCB0aGlzLnBoYXNlPT1cInBvc3RJbml0XCIgKSAmJiB0aGlzLm9wdGlvbnMucGVyc2lzdCAmJiB0aGlzLnBlcnNpc3RlbmNlLmNvb2tpZXNGb3VuZDtcblx0XHR9LFxuXHRcdFRPRE86IGlzVXNlckV2ZW50OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAoIHRoaXMucGhhc2U9PVwidXNlckV2ZW50XCIgKTtcblx0XHR9LFxuXHRcdCovXG5cblx0XHQvKipcblx0XHQgKiBNYWtlIHN1cmUgdGhhdCBhIG5vZGUgd2l0aCBhIGdpdmVuIElEIGlzIGxvYWRlZCwgYnkgdHJhdmVyc2luZyAtIGFuZFxuXHRcdCAqIGxvYWRpbmcgLSBpdHMgcGFyZW50cy4gVGhpcyBtZXRob2QgaXMgbWVhbnQgZm9yIGxhenkgaGllcmFyY2hpZXMuXG5cdFx0ICogQSBjYWxsYmFjayBpcyBleGVjdXRlZCBmb3IgZXZlcnkgbm9kZSBhcyB3ZSBnby5cblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIC8vIFJlc29sdmUgdXNpbmcgbm9kZS5rZXk6XG5cdFx0ICogdHJlZS5sb2FkS2V5UGF0aChcIi9fMy9fMjMvXzI2L18yN1wiLCBmdW5jdGlvbihub2RlLCBzdGF0dXMpe1xuXHRcdCAqICAgaWYoc3RhdHVzID09PSBcImxvYWRlZFwiKSB7XG5cdFx0ICogICAgIGNvbnNvbGUubG9nKFwibG9hZGVkIGludGVybWVkaWF0ZSBub2RlIFwiICsgbm9kZSk7XG5cdFx0ICogICB9ZWxzZSBpZihzdGF0dXMgPT09IFwib2tcIikge1xuXHRcdCAqICAgICBub2RlLmFjdGl2YXRlKCk7XG5cdFx0ICogICB9XG5cdFx0ICogfSk7XG5cdFx0ICogLy8gVXNlIGRlZmVycmVkIHByb21pc2U6XG5cdFx0ICogdHJlZS5sb2FkS2V5UGF0aChcIi9fMy9fMjMvXzI2L18yN1wiKS5wcm9ncmVzcyhmdW5jdGlvbihkYXRhKXtcblx0XHQgKiAgIGlmKGRhdGEuc3RhdHVzID09PSBcImxvYWRlZFwiKSB7XG5cdFx0ICogICAgIGNvbnNvbGUubG9nKFwibG9hZGVkIGludGVybWVkaWF0ZSBub2RlIFwiICsgZGF0YS5ub2RlKTtcblx0XHQgKiAgIH1lbHNlIGlmKGRhdGEuc3RhdHVzID09PSBcIm9rXCIpIHtcblx0XHQgKiAgICAgbm9kZS5hY3RpdmF0ZSgpO1xuXHRcdCAqICAgfVxuXHRcdCAqIH0pLmRvbmUoZnVuY3Rpb24oKXtcblx0XHQgKiAgICAuLi5cblx0XHQgKiB9KTtcblx0XHQgKiAvLyBDdXN0b20gcGF0aCBzZWdtZW50IHJlc29sdmVyOlxuXHRcdCAqIHRyZWUubG9hZEtleVBhdGgoXCIvMzIxLzQzMS8yMS8yXCIsIHtcblx0XHQgKiAgIG1hdGNoS2V5OiBmdW5jdGlvbihub2RlLCBrZXkpe1xuXHRcdCAqICAgICByZXR1cm4gbm9kZS5kYXRhLnJlZktleSA9PT0ga2V5O1xuXHRcdCAqICAgfSxcblx0XHQgKiAgIGNhbGxiYWNrOiBmdW5jdGlvbihub2RlLCBzdGF0dXMpe1xuXHRcdCAqICAgICBpZihzdGF0dXMgPT09IFwibG9hZGVkXCIpIHtcblx0XHQgKiAgICAgICBjb25zb2xlLmxvZyhcImxvYWRlZCBpbnRlcm1lZGlhdGUgbm9kZSBcIiArIG5vZGUpO1xuXHRcdCAqICAgICB9ZWxzZSBpZihzdGF0dXMgPT09IFwib2tcIikge1xuXHRcdCAqICAgICAgIG5vZGUuYWN0aXZhdGUoKTtcblx0XHQgKiAgICAgfVxuXHRcdCAqICAgfVxuXHRcdCAqIH0pO1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGtleVBhdGhMaXN0IG9uZSBvciBtb3JlIGtleSBwYXRocyAoZS5nLiAnLzMvMl8xLzcnKVxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb24gfCBvYmplY3R9IG9wdHNPckNhbGxiYWNrIGNhbGxiYWNrKG5vZGUsIHN0YXR1cykgaXMgY2FsbGVkIGZvciBldmVyeSB2aXNpdGVkIG5vZGUgKCdsb2FkaW5nJywgJ2xvYWRlZCcsICdvaycsICdlcnJvcicpLlxuXHRcdCAqICAgICBQYXNzIGFuIG9iamVjdCB0byBkZWZpbmUgY3VzdG9tIGtleSBtYXRjaGVycyBmb3IgdGhlIHBhdGggc2VnbWVudHM6IHtjYWxsYmFjazogZnVuY3Rpb24sIG1hdGNoS2V5OiBmdW5jdGlvbn0uXG5cdFx0ICogQHJldHVybnMgeyQuUHJvbWlzZX1cblx0XHQgKi9cblx0XHRsb2FkS2V5UGF0aDogZnVuY3Rpb24oa2V5UGF0aExpc3QsIG9wdHNPckNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgY2FsbGJhY2ssXG5cdFx0XHRcdGksXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRkZmQgPSBuZXcgJC5EZWZlcnJlZCgpLFxuXHRcdFx0XHRwYXJlbnQgPSB0aGlzLmdldFJvb3ROb2RlKCksXG5cdFx0XHRcdHNlcCA9IHRoaXMub3B0aW9ucy5rZXlQYXRoU2VwYXJhdG9yLFxuXHRcdFx0XHRwYXRoU2VnTGlzdCA9IFtdLFxuXHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIG9wdHNPckNhbGxiYWNrKTtcblxuXHRcdFx0Ly8gUHJlcGFyZSBvcHRpb25zXG5cdFx0XHRpZiAodHlwZW9mIG9wdHNPckNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBvcHRzT3JDYWxsYmFjaztcblx0XHRcdH0gZWxzZSBpZiAob3B0c09yQ2FsbGJhY2sgJiYgb3B0c09yQ2FsbGJhY2suY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBvcHRzT3JDYWxsYmFjay5jYWxsYmFjaztcblx0XHRcdH1cblx0XHRcdG9wdHMuY2FsbGJhY2sgPSBmdW5jdGlvbihjdHgsIG5vZGUsIHN0YXR1cykge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKGN0eCwgbm9kZSwgc3RhdHVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZmQubm90aWZ5V2l0aChjdHgsIFt7IG5vZGU6IG5vZGUsIHN0YXR1czogc3RhdHVzIH1dKTtcblx0XHRcdH07XG5cdFx0XHRpZiAob3B0cy5tYXRjaEtleSA9PSBudWxsKSB7XG5cdFx0XHRcdG9wdHMubWF0Y2hLZXkgPSBmdW5jdGlvbihub2RlLCBrZXkpIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5rZXkgPT09IGtleTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIENvbnZlcnQgYXJyYXkgb2YgcGF0aCBzdHJpbmdzIHRvIGFycmF5IG9mIHNlZ21lbnQgYXJyYXlzXG5cdFx0XHRpZiAoISQuaXNBcnJheShrZXlQYXRoTGlzdCkpIHtcblx0XHRcdFx0a2V5UGF0aExpc3QgPSBba2V5UGF0aExpc3RdO1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGtleVBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHBhdGggPSBrZXlQYXRoTGlzdFtpXTtcblx0XHRcdFx0Ly8gc3RyaXAgbGVhZGluZyBzbGFzaFxuXHRcdFx0XHRpZiAocGF0aC5jaGFyQXQoMCkgPT09IHNlcCkge1xuXHRcdFx0XHRcdHBhdGggPSBwYXRoLnN1YnN0cigxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBzZWdMaXN0TWFwW3BhdGhdID0geyBwYXJlbnQ6IHBhcmVudCwgc2VnTGlzdDogcGF0aC5zcGxpdChzZXApIH07XG5cdFx0XHRcdHBhdGhTZWdMaXN0LnB1c2gocGF0aC5zcGxpdChzZXApKTtcblx0XHRcdFx0Ly8gdGFyZ2V0TGlzdC5wdXNoKHsgcGFyZW50OiBwYXJlbnQsIHNlZ0xpc3Q6IHBhdGguc3BsaXQoc2VwKS8qICwgcGF0aDogcGF0aCovfSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaGUgdGltZW91dCBmb3JjZXMgYXN5bmMgYmVoYXZpb3IgYWx3YXlzIChldmVuIGlmIG5vZGVzIGFyZSBhbGwgbG9hZGVkKVxuXHRcdFx0Ly8gVGhpcyB3YXkgYSBwb3RlbnRpYWwgcHJvZ3Jlc3MoKSBldmVudCB3aWxsIGZpcmUuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLl9sb2FkS2V5UGF0aEltcGwoZGZkLCBvcHRzLCBwYXJlbnQsIHBhdGhTZWdMaXN0KS5kb25lKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGZkLnJlc29sdmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cdFx0XHR9LCAwKTtcblx0XHRcdHJldHVybiBkZmQucHJvbWlzZSgpO1xuXHRcdH0sXG5cdFx0Lypcblx0XHQgKiBSZXNvbHZlIGEgbGlzdCBvZiBwYXRocywgcmVsYXRpdmUgdG8gb25lIHBhcmVudCBub2RlLlxuXHRcdCAqL1xuXHRcdF9sb2FkS2V5UGF0aEltcGw6IGZ1bmN0aW9uKGRmZCwgb3B0cywgcGFyZW50LCBwYXRoU2VnTGlzdCkge1xuXHRcdFx0dmFyIGRlZmVycmVkTGlzdCxcblx0XHRcdFx0aSxcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRub2RlLFxuXHRcdFx0XHRub2RlS2V5LFxuXHRcdFx0XHRyZW1haW4sXG5cdFx0XHRcdHJlbWFpbk1hcCxcblx0XHRcdFx0dG1wUGFyZW50LFxuXHRcdFx0XHRzZWdMaXN0LFxuXHRcdFx0XHRzdWJEZmQsXG5cdFx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRmdW5jdGlvbiBfX2ZpbmRDaGlsZChwYXJlbnQsIGtleSkge1xuXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIl9fZmluZENoaWxkXCIsIGtleSwgcGFyZW50KTtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0bCxcblx0XHRcdFx0XHRjbCA9IHBhcmVudC5jaGlsZHJlbjtcblxuXHRcdFx0XHRpZiAoY2wpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gY2wubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAob3B0cy5tYXRjaEtleShjbFtpXSwga2V5KSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY2xbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcIl9sb2FkS2V5UGF0aEltcGwsIHBhcmVudD1cIiwgcGFyZW50LCBcIiwgcGF0aFNlZ0xpc3Q9XCIsIHBhdGhTZWdMaXN0KTtcblxuXHRcdFx0Ly8gUGFzcyAxOlxuXHRcdFx0Ly8gSGFuZGxlIGFsbCBwYXRoIHNlZ21lbnRzIGZvciBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGxvYWRlZC5cblx0XHRcdC8vIENvbGxlY3QgZGlzdGluY3QgdG9wLW1vc3QgbGF6eSBub2RlcyBpbiBhIG1hcC5cblx0XHRcdC8vIE5vdGUgdGhhdCB3ZSBjYW4gdXNlIG5vZGUua2V5IHRvIGRlLWR1cGUgZW50cmllcywgZXZlbiBpZiBhIGN1c3RvbSBtYXRjaGVyIHdvdWxkXG5cdFx0XHQvLyBsb29rIGZvciBvdGhlciBub2RlIGF0dHJpYnV0ZXMuXG5cdFx0XHQvLyBtYXBbbm9kZS5rZXldID0+IHtub2RlOiBub2RlLCBwYXRoTGlzdDogW2xpc3Qgb2YgcmVtYWluaW5nIHJlc3QtcGF0aHNdfVxuXHRcdFx0cmVtYWluTWFwID0ge307XG5cblx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXRoU2VnTGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzZWdMaXN0ID0gcGF0aFNlZ0xpc3RbaV07XG5cdFx0XHRcdC8vIHRhcmdldCA9IHRhcmdldExpc3RbaV07XG5cblx0XHRcdFx0Ly8gVHJhdmVyc2UgYW5kIHBvcCBwYXRoIHNlZ21lbnRzIChpLmUuIGtleXMpLCB1bnRpbCB3ZSBoaXQgYSBsYXp5LCB1bmxvYWRlZCBub2RlXG5cdFx0XHRcdHRtcFBhcmVudCA9IHBhcmVudDtcblx0XHRcdFx0d2hpbGUgKHNlZ0xpc3QubGVuZ3RoKSB7XG5cdFx0XHRcdFx0a2V5ID0gc2VnTGlzdC5zaGlmdCgpO1xuXHRcdFx0XHRcdG5vZGUgPSBfX2ZpbmRDaGlsZCh0bXBQYXJlbnQsIGtleSk7XG5cdFx0XHRcdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRcdFx0XHR0aGlzLndhcm4oXG5cdFx0XHRcdFx0XHRcdFwibG9hZEtleVBhdGg6IGtleSBub3QgZm91bmQ6IFwiICtcblx0XHRcdFx0XHRcdFx0XHRrZXkgK1xuXHRcdFx0XHRcdFx0XHRcdFwiIChwYXJlbnQ6IFwiICtcblx0XHRcdFx0XHRcdFx0XHR0bXBQYXJlbnQgK1xuXHRcdFx0XHRcdFx0XHRcdFwiKVwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0b3B0cy5jYWxsYmFjayh0aGlzLCBrZXksIFwiZXJyb3JcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNlZ0xpc3QubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRvcHRzLmNhbGxiYWNrKHRoaXMsIG5vZGUsIFwib2tcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFub2RlLmxhenkgfHwgbm9kZS5oYXNDaGlsZHJlbigpICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdG9wdHMuY2FsbGJhY2sodGhpcywgbm9kZSwgXCJsb2FkZWRcIik7XG5cdFx0XHRcdFx0XHR0bXBQYXJlbnQgPSBub2RlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRvcHRzLmNhbGxiYWNrKHRoaXMsIG5vZGUsIFwibG9hZGVkXCIpO1xuXHRcdFx0XHRcdFx0a2V5ID0gbm9kZS5rZXk7IC8vdGFyZ2V0LnNlZ0xpc3Quam9pbihzZXApO1xuXHRcdFx0XHRcdFx0aWYgKHJlbWFpbk1hcFtrZXldKSB7XG5cdFx0XHRcdFx0XHRcdHJlbWFpbk1hcFtrZXldLnBhdGhTZWdMaXN0LnB1c2goc2VnTGlzdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZW1haW5NYXBba2V5XSA9IHtcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnQ6IG5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0cGF0aFNlZ0xpc3Q6IFtzZWdMaXN0XSxcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJfbG9hZEtleVBhdGhJbXBsIEFGVEVSIHBhc3MgMSwgcmVtYWluTWFwPVwiLCByZW1haW5NYXApO1xuXG5cdFx0XHQvLyBOb3cgbG9hZCBhbGwgbGF6eSBub2RlcyBhbmQgY29udGludWUgaXRlcmF0aW9uIGZvciByZW1haW5pbmcgcGF0aHNcblx0XHRcdGRlZmVycmVkTGlzdCA9IFtdO1xuXG5cdFx0XHQvLyBBdm9pZCBqc2hpbnQgd2FybmluZyAnRG9uJ3QgbWFrZSBmdW5jdGlvbnMgd2l0aGluIGEgbG9vcC4nOlxuXHRcdFx0ZnVuY3Rpb24gX19sYXp5bG9hZChkZmQsIHBhcmVudCwgcGF0aFNlZ0xpc3QpIHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJfX2xhenlsb2FkXCIsIHBhcmVudCwgXCJwYXRoU2VnTGlzdD1cIiwgcGF0aFNlZ0xpc3QpO1xuXHRcdFx0XHRvcHRzLmNhbGxiYWNrKHNlbGYsIHBhcmVudCwgXCJsb2FkaW5nXCIpO1xuXHRcdFx0XHRwYXJlbnRcblx0XHRcdFx0XHQubG9hZCgpXG5cdFx0XHRcdFx0LmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9sb2FkS2V5UGF0aEltcGxcblx0XHRcdFx0XHRcdFx0LmNhbGwoc2VsZiwgZGZkLCBvcHRzLCBwYXJlbnQsIHBhdGhTZWdMaXN0KVxuXHRcdFx0XHRcdFx0XHQuYWx3YXlzKF9tYWtlUmVzb2x2ZUZ1bmMoZGZkLCBzZWxmKSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuZmFpbChmdW5jdGlvbihlcnJNc2cpIHtcblx0XHRcdFx0XHRcdHNlbGYud2FybihcImxvYWRLZXlQYXRoOiBlcnJvciBsb2FkaW5nIGxhenkgXCIgKyBwYXJlbnQpO1xuXHRcdFx0XHRcdFx0b3B0cy5jYWxsYmFjayhzZWxmLCBub2RlLCBcImVycm9yXCIpO1xuXHRcdFx0XHRcdFx0ZGZkLnJlamVjdFdpdGgoc2VsZik7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyByZW1haW5NYXAgY29udGFpbnMgcGFyZW50IG5vZGVzLCBlYWNoIHdpdGggYSBsaXN0IG9mIHJlbGF0aXZlIHN1Yi1wYXRocy5cblx0XHRcdC8vIFdlIHN0YXJ0IGxvYWRpbmcgYWxsIG9mIHRoZW0gbm93LCBhbmQgcGFzcyB0aGUgdGhlIGxpc3QgdG8gZWFjaCBsb2FkZXIuXG5cdFx0XHRmb3IgKG5vZGVLZXkgaW4gcmVtYWluTWFwKSB7XG5cdFx0XHRcdGlmIChyZW1haW5NYXAuaGFzT3duUHJvcGVydHkobm9kZUtleSkpIHtcblx0XHRcdFx0XHRyZW1haW4gPSByZW1haW5NYXBbbm9kZUtleV07XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coXCJmb3IoKTogcmVtYWluPVwiLCByZW1haW4sIFwicmVtYWluTWFwPVwiLCByZW1haW5NYXApO1xuXHRcdFx0XHRcdC8vIGtleSA9IHJlbWFpbi5zZWdMaXN0LnNoaWZ0KCk7XG5cdFx0XHRcdFx0Ly8gbm9kZSA9IF9fZmluZENoaWxkKHJlbWFpbi5wYXJlbnQsIGtleSk7XG5cdFx0XHRcdFx0Ly8gaWYgKG5vZGUgPT0gbnVsbCkgeyAgLy8gIzU3NlxuXHRcdFx0XHRcdC8vIFx0Ly8gSXNzdWUgIzU3NiwgcmVmYWN0b3JlZCBmb3IgdjIuMjc6XG5cdFx0XHRcdFx0Ly8gXHQvLyBUaGUgcm9vdCBjYXVzZSB3YXMsIHRoYXQgc29tZXRpbWVzIHRoZSB3cm9uZyBwYXJlbnQgd2FzIHVzZWQgaGVyZVxuXHRcdFx0XHRcdC8vIFx0Ly8gdG8gZmluZCB0aGUgbmV4dCBzZWdtZW50LlxuXHRcdFx0XHRcdC8vIFx0Ly8gRmFsbGluZyBiYWNrIHRvIGdldE5vZGVCeUtleSgpIHdhcyBhIGhhY2sgdGhhdCBubyBsb25nZXIgd29ya3MgaWYgYSBjdXN0b21cblx0XHRcdFx0XHQvLyBcdC8vIG1hdGNoZXIgaXMgdXNlZCwgYmVjYXVzZSB3ZSBjYW5ub3QgYXNzdW1lIHRoYXQgYSBzaW5nbGUgc2VnbWVudC1rZXkgaXMgdW5pcXVlXG5cdFx0XHRcdFx0Ly8gXHQvLyB0aHJvdWdob3V0IHRoZSB0cmVlLlxuXHRcdFx0XHRcdC8vIFx0c2VsZi5lcnJvcihcImxvYWRLZXlQYXRoOiBlcnJvciBsb2FkaW5nIGNoaWxkIGJ5IGtleSAnXCIgKyBrZXkgKyBcIicgKHBhcmVudDogXCIgKyB0YXJnZXQucGFyZW50ICsgXCIpXCIsIHRhcmdldCk7XG5cdFx0XHRcdFx0Ly8gXHQvLyBcdG5vZGUgPSBzZWxmLmdldE5vZGVCeUtleShrZXkpO1xuXHRcdFx0XHRcdC8vIFx0Y29udGludWU7XG5cdFx0XHRcdFx0Ly8gfVxuXHRcdFx0XHRcdHN1YkRmZCA9IG5ldyAkLkRlZmVycmVkKCk7XG5cdFx0XHRcdFx0ZGVmZXJyZWRMaXN0LnB1c2goc3ViRGZkKTtcblx0XHRcdFx0XHRfX2xhenlsb2FkKHN1YkRmZCwgcmVtYWluLnBhcmVudCwgcmVtYWluLnBhdGhTZWdMaXN0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gUmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkLCB3aGVuIEFMTCBwYXRocyB3ZXJlIGxvYWRlZFxuXHRcdFx0cmV0dXJuICQud2hlbi5hcHBseSgkLCBkZWZlcnJlZExpc3QpLnByb21pc2UoKTtcblx0XHR9LFxuXHRcdC8qKiBSZS1maXJlIGJlZm9yZUFjdGl2YXRlLCBhY3RpdmF0ZSwgYW5kIChvcHRpb25hbCkgZm9jdXMgZXZlbnRzLlxuXHRcdCAqIENhbGxpbmcgdGhpcyBtZXRob2QgaW4gdGhlIGBpbml0YCBldmVudCwgd2lsbCBhY3RpdmF0ZSB0aGUgbm9kZSB0aGF0XG5cdFx0ICogd2FzIG1hcmtlZCAnYWN0aXZlJyBpbiB0aGUgc291cmNlIGRhdGEsIGFuZCBvcHRpb25hbGx5IHNldCB0aGUga2V5Ym9hcmRcblx0XHQgKiBmb2N1cy5cblx0XHQgKiBAcGFyYW0gW3NldEZvY3VzPWZhbHNlXVxuXHRcdCAqL1xuXHRcdHJlYWN0aXZhdGU6IGZ1bmN0aW9uKHNldEZvY3VzKSB7XG5cdFx0XHR2YXIgcmVzLFxuXHRcdFx0XHRub2RlID0gdGhpcy5hY3RpdmVOb2RlO1xuXG5cdFx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdFx0cmV0dXJuIF9nZXRSZXNvbHZlZFByb21pc2UoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuYWN0aXZlTm9kZSA9IG51bGw7IC8vIEZvcmNlIHJlLWFjdGl2YXRpbmdcblx0XHRcdHJlcyA9IG5vZGUuc2V0QWN0aXZlKHRydWUsIHsgbm9Gb2N1czogdHJ1ZSB9KTtcblx0XHRcdGlmIChzZXRGb2N1cykge1xuXHRcdFx0XHRub2RlLnNldEZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cdFx0LyoqIFJlbG9hZCB0cmVlIGZyb20gc291cmNlIGFuZCByZXR1cm4gYSBwcm9taXNlLlxuXHRcdCAqIEBwYXJhbSBbc291cmNlXSBvcHRpb25hbCBuZXcgc291cmNlIChkZWZhdWx0cyB0byBpbml0aWFsIHNvdXJjZSBkYXRhKVxuXHRcdCAqIEByZXR1cm5zIHskLlByb21pc2V9XG5cdFx0ICovXG5cdFx0cmVsb2FkOiBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdHRoaXMuX2NhbGxIb29rKFwidHJlZUNsZWFyXCIsIHRoaXMpO1xuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbGxIb29rKFwidHJlZUxvYWRcIiwgdGhpcywgc291cmNlKTtcblx0XHR9LFxuXHRcdC8qKlJlbmRlciB0cmVlIChpLmUuIGNyZWF0ZSBET00gZWxlbWVudHMgZm9yIGFsbCB0b3AtbGV2ZWwgbm9kZXMpLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSBjcmVhdGUgRE9NIGVsZW1udHMsIGV2ZW4gaWYgcGFyZW50IGlzIGNvbGxhcHNlZFxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZXA9ZmFsc2VdXG5cdFx0ICovXG5cdFx0cmVuZGVyOiBmdW5jdGlvbihmb3JjZSwgZGVlcCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucm9vdE5vZGUucmVuZGVyKGZvcmNlLCBkZWVwKTtcblx0XHR9LFxuXHRcdC8qKihEZSlzZWxlY3QgYWxsIG5vZGVzLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV1cblx0XHQgKiBAc2luY2UgMi4yOFxuXHRcdCAqL1xuXHRcdHNlbGVjdEFsbDogZnVuY3Rpb24oZmxhZykge1xuXHRcdFx0dGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRcdG5vZGUuc2V0U2VsZWN0ZWQoZmxhZyk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdC8vIFRPRE86IHNlbGVjdEtleTogZnVuY3Rpb24oa2V5LCBzZWxlY3QpXG5cdFx0Ly8gVE9ETzogc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKHN0b3BPblBhcmVudHMpXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhZz10cnVlXVxuXHRcdCAqL1xuXHRcdHNldEZvY3VzOiBmdW5jdGlvbihmbGFnKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FsbEhvb2soXCJ0cmVlU2V0Rm9jdXNcIiwgdGhpcywgZmxhZyk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBTZXQgY3VycmVudCBvcHRpb24gdmFsdWUuXG5cdFx0ICogKE5vdGU6IHRoaXMgaXMgdGhlIHByZWZlcnJlZCB2YXJpYW50IG9mIGAkKCkuZmFuY3l0cmVlKFwib3B0aW9uXCIsIFwiS0VZXCIsIFZBTFVFKWApXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgb3B0aW9uIG5hbWUgKG1heSBjb250YWluICcuJylcblx0XHQgKiBAcGFyYW0ge2FueX0gbmV3IHZhbHVlXG5cdFx0ICovXG5cdFx0c2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb25OYW1lLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMud2lkZ2V0Lm9wdGlvbihvcHRpb25OYW1lLCB2YWx1ZSk7XG5cdFx0fSxcblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYWxsIG5vZGVzIGFzIG5lc3RlZCBsaXN0IG9mIHtAbGluayBOb2RlRGF0YX0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlUm9vdD1mYWxzZV0gUmV0dXJucyB0aGUgaGlkZGVuIHN5c3RlbSByb290IG5vZGUgKGFuZCBpdHMgY2hpbGRyZW4pXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayhkaWN0LCBub2RlKSBpcyBjYWxsZWQgZm9yIGV2ZXJ5IG5vZGUsIGluIG9yZGVyIHRvIGFsbG93IG1vZGlmaWNhdGlvbnMuXG5cdFx0ICogICAgIFJldHVybiBgZmFsc2VgIHRvIGlnbm9yZSB0aGlzIG5vZGUgb3IgXCJza2lwXCIgdG8gaW5jbHVkZSB0aGlzIG5vZGUgd2l0aG91dCBpdHMgY2hpbGRyZW4uXG5cdFx0ICogQHJldHVybnMge0FycmF5IHwgb2JqZWN0fVxuXHRcdCAqIEBzZWUgRmFuY3l0cmVlTm9kZSN0b0RpY3Rcblx0XHQgKi9cblx0XHR0b0RpY3Q6IGZ1bmN0aW9uKGluY2x1ZGVSb290LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHJlcyA9IHRoaXMucm9vdE5vZGUudG9EaWN0KHRydWUsIGNhbGxiYWNrKTtcblx0XHRcdHJldHVybiBpbmNsdWRlUm9vdCA/IHJlcyA6IHJlcy5jaGlsZHJlbjtcblx0XHR9LFxuXHRcdC8qIEltcGxpY2l0bHkgY2FsbGVkIGZvciBzdHJpbmcgY29udmVyc2lvbnMuXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHQgKi9cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gXCJGYW5jeXRyZWVAXCIgKyB0aGlzLl9pZDtcblx0XHRcdC8vIHJldHVybiBcIjxGYW5jeXRyZWUoI1wiICsgdGhpcy5faWQgKyBcIik+XCI7XG5cdFx0fSxcblx0XHQvKiBfdHJpZ2dlciBhIHdpZGdldCBldmVudCB3aXRoIGFkZGl0aW9uYWwgbm9kZSBjdHguXG5cdFx0ICogQHNlZSBFdmVudERhdGFcblx0XHQgKi9cblx0XHRfdHJpZ2dlck5vZGVFdmVudDogZnVuY3Rpb24odHlwZSwgbm9kZSwgb3JpZ2luYWxFdmVudCwgZXh0cmEpIHtcblx0XHRcdC8vIHRoaXMuZGVidWcoXCJfdHJpZ2dlcihcIiArIHR5cGUgKyBcIik6ICdcIiArIGN0eC5ub2RlLnRpdGxlICsgXCInXCIsIGN0eCk7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fbWFrZUhvb2tDb250ZXh0KG5vZGUsIG9yaWdpbmFsRXZlbnQsIGV4dHJhKSxcblx0XHRcdFx0cmVzID0gdGhpcy53aWRnZXQuX3RyaWdnZXIodHlwZSwgb3JpZ2luYWxFdmVudCwgY3R4KTtcblx0XHRcdGlmIChyZXMgIT09IGZhbHNlICYmIGN0eC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gY3R4LnJlc3VsdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHQvKiBfdHJpZ2dlciBhIHdpZGdldCBldmVudCB3aXRoIGFkZGl0aW9uYWwgdHJlZSBkYXRhLiAqL1xuXHRcdF90cmlnZ2VyVHJlZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBvcmlnaW5hbEV2ZW50LCBleHRyYSkge1xuXHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcIl90cmlnZ2VyKFwiICsgdHlwZSArIFwiKVwiLCBjdHgpO1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuX21ha2VIb29rQ29udGV4dCh0aGlzLCBvcmlnaW5hbEV2ZW50LCBleHRyYSksXG5cdFx0XHRcdHJlcyA9IHRoaXMud2lkZ2V0Ll90cmlnZ2VyKHR5cGUsIG9yaWdpbmFsRXZlbnQsIGN0eCk7XG5cblx0XHRcdGlmIChyZXMgIT09IGZhbHNlICYmIGN0eC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gY3R4LnJlc3VsdDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblx0XHQvKiogQ2FsbCBmbihub2RlKSBmb3IgYWxsIG5vZGVzIGluIGhpZXJhcmNoaWNhbCBvcmRlciAoZGVwdGgtZmlyc3QpLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHRcdCAqICAgICBSZXR1cm4gZmFsc2UgdG8gc3RvcCBpdGVyYXRpb24sIHJldHVybiBcInNraXBcIiB0byBza2lwIHRoaXMgbm9kZSBhbmQgY2hpbGRyZW4gb25seS5cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UsIGlmIHRoZSBpdGVyYXRvciB3YXMgc3RvcHBlZC5cblx0XHQgKi9cblx0XHR2aXNpdDogZnVuY3Rpb24oZm4pIHtcblx0XHRcdHJldHVybiB0aGlzLnJvb3ROb2RlLnZpc2l0KGZuLCBmYWxzZSk7XG5cdFx0fSxcblx0XHQvKiogQ2FsbCBmbihub2RlKSBmb3IgYWxsIG5vZGVzIGluIHZlcnRpY2FsIG9yZGVyLCB0b3AgZG93biAob3IgYm90dG9tIHVwKS48YnI+XG5cdFx0ICogU3RvcCBpdGVyYXRpb24sIGlmIGZuKCkgcmV0dXJucyBmYWxzZS48YnI+XG5cdFx0ICogUmV0dXJuIGZhbHNlIGlmIGl0ZXJhdGlvbiB3YXMgc3RvcHBlZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0XHQgKiAgICAgUmV0dXJuIGZhbHNlIHRvIHN0b3AgaXRlcmF0aW9uLCByZXR1cm4gXCJza2lwXCIgdG8gc2tpcCB0aGlzIG5vZGUgYW5kIGNoaWxkcmVuIG9ubHkuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuXHRcdCAqICAgICBEZWZhdWx0czpcblx0XHQgKiAgICAge3N0YXJ0OiBGaXJzdCB0b3Agbm9kZSwgcmV2ZXJzZTogZmFsc2UsIGluY2x1ZGVTZWxmOiB0cnVlLCBpbmNsdWRlSGlkZGVuOiBmYWxzZX1cblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gZmFsc2UgaWYgaXRlcmF0aW9uIHdhcyBjYW5jZWxsZWRcblx0XHQgKiBAc2luY2UgMi4yOFxuXHRcdCAqL1xuXHRcdHZpc2l0Um93czogZnVuY3Rpb24oZm4sIG9wdHMpIHtcblx0XHRcdGlmICghdGhpcy5yb290Tm9kZS5jaGlsZHJlbikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0cyAmJiBvcHRzLnJldmVyc2UpIHtcblx0XHRcdFx0ZGVsZXRlIG9wdHMucmV2ZXJzZTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Zpc2l0Um93c1VwKGZuLCBvcHRzKTtcblx0XHRcdH1cblx0XHRcdG9wdHMgPSBvcHRzIHx8IHt9O1xuXG5cdFx0XHR2YXIgaSxcblx0XHRcdFx0bmV4dElkeCxcblx0XHRcdFx0cGFyZW50LFxuXHRcdFx0XHRyZXMsXG5cdFx0XHRcdHNpYmxpbmdzLFxuXHRcdFx0XHRzaWJsaW5nT2ZzID0gMCxcblx0XHRcdFx0c2tpcEZpcnN0Tm9kZSA9IG9wdHMuaW5jbHVkZVNlbGYgPT09IGZhbHNlLFxuXHRcdFx0XHRpbmNsdWRlSGlkZGVuID0gISFvcHRzLmluY2x1ZGVIaWRkZW4sXG5cdFx0XHRcdGNoZWNrRmlsdGVyID0gIWluY2x1ZGVIaWRkZW4gJiYgdGhpcy5lbmFibGVGaWx0ZXIsXG5cdFx0XHRcdG5vZGUgPSBvcHRzLnN0YXJ0IHx8IHRoaXMucm9vdE5vZGUuY2hpbGRyZW5bMF07XG5cblx0XHRcdHBhcmVudCA9IG5vZGUucGFyZW50O1xuXHRcdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0XHQvLyB2aXNpdCBzaWJsaW5nc1xuXHRcdFx0XHRzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlbjtcblx0XHRcdFx0bmV4dElkeCA9IHNpYmxpbmdzLmluZGV4T2Yobm9kZSkgKyBzaWJsaW5nT2ZzO1xuXG5cdFx0XHRcdGZvciAoaSA9IG5leHRJZHg7IGkgPCBzaWJsaW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG5vZGUgPSBzaWJsaW5nc1tpXTtcblx0XHRcdFx0XHRpZiAoY2hlY2tGaWx0ZXIgJiYgIW5vZGUubWF0Y2ggJiYgIW5vZGUuc3ViTWF0Y2hDb3VudCkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICghc2tpcEZpcnN0Tm9kZSAmJiBmbihub2RlKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2tpcEZpcnN0Tm9kZSA9IGZhbHNlO1xuXHRcdFx0XHRcdC8vIERpdmUgaW50byBub2RlJ3MgY2hpbGQgbm9kZXNcblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuICYmXG5cdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuLmxlbmd0aCAmJlxuXHRcdFx0XHRcdFx0KGluY2x1ZGVIaWRkZW4gfHwgbm9kZS5leHBhbmRlZClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIERpc2FibGUgd2FybmluZzogRnVuY3Rpb25zIGRlY2xhcmVkIHdpdGhpbiBsb29wcyByZWZlcmVuY2luZyBhbiBvdXRlclxuXHRcdFx0XHRcdFx0Ly8gc2NvcGVkIHZhcmlhYmxlIG1heSBsZWFkIHRvIGNvbmZ1c2luZyBzZW1hbnRpY3M6XG5cdFx0XHRcdFx0XHQvKmpzaGludCAtVzA4MyAqL1xuXHRcdFx0XHRcdFx0cmVzID0gbm9kZS52aXNpdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChjaGVja0ZpbHRlciAmJiAhbi5tYXRjaCAmJiAhbi5zdWJNYXRjaENvdW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwic2tpcFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChmbihuKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCFpbmNsdWRlSGlkZGVuICYmIG4uY2hpbGRyZW4gJiYgIW4uZXhwYW5kZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJza2lwXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIGZhbHNlKTtcblx0XHRcdFx0XHRcdC8qanNoaW50ICtXMDgzICovXG5cdFx0XHRcdFx0XHRpZiAocmVzID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFZpc2l0IHBhcmVudCBub2RlcyAoYm90dG9tIHVwKVxuXHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0XHRzaWJsaW5nT2ZzID0gMTsgLy9cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cdFx0LyogQ2FsbCBmbihub2RlKSBmb3IgYWxsIG5vZGVzIGluIHZlcnRpY2FsIG9yZGVyLCBib3R0b20gdXAuXG5cdFx0ICovXG5cdFx0X3Zpc2l0Um93c1VwOiBmdW5jdGlvbihmbiwgb3B0cykge1xuXHRcdFx0dmFyIGNoaWxkcmVuLFxuXHRcdFx0XHRpZHgsXG5cdFx0XHRcdHBhcmVudCxcblx0XHRcdFx0aW5jbHVkZUhpZGRlbiA9ICEhb3B0cy5pbmNsdWRlSGlkZGVuLFxuXHRcdFx0XHRub2RlID0gb3B0cy5zdGFydCB8fCB0aGlzLnJvb3ROb2RlLmNoaWxkcmVuWzBdO1xuXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRwYXJlbnQgPSBub2RlLnBhcmVudDtcblx0XHRcdFx0Y2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG5cblx0XHRcdFx0aWYgKGNoaWxkcmVuWzBdID09PSBub2RlKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbHJlYWR5IHRoZSBmaXJzdCBzaWJsaW5nLCBnb3RvIHBhcmVudFxuXHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0aWYgKCFub2RlLnBhcmVudCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7IC8vIGZpcnN0IG5vZGUgb2YgdGhlIHRyZWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBnb3RvIHByZXYuIHNpYmxpbmdcblx0XHRcdFx0XHRpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuXHRcdFx0XHRcdG5vZGUgPSBjaGlsZHJlbltpZHggLSAxXTtcblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJldi4gc2libGluZyBoYXMgY2hpbGRyZW4sIGZvbGxvdyBkb3duIHRvIGxhc3QgZGVzY2VuZGFudFxuXHRcdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRcdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzExMzAyXG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5tb2RpZmllZC1sb29wLWNvbmRpdGlvblxuXHRcdFx0XHRcdFx0KGluY2x1ZGVIaWRkZW4gfHwgbm9kZS5leHBhbmRlZCkgJiZcblx0XHRcdFx0XHRcdG5vZGUuY2hpbGRyZW4gJiZcblx0XHRcdFx0XHRcdG5vZGUuY2hpbGRyZW4ubGVuZ3RoXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBub2RlO1xuXHRcdFx0XHRcdFx0bm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTa2lwIGludmlzaWJsZVxuXHRcdFx0XHRpZiAoIWluY2x1ZGVIaWRkZW4gJiYgIW5vZGUuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZm4obm9kZSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQvKiogV3JpdGUgd2FybmluZyB0byBicm93c2VyIGNvbnNvbGUgaWYgZGVidWdMZXZlbCA+PSAyIChwcmVwZW5kaW5nIHRyZWUgaW5mbylcblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Kn0gbXNnIHN0cmluZyBvciBvYmplY3Qgb3IgYXJyYXkgb2Ygc3VjaFxuXHRcdCAqL1xuXHRcdHdhcm46IGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5kZWJ1Z0xldmVsID49IDIpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuY2FsbChhcmd1bWVudHMsIHRoaXMudG9TdHJpbmcoKSk7XG5cdFx0XHRcdGNvbnNvbGVBcHBseShcIndhcm5cIiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGVzZSBhZGRpdGlvbmFsIG1ldGhvZHMgb2YgdGhlIHtAbGluayBGYW5jeXRyZWV9IGNsYXNzIGFyZSAnaG9vayBmdW5jdGlvbnMnXG5cdCAqIHRoYXQgY2FuIGJlIHVzZWQgYW5kIG92ZXJsb2FkZWQgYnkgZXh0ZW5zaW9ucy5cblx0ICogKFNlZSA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21hcjEwL2ZhbmN5dHJlZS93aWtpL1R1dG9yaWFsRXh0ZW5zaW9uc1wiPndyaXRpbmcgZXh0ZW5zaW9uczwvYT4uKVxuXHQgKiBAbWl4aW4gRmFuY3l0cmVlX0hvb2tzXG5cdCAqL1xuXHQkLmV4dGVuZChcblx0XHRGYW5jeXRyZWUucHJvdG90eXBlLFxuXHRcdC8qKiBAbGVuZHMgRmFuY3l0cmVlX0hvb2tzIyAqL1xuXHRcdHtcblx0XHRcdC8qKiBEZWZhdWx0IGhhbmRsaW5nIGZvciBtb3VzZSBjbGljayBldmVudHMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICovXG5cdFx0XHRub2RlQ2xpY2s6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHR2YXIgYWN0aXZhdGUsXG5cdFx0XHRcdFx0ZXhwYW5kLFxuXHRcdFx0XHRcdC8vIGV2ZW50ID0gY3R4Lm9yaWdpbmFsRXZlbnQsXG5cdFx0XHRcdFx0dGFyZ2V0VHlwZSA9IGN0eC50YXJnZXRUeXBlLFxuXHRcdFx0XHRcdG5vZGUgPSBjdHgubm9kZTtcblxuXHRcdFx0XHQvLyB0aGlzLmRlYnVnKFwiZnRub2RlLm9uQ2xpY2soXCIgKyBldmVudC50eXBlICsgXCIpOiBmdG5vZGU6XCIgKyB0aGlzICsgXCIsIGJ1dHRvbjpcIiArIGV2ZW50LmJ1dHRvbiArIFwiLCB3aGljaDogXCIgKyBldmVudC53aGljaCwgY3R4KTtcblx0XHRcdFx0Ly8gVE9ETzogdXNlIHN3aXRjaFxuXHRcdFx0XHQvLyBUT0RPOiBtYWtlIHN1cmUgY2xpY2tzIG9uIGVtYmVkZGVkIDxpbnB1dD4gZG9lc24ndCBzdGVhbCBmb2N1cyAoc2VlIHRhYmxlIHNhbXBsZSlcblx0XHRcdFx0aWYgKHRhcmdldFR5cGUgPT09IFwiZXhwYW5kZXJcIikge1xuXHRcdFx0XHRcdGlmIChub2RlLmlzTG9hZGluZygpKSB7XG5cdFx0XHRcdFx0XHQvLyAjNDk1OiB3ZSBwcm9iYWJseSBnb3QgYSBjbGljayBldmVudCB3aGlsZSBhIGxhenkgbG9hZCBpcyBwZW5kaW5nLlxuXHRcdFx0XHRcdFx0Ly8gVGhlICdleHBhbmRlZCcgc3RhdGUgaXMgbm90IHlldCBzZXQsIHNvICd0b2dnbGUnIHdvdWxkIGV4cGFuZFxuXHRcdFx0XHRcdFx0Ly8gYW5kIHRyaWdnZXIgbGF6eUxvYWQgYWdhaW4uXG5cdFx0XHRcdFx0XHQvLyBJdCB3b3VsZCBiZSBiZXR0ZXIgdG8gYWxsb3cgdG8gY29sbGFwc2UvZXhwYW5kIHRoZSBzdGF0dXMgbm9kZVxuXHRcdFx0XHRcdFx0Ly8gd2hpbGUgbG9hZGluZyAoaW5zdGVhZCBvZiBpZ25vcmluZyksIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgc29tZVxuXHRcdFx0XHRcdFx0Ly8gbW9yZSB3b3JrLlxuXHRcdFx0XHRcdFx0bm9kZS5kZWJ1ZyhcIkdvdCAybmQgY2xpY2sgd2hpbGUgbG9hZGluZzogaWdub3JlZFwiKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2xpY2tpbmcgdGhlIGV4cGFuZGVyIGljb24gYWx3YXlzIGV4cGFuZHMvY29sbGFwc2VzXG5cdFx0XHRcdFx0dGhpcy5fY2FsbEhvb2soXCJub2RlVG9nZ2xlRXhwYW5kZWRcIiwgY3R4KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXRUeXBlID09PSBcImNoZWNrYm94XCIpIHtcblx0XHRcdFx0XHQvLyBDbGlja2luZyB0aGUgY2hlY2tib3ggYWx3YXlzIChkZSlzZWxlY3RzXG5cdFx0XHRcdFx0dGhpcy5fY2FsbEhvb2soXCJub2RlVG9nZ2xlU2VsZWN0ZWRcIiwgY3R4KTtcblx0XHRcdFx0XHRpZiAoY3R4Lm9wdGlvbnMuZm9jdXNPblNlbGVjdCkge1xuXHRcdFx0XHRcdFx0Ly8gIzM1OFxuXHRcdFx0XHRcdFx0dGhpcy5fY2FsbEhvb2soXCJub2RlU2V0Rm9jdXNcIiwgY3R4LCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSG9ub3IgYGNsaWNrRm9sZGVyTW9kZWAgZm9yXG5cdFx0XHRcdFx0ZXhwYW5kID0gZmFsc2U7XG5cdFx0XHRcdFx0YWN0aXZhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdGlmIChub2RlLmZvbGRlcikge1xuXHRcdFx0XHRcdFx0c3dpdGNoIChjdHgub3B0aW9ucy5jbGlja0ZvbGRlck1vZGUpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAyOiAvLyBleHBhbmQgb25seVxuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0YWN0aXZhdGUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOiAvLyBleHBhbmQgYW5kIGFjdGl2YXRlXG5cdFx0XHRcdFx0XHRcdFx0YWN0aXZhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZCA9IHRydWU7IC8vIW5vZGUuaXNFeHBhbmRlZCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHQvLyBlbHNlIDEgb3IgNDoganVzdCBhY3RpdmF0ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoYWN0aXZhdGUpIHtcblx0XHRcdFx0XHRcdHRoaXMubm9kZVNldEZvY3VzKGN0eCk7XG5cdFx0XHRcdFx0XHR0aGlzLl9jYWxsSG9vayhcIm5vZGVTZXRBY3RpdmVcIiwgY3R4LCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGV4cGFuZCkge1xuXHRcdFx0XHRcdFx0aWYgKCFhY3RpdmF0ZSkge1xuXHRcdFx0XHRcdFx0XHQvLyB0aGlzLl9jYWxsSG9vayhcIm5vZGVTZXRGb2N1c1wiLCBjdHgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gdGhpcy5fY2FsbEhvb2soXCJub2RlU2V0RXhwYW5kZWRcIiwgY3R4LCB0cnVlKTtcblx0XHRcdFx0XHRcdHRoaXMuX2NhbGxIb29rKFwibm9kZVRvZ2dsZUV4cGFuZGVkXCIsIGN0eCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IGNsaWNrcyBzdG9wLCBvdGhlcndpc2UgPGEgaHJlZj0nIyc+IGp1bXBzIHRvIHRoZSB0b3Bcblx0XHRcdFx0Ly8gaWYoZXZlbnQudGFyZ2V0LmxvY2FsTmFtZSA9PT0gXCJhXCIgJiYgZXZlbnQudGFyZ2V0LmNsYXNzTmFtZSA9PT0gXCJmYW5jeXRyZWUtdGl0bGVcIil7XG5cdFx0XHRcdC8vIFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0XHQvLyBUT0RPOiByZXR1cm4gcHJvbWlzZT9cblx0XHRcdH0sXG5cdFx0XHQvKiogQ29sbGFwc2UgYWxsIG90aGVyICBjaGlsZHJlbiBvZiBzYW1lIHBhcmVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKiBAcGFyYW0ge29iamVjdH0gY2FsbE9wdHNcblx0XHRcdCAqL1xuXHRcdFx0bm9kZUNvbGxhcHNlU2libGluZ3M6IGZ1bmN0aW9uKGN0eCwgY2FsbE9wdHMpIHtcblx0XHRcdFx0Ly8gVE9ETzogcmV0dXJuIHByb21pc2U/XG5cdFx0XHRcdHZhciBhYyxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdGwsXG5cdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlO1xuXG5cdFx0XHRcdGlmIChub2RlLnBhcmVudCkge1xuXHRcdFx0XHRcdGFjID0gbm9kZS5wYXJlbnQuY2hpbGRyZW47XG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IGFjLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGFjW2ldICE9PSBub2RlICYmIGFjW2ldLmV4cGFuZGVkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2NhbGxIb29rKFxuXHRcdFx0XHRcdFx0XHRcdFwibm9kZVNldEV4cGFuZGVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0YWNbaV0sXG5cdFx0XHRcdFx0XHRcdFx0ZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbE9wdHNcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKiogRGVmYXVsdCBoYW5kbGluZyBmb3IgbW91c2UgZG91bGVjbGljayBldmVudHMuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKi9cblx0XHRcdG5vZGVEYmxjbGljazogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRcdC8vIFRPRE86IHJldHVybiBwcm9taXNlP1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y3R4LnRhcmdldFR5cGUgPT09IFwidGl0bGVcIiAmJlxuXHRcdFx0XHRcdGN0eC5vcHRpb25zLmNsaWNrRm9sZGVyTW9kZSA9PT0gNFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyB0aGlzLm5vZGVTZXRGb2N1cyhjdHgpO1xuXHRcdFx0XHRcdC8vIHRoaXMuX2NhbGxIb29rKFwibm9kZVNldEFjdGl2ZVwiLCBjdHgsIHRydWUpO1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxIb29rKFwibm9kZVRvZ2dsZUV4cGFuZGVkXCIsIGN0eCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETzogcHJldmVudCB0ZXh0IHNlbGVjdGlvbiBvbiBkYmxjbGlja3Ncblx0XHRcdFx0aWYgKGN0eC50YXJnZXRUeXBlID09PSBcInRpdGxlXCIpIHtcblx0XHRcdFx0XHRjdHgub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIERlZmF1bHQgaGFuZGxpbmcgZm9yIG1vdXNlIGtleWRvd24gZXZlbnRzLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5PVEU6IHRoaXMgbWF5IGJlIGNhbGxlZCB3aXRoIG5vZGUgPT0gbnVsbCBpZiB0cmVlIChidXQgbm8gbm9kZSkgaGFzIGZvY3VzLlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICovXG5cdFx0XHRub2RlS2V5ZG93bjogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRcdC8vIFRPRE86IHJldHVybiBwcm9taXNlP1xuXHRcdFx0XHR2YXIgbWF0Y2hOb2RlLFxuXHRcdFx0XHRcdHN0YW1wLFxuXHRcdFx0XHRcdF9yZXMsXG5cdFx0XHRcdFx0Zm9jdXNOb2RlLFxuXHRcdFx0XHRcdGV2ZW50ID0gY3R4Lm9yaWdpbmFsRXZlbnQsXG5cdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdHRyZWUgPSBjdHgudHJlZSxcblx0XHRcdFx0XHRvcHRzID0gY3R4Lm9wdGlvbnMsXG5cdFx0XHRcdFx0d2hpY2ggPSBldmVudC53aGljaCxcblx0XHRcdFx0XHQvLyAjOTA5OiBVc2UgZXZlbnQua2V5LCB0byBnZXQgdW5pY29kZSBjaGFyYWN0ZXJzLlxuXHRcdFx0XHRcdC8vIFdlIGNhbid0IHVzZSBgL1xcdy8udGVzdChrZXkpYCwgYmVjYXVzZSB0aGF0IHdvdWxkXG5cdFx0XHRcdFx0Ly8gb25seSBkZXRlY3QgcGxhaW4gYXNjaWkgYWxwaGEtbnVtZXJpY3MuIEJ1dCB3ZSBzdGlsbCBuZWVkXG5cdFx0XHRcdFx0Ly8gdG8gaWdub3JlIG1vZGlmaWVyLW9ubHksIHdoaXRlc3BhY2UsIGN1cnNvci1rZXlzLCBldGMuXG5cdFx0XHRcdFx0a2V5ID0gZXZlbnQua2V5IHx8IFN0cmluZy5mcm9tQ2hhckNvZGUod2hpY2gpLFxuXHRcdFx0XHRcdHNwZWNpYWxNb2RpZmllcnMgPSAhIShcblx0XHRcdFx0XHRcdGV2ZW50LmFsdEtleSB8fFxuXHRcdFx0XHRcdFx0ZXZlbnQuY3RybEtleSB8fFxuXHRcdFx0XHRcdFx0ZXZlbnQubWV0YUtleVxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0aXNBbG51bSA9XG5cdFx0XHRcdFx0XHQhTU9ESUZJRVJTW3doaWNoXSAmJlxuXHRcdFx0XHRcdFx0IVNQRUNJQUxfS0VZQ09ERVNbd2hpY2hdICYmXG5cdFx0XHRcdFx0XHQhc3BlY2lhbE1vZGlmaWVycyxcblx0XHRcdFx0XHQkdGFyZ2V0ID0gJChldmVudC50YXJnZXQpLFxuXHRcdFx0XHRcdGhhbmRsZWQgPSB0cnVlLFxuXHRcdFx0XHRcdGFjdGl2YXRlID0gIShldmVudC5jdHJsS2V5IHx8ICFvcHRzLmF1dG9BY3RpdmF0ZSk7XG5cblx0XHRcdFx0Ly8gKG5vZGUgfHwgRlQpLmRlYnVnKFwiZnRub2RlLm5vZGVLZXlkb3duKFwiICsgZXZlbnQudHlwZSArIFwiKTogZnRub2RlOlwiICsgdGhpcyArIFwiLCBjaGFyQ29kZTpcIiArIGV2ZW50LmNoYXJDb2RlICsgXCIsIGtleUNvZGU6IFwiICsgZXZlbnQua2V5Q29kZSArIFwiLCB3aGljaDogXCIgKyBldmVudC53aGljaCk7XG5cdFx0XHRcdC8vIEZULmRlYnVnKCBcImV2ZW50VG9TdHJpbmcoKTogXCIgKyBGVC5ldmVudFRvU3RyaW5nKGV2ZW50KSArIFwiLCBrZXk9J1wiICsga2V5ICsgXCInLCBpc0FsbnVtOiBcIiArIGlzQWxudW0gKTtcblxuXHRcdFx0XHQvLyBTZXQgZm9jdXMgdG8gYWN0aXZlIChvciBmaXJzdCBub2RlKSBpZiBubyBvdGhlciBub2RlIGhhcyB0aGUgZm9jdXMgeWV0XG5cdFx0XHRcdGlmICghbm9kZSkge1xuXHRcdFx0XHRcdGZvY3VzTm9kZSA9IHRoaXMuZ2V0QWN0aXZlTm9kZSgpIHx8IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdFx0XHRcdGlmIChmb2N1c05vZGUpIHtcblx0XHRcdFx0XHRcdGZvY3VzTm9kZS5zZXRGb2N1cygpO1xuXHRcdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlID0gdGhpcy5mb2N1c05vZGU7XG5cdFx0XHRcdFx0XHRub2RlLmRlYnVnKFwiS2V5ZG93biBmb3JjZSBmb2N1cyBvbiBhY3RpdmUgbm9kZVwiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b3B0cy5xdWlja3NlYXJjaCAmJlxuXHRcdFx0XHRcdGlzQWxudW0gJiZcblx0XHRcdFx0XHQhJHRhcmdldC5pcyhcIjppbnB1dDplbmFibGVkXCIpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIEFsbG93IHRvIHNlYXJjaCBmb3IgbG9uZ2VyIHN0cmVha3MgaWYgdHlwZWQgaW4gcXVpY2tseVxuXHRcdFx0XHRcdHN0YW1wID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRpZiAoc3RhbXAgLSB0cmVlLmxhc3RRdWlja3NlYXJjaFRpbWUgPiA1MDApIHtcblx0XHRcdFx0XHRcdHRyZWUubGFzdFF1aWNrc2VhcmNoVGVybSA9IFwiXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRyZWUubGFzdFF1aWNrc2VhcmNoVGltZSA9IHN0YW1wO1xuXHRcdFx0XHRcdHRyZWUubGFzdFF1aWNrc2VhcmNoVGVybSArPSBrZXk7XG5cdFx0XHRcdFx0Ly8gdHJlZS5kZWJ1ZyhcInF1aWNrc2VhcmNoIGZpbmRcIiwgdHJlZS5sYXN0UXVpY2tzZWFyY2hUZXJtKTtcblx0XHRcdFx0XHRtYXRjaE5vZGUgPSB0cmVlLmZpbmROZXh0Tm9kZShcblx0XHRcdFx0XHRcdHRyZWUubGFzdFF1aWNrc2VhcmNoVGVybSxcblx0XHRcdFx0XHRcdHRyZWUuZ2V0QWN0aXZlTm9kZSgpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRpZiAobWF0Y2hOb2RlKSB7XG5cdFx0XHRcdFx0XHRtYXRjaE5vZGUuc2V0QWN0aXZlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN3aXRjaCAoRlQuZXZlbnRUb1N0cmluZyhldmVudCkpIHtcblx0XHRcdFx0XHRjYXNlIFwiK1wiOlxuXHRcdFx0XHRcdGNhc2UgXCI9XCI6IC8vIDE4NzogJysnIEAgQ2hyb21lLCBTYWZhcmlcblx0XHRcdFx0XHRcdHRyZWUubm9kZVNldEV4cGFuZGVkKGN0eCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiLVwiOlxuXHRcdFx0XHRcdFx0dHJlZS5ub2RlU2V0RXhwYW5kZWQoY3R4LCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic3BhY2VcIjpcblx0XHRcdFx0XHRcdGlmIChub2RlLmlzUGFnaW5nTm9kZSgpKSB7XG5cdFx0XHRcdFx0XHRcdHRyZWUuX3RyaWdnZXJOb2RlRXZlbnQoXCJjbGlja1BhZ2luZ1wiLCBjdHgsIGV2ZW50KTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdEZULmV2YWxPcHRpb24oXCJjaGVja2JveFwiLCBub2RlLCBub2RlLCBvcHRzLCBmYWxzZSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHQvLyAjNzY4XG5cdFx0XHRcdFx0XHRcdHRyZWUubm9kZVRvZ2dsZVNlbGVjdGVkKGN0eCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0cmVlLm5vZGVTZXRBY3RpdmUoY3R4LCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJyZXR1cm5cIjpcblx0XHRcdFx0XHRcdHRyZWUubm9kZVNldEFjdGl2ZShjdHgsIHRydWUpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImhvbWVcIjpcblx0XHRcdFx0XHRjYXNlIFwiZW5kXCI6XG5cdFx0XHRcdFx0Y2FzZSBcImJhY2tzcGFjZVwiOlxuXHRcdFx0XHRcdGNhc2UgXCJsZWZ0XCI6XG5cdFx0XHRcdFx0Y2FzZSBcInJpZ2h0XCI6XG5cdFx0XHRcdFx0Y2FzZSBcInVwXCI6XG5cdFx0XHRcdFx0Y2FzZSBcImRvd25cIjpcblx0XHRcdFx0XHRcdF9yZXMgPSBub2RlLm5hdmlnYXRlKGV2ZW50LndoaWNoLCBhY3RpdmF0ZSk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0aGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gLyoqIERlZmF1bHQgaGFuZGxpbmcgZm9yIG1vdXNlIGtleXByZXNzIGV2ZW50cy4gKi9cblx0XHRcdC8vIG5vZGVLZXlwcmVzczogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHQvLyAgICAgdmFyIGV2ZW50ID0gY3R4Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0XHQvLyB9LFxuXG5cdFx0XHQvLyAvKiogVHJpZ2dlciBsYXp5TG9hZCBldmVudCAoYXN5bmMpLiAqL1xuXHRcdFx0Ly8gbm9kZUxhenlMb2FkOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdC8vICAgICB2YXIgbm9kZSA9IGN0eC5ub2RlO1xuXHRcdFx0Ly8gICAgIGlmKHRoaXMuX3RyaWdnZXJOb2RlRXZlbnQoKSlcblx0XHRcdC8vIH0sXG5cdFx0XHQvKiogTG9hZCBjaGlsZCBub2RlcyAoYXN5bmMpLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0W118b2JqZWN0fHN0cmluZ3wkLlByb21pc2V8ZnVuY3Rpb259IHNvdXJjZVxuXHRcdFx0ICogQHJldHVybnMgeyQuUHJvbWlzZX0gVGhlIGRlZmVycmVkIHdpbGwgYmUgcmVzb2x2ZWQgYXMgc29vbiBhcyB0aGUgKGFqYXgpXG5cdFx0XHQgKiAgICAgZGF0YSB3YXMgcmVuZGVyZWQuXG5cdFx0XHQgKi9cblx0XHRcdG5vZGVMb2FkQ2hpbGRyZW46IGZ1bmN0aW9uKGN0eCwgc291cmNlKSB7XG5cdFx0XHRcdHZhciBhamF4LFxuXHRcdFx0XHRcdGRlbGF5LFxuXHRcdFx0XHRcdGRmZCxcblx0XHRcdFx0XHRyZXMsXG5cdFx0XHRcdFx0dHJlZSA9IGN0eC50cmVlLFxuXHRcdFx0XHRcdG5vZGUgPSBjdHgubm9kZSxcblx0XHRcdFx0XHRyZXF1ZXN0SWQgPSBEYXRlLm5vdygpO1xuXG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oc291cmNlKSkge1xuXHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZS5jYWxsKHRyZWUsIHsgdHlwZTogXCJzb3VyY2VcIiB9LCBjdHgpO1xuXHRcdFx0XHRcdF9hc3NlcnQoXG5cdFx0XHRcdFx0XHQhJC5pc0Z1bmN0aW9uKHNvdXJjZSksXG5cdFx0XHRcdFx0XHRcInNvdXJjZSBjYWxsYmFjayBtdXN0IG5vdCByZXR1cm4gYW5vdGhlciBmdW5jdGlvblwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc291cmNlLnVybCkge1xuXHRcdFx0XHRcdGlmIChub2RlLl9yZXF1ZXN0SWQpIHtcblx0XHRcdFx0XHRcdG5vZGUud2Fybihcblx0XHRcdFx0XHRcdFx0XCJSZWN1cnNpdmUgbG9hZCByZXF1ZXN0ICNcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdElkICtcblx0XHRcdFx0XHRcdFx0XHRcIiB3aGlsZSAjXCIgK1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUuX3JlcXVlc3RJZCArXG5cdFx0XHRcdFx0XHRcdFx0XCIgaXMgcGVuZGluZy5cIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdC8vIH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBcdG5vZGUuZGVidWcoXCJTZW5kIGxvYWQgcmVxdWVzdCAjXCIgKyByZXF1ZXN0SWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBgc291cmNlYCBpcyBhbiBBamF4IG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRcdFx0YWpheCA9ICQuZXh0ZW5kKHt9LCBjdHgub3B0aW9ucy5hamF4LCBzb3VyY2UpO1xuXHRcdFx0XHRcdG5vZGUuX3JlcXVlc3RJZCA9IHJlcXVlc3RJZDtcblx0XHRcdFx0XHRpZiAoYWpheC5kZWJ1Z0RlbGF5KSB7XG5cdFx0XHRcdFx0XHQvLyBzaW11bGF0ZSBhIHNsb3cgc2VydmVyXG5cdFx0XHRcdFx0XHRkZWxheSA9IGFqYXguZGVidWdEZWxheTtcblx0XHRcdFx0XHRcdGRlbGV0ZSBhamF4LmRlYnVnRGVsYXk7IC8vIHJlbW92ZSBkZWJ1ZyBvcHRpb25cblx0XHRcdFx0XHRcdGlmICgkLmlzQXJyYXkoZGVsYXkpKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHJhbmRvbSBkZWxheSByYW5nZSBbbWluLi5tYXhdXG5cdFx0XHRcdFx0XHRcdGRlbGF5ID1cblx0XHRcdFx0XHRcdFx0XHRkZWxheVswXSArXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yYW5kb20oKSAqIChkZWxheVsxXSAtIGRlbGF5WzBdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG5vZGUud2Fybihcblx0XHRcdFx0XHRcdFx0XCJub2RlTG9hZENoaWxkcmVuIHdhaXRpbmcgZGVidWdEZWxheSBcIiArXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5yb3VuZChkZWxheSkgK1xuXHRcdFx0XHRcdFx0XHRcdFwiIG1zIC4uLlwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0ZGZkID0gJC5EZWZlcnJlZChmdW5jdGlvbihkZmQpIHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHQkLmFqYXgoYWpheClcblx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZmQucmVzb2x2ZVdpdGgodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0XHQuZmFpbChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGZkLnJlamVjdFdpdGgodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9LCBkZWxheSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGZkID0gJC5hamF4KGFqYXgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERlZmVyIHRoZSBkZWZlcnJlZDogd2Ugd2FudCB0byBiZSBhYmxlIHRvIHJlamVjdCwgZXZlbiBpZiBhamF4XG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZWQgb2suXG5cdFx0XHRcdFx0c291cmNlID0gbmV3ICQuRGVmZXJyZWQoKTtcblx0XHRcdFx0XHRkZmQuZG9uZShmdW5jdGlvbihkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuXHRcdFx0XHRcdFx0dmFyIGVycm9yT2JqLCByZXM7XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0KHRoaXMuZGF0YVR5cGUgPT09IFwianNvblwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5kYXRhVHlwZSA9PT0gXCJqc29ucFwiKSAmJlxuXHRcdFx0XHRcdFx0XHR0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIlxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdCQuZXJyb3IoXG5cdFx0XHRcdFx0XHRcdFx0XCJBamF4IHJlcXVlc3QgcmV0dXJuZWQgYSBzdHJpbmcgKGRpZCB5b3UgZ2V0IHRoZSBKU09OIGRhdGFUeXBlIHdyb25nPykuXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChub2RlLl9yZXF1ZXN0SWQgJiYgbm9kZS5fcmVxdWVzdElkID4gcmVxdWVzdElkKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBleHBlY3RlZCByZXF1ZXN0IHRpbWUgc3RhbXAgaXMgbGF0ZXIgdGhhbiBgcmVxdWVzdElkYFxuXHRcdFx0XHRcdFx0XHQvLyAod2hpY2ggd2FzIGtlcHQgYXMgYXMgY2xvc3VyZSB2YXJpYWJsZSB0byB0aGlzIGhhbmRsZXIgZnVuY3Rpb24pXG5cdFx0XHRcdFx0XHRcdC8vIG5vZGUud2FybihcIklnbm9yZWQgbG9hZCByZXNwb25zZSBmb3Igb2Jzb2xldGUgcmVxdWVzdCAjXCIgKyByZXF1ZXN0SWQgKyBcIiAoZXhwZWN0ZWQgI1wiICsgbm9kZS5fcmVxdWVzdElkICsgXCIpXCIpO1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucmVqZWN0V2l0aCh0aGlzLCBbUkVDVVJTSVZFX1JFUVVFU1RfRVJST1JdKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHQvLyB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBcdG5vZGUuZGVidWcoXCJSZXNwb25zZSByZXR1cm5lZCBmb3IgbG9hZCByZXF1ZXN0ICNcIiArIHJlcXVlc3RJZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBwb3N0UHJvY2VzcyBpcyBzaW1pbGFyIHRvIHRoZSBzdGFuZGFyZCBhamF4IGRhdGFGaWx0ZXIgaG9vayxcblx0XHRcdFx0XHRcdC8vIGJ1dCBpdCBpcyBhbHNvIGNhbGxlZCBmb3IgSlNPTlBcblx0XHRcdFx0XHRcdGlmIChjdHgub3B0aW9ucy5wb3N0UHJvY2Vzcykge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFRoZSBoYW5kbGVyIG1heSBlaXRoZXJcblx0XHRcdFx0XHRcdFx0XHQvLyAgIC0gbW9kaWZ5IGBjdHgucmVzcG9uc2VgIGluLXBsYWNlIChhbmQgbGVhdmUgYGN0eC5yZXN1bHRgIHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdFx0XHQvLyAgICAgPT4gcmVzID0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHRcdFx0Ly8gICAtIHJldHVybiBhIHJlcGxhY2VtZW50IGluIGBjdHgucmVzdWx0YFxuXHRcdFx0XHRcdFx0XHRcdC8vICAgICA9PiByZXMgPSA8bmV3IGRhdGE+XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgcmVzIGNvbnRhaW5zIGFuIGBlcnJvcmAgcHJvcGVydHksIGFuIGVycm9yIHN0YXR1cyBpcyBkaXNwbGF5ZWRcblx0XHRcdFx0XHRcdFx0XHRyZXMgPSB0cmVlLl90cmlnZ2VyTm9kZUV2ZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJwb3N0UHJvY2Vzc1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4Lm9yaWdpbmFsRXZlbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlOiBkYXRhLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGU6IHRoaXMuZGF0YVR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcyA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogXCJcIiArIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRkZXRhaWxzOiBcInBvc3RQcm9jZXNzIGZhaWxlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKHJlcy5lcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yT2JqID0gJC5pc1BsYWluT2JqZWN0KHJlcy5lcnJvcilcblx0XHRcdFx0XHRcdFx0XHRcdD8gcmVzLmVycm9yXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHsgbWVzc2FnZTogcmVzLmVycm9yIH07XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3JPYmogPSB0cmVlLl9tYWtlSG9va0NvbnRleHQoXG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yT2JqXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRzb3VyY2UucmVqZWN0V2l0aCh0aGlzLCBbZXJyb3JPYmpdKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdCQuaXNBcnJheShyZXMpIHx8XG5cdFx0XHRcdFx0XHRcdFx0KCQuaXNQbGFpbk9iamVjdChyZXMpICYmXG5cdFx0XHRcdFx0XHRcdFx0XHQkLmlzQXJyYXkocmVzLmNoaWxkcmVuKSlcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIGBjdHgucmVzdWx0YCBpZiB2YWxpZFxuXHRcdFx0XHRcdFx0XHRcdC8vIChvdGhlcndpc2UgdXNlIGV4aXN0aW5nIGRhdGEsIHdoaWNoIG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgaW4tcGxhY2UpXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IHJlcztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0ZGF0YSAmJlxuXHRcdFx0XHRcdFx0XHRkYXRhLmhhc093blByb3BlcnR5KFwiZFwiKSAmJlxuXHRcdFx0XHRcdFx0XHRjdHgub3B0aW9ucy5lbmFibGVBc3B4XG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyBBU1BYIFdlYk1ldGhvZCBKU09OIG9iamVjdCBpbnNpZGUgXCJkXCIgcHJvcGVydHlcblx0XHRcdFx0XHRcdFx0ZGF0YSA9XG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGRhdGEuZCA9PT0gXCJzdHJpbmdcIlxuXHRcdFx0XHRcdFx0XHRcdFx0PyAkLnBhcnNlSlNPTihkYXRhLmQpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGRhdGEuZDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNvdXJjZS5yZXNvbHZlV2l0aCh0aGlzLCBbZGF0YV0pO1xuXHRcdFx0XHRcdH0pLmZhaWwoZnVuY3Rpb24oanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG5cdFx0XHRcdFx0XHR2YXIgZXJyb3JPYmogPSB0cmVlLl9tYWtlSG9va0NvbnRleHQobm9kZSwgbnVsbCwge1xuXHRcdFx0XHRcdFx0XHRlcnJvcjoganFYSFIsXG5cdFx0XHRcdFx0XHRcdGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6IGVycm9yVGhyb3duLFxuXHRcdFx0XHRcdFx0XHRkZXRhaWxzOiBqcVhIUi5zdGF0dXMgKyBcIjogXCIgKyBlcnJvclRocm93bixcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0c291cmNlLnJlamVjdFdpdGgodGhpcywgW2Vycm9yT2JqXSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gIzM4MzogYWNjZXB0IGFuZCBjb252ZXJ0IEVDTUFTY3JpcHQgNiBQcm9taXNlXG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oc291cmNlLnRoZW4pICYmICQuaXNGdW5jdGlvbihzb3VyY2UuY2F0Y2gpKSB7XG5cdFx0XHRcdFx0ZGZkID0gc291cmNlO1xuXHRcdFx0XHRcdHNvdXJjZSA9IG5ldyAkLkRlZmVycmVkKCk7XG5cdFx0XHRcdFx0ZGZkLnRoZW4oXG5cdFx0XHRcdFx0XHRmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucmVzb2x2ZSh2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0XHRcdFx0XHRcdHNvdXJjZS5yZWplY3QocmVhc29uKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkLmlzRnVuY3Rpb24oc291cmNlLnByb21pc2UpKSB7XG5cdFx0XHRcdFx0Ly8gYHNvdXJjZWAgaXMgYSBkZWZlcnJlZCwgaS5lLiBhamF4IHJlcXVlc3Rcblx0XHRcdFx0XHQvLyBfYXNzZXJ0KCFub2RlLmlzTG9hZGluZygpLCBcInJlY3Vyc2l2ZSBsb2FkXCIpO1xuXHRcdFx0XHRcdHRyZWUubm9kZVNldFN0YXR1cyhjdHgsIFwibG9hZGluZ1wiKTtcblxuXHRcdFx0XHRcdHNvdXJjZVxuXHRcdFx0XHRcdFx0LmRvbmUoZnVuY3Rpb24oY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdFx0dHJlZS5ub2RlU2V0U3RhdHVzKGN0eCwgXCJva1wiKTtcblx0XHRcdFx0XHRcdFx0bm9kZS5fcmVxdWVzdElkID0gbnVsbDtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuZmFpbChmdW5jdGlvbihlcnJvcikge1xuXHRcdFx0XHRcdFx0XHR2YXIgY3R4RXJyO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChlcnJvciA9PT0gUkVDVVJTSVZFX1JFUVVFU1RfRVJST1IpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlLndhcm4oXG5cdFx0XHRcdFx0XHRcdFx0XHRcIklnbm9yZWQgcmVzcG9uc2UgZm9yIG9ic29sZXRlIGxvYWQgcmVxdWVzdCAjXCIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXF1ZXN0SWQgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcIiAoZXhwZWN0ZWQgI1wiICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5fcmVxdWVzdElkICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XCIpXCJcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5ub2RlICYmXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IuZXJyb3IgJiZcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5tZXNzYWdlXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9yIGlzIGFscmVhZHkgYSBjb250ZXh0IG9iamVjdFxuXHRcdFx0XHRcdFx0XHRcdGN0eEVyciA9IGVycm9yO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGN0eEVyciA9IHRyZWUuX21ha2VIb29rQ29udGV4dChub2RlLCBudWxsLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IsIC8vIGl0IGNhbiBiZSBqcVhIUiBvciBhbnkgY3VzdG9tIGVycm9yXG5cdFx0XHRcdFx0XHRcdFx0XHRhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdFx0XHRcdFx0bWVzc2FnZTogZXJyb3Jcblx0XHRcdFx0XHRcdFx0XHRcdFx0PyBlcnJvci5tZXNzYWdlIHx8IGVycm9yLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0OiBcIlwiLFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjdHhFcnIubWVzc2FnZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4RXJyLm1lc3NhZ2UgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRub2RlLndhcm4oXG5cdFx0XHRcdFx0XHRcdFx0XCJMb2FkIGNoaWxkcmVuIGZhaWxlZCAoXCIgKyBjdHhFcnIubWVzc2FnZSArIFwiKVwiLFxuXHRcdFx0XHRcdFx0XHRcdGN0eEVyclxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0dHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XHRcdFwibG9hZEVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRjdHhFcnIsXG5cdFx0XHRcdFx0XHRcdFx0XHRudWxsXG5cdFx0XHRcdFx0XHRcdFx0KSAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJlZS5ub2RlU2V0U3RhdHVzKFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4RXJyLm1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRcdFx0XHRjdHhFcnIuZGV0YWlsc1xuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjdHgub3B0aW9ucy5wb3N0UHJvY2Vzcykge1xuXHRcdFx0XHRcdFx0Ly8gIzc5MjogQ2FsbCBwb3N0UHJvY2VzcyBmb3Igbm9uLWRlZmVycmVkIHNvdXJjZVxuXHRcdFx0XHRcdFx0cmVzID0gdHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XCJwb3N0UHJvY2Vzc1wiLFxuXHRcdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRcdGN0eC5vcmlnaW5hbEV2ZW50LFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2U6IHNvdXJjZSxcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZTogdHlwZW9mIHNvdXJjZSxcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHQkLmlzQXJyYXkocmVzKSB8fFxuXHRcdFx0XHRcdFx0XHQoJC5pc1BsYWluT2JqZWN0KHJlcykgJiYgJC5pc0FycmF5KHJlcy5jaGlsZHJlbikpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIGBjdHgucmVzdWx0YCBpZiB2YWxpZFxuXHRcdFx0XHRcdFx0XHQvLyAob3RoZXJ3aXNlIHVzZSBleGlzdGluZyBkYXRhLCB3aGljaCBtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIGluLXBsYWNlKVxuXHRcdFx0XHRcdFx0XHRzb3VyY2UgPSByZXM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vICQud2hlbihzb3VyY2UpIHJlc29sdmVzIGFsc28gZm9yIG5vbi1kZWZlcnJlZHNcblx0XHRcdFx0cmV0dXJuICQud2hlbihzb3VyY2UpLmRvbmUoZnVuY3Rpb24oY2hpbGRyZW4pIHtcblx0XHRcdFx0XHR2YXIgbWV0YURhdGEsIG5vRGF0YVJlcztcblxuXHRcdFx0XHRcdGlmICgkLmlzUGxhaW5PYmplY3QoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdFx0XHQvLyBXZSBnb3Qge2ZvbzogJ2FiYycsIGNoaWxkcmVuOiBbLi4uXX1cblx0XHRcdFx0XHRcdC8vIENvcHkgZXh0cmEgcHJvcGVydGllcyB0byB0cmVlLmRhdGEuZm9vXG5cdFx0XHRcdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHRcdFx0XHRub2RlLmlzUm9vdE5vZGUoKSxcblx0XHRcdFx0XHRcdFx0XCJzb3VyY2UgbWF5IG9ubHkgYmUgYW4gb2JqZWN0IGZvciByb290IG5vZGVzIChleHBlY3RpbmcgYW4gYXJyYXkgb2YgY2hpbGQgb2JqZWN0cyBvdGhlcndpc2UpXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHRcdFx0XHQkLmlzQXJyYXkoY2hpbGRyZW4uY2hpbGRyZW4pLFxuXHRcdFx0XHRcdFx0XHRcImlmIGFuIG9iamVjdCBpcyBwYXNzZWQgYXMgc291cmNlLCBpdCBtdXN0IGNvbnRhaW4gYSAnY2hpbGRyZW4nIGFycmF5IChhbGwgb3RoZXIgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gJ3RyZWUuZGF0YScpXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRtZXRhRGF0YSA9IGNoaWxkcmVuO1xuXHRcdFx0XHRcdFx0Y2hpbGRyZW4gPSBjaGlsZHJlbi5jaGlsZHJlbjtcblx0XHRcdFx0XHRcdGRlbGV0ZSBtZXRhRGF0YS5jaGlsZHJlbjtcblx0XHRcdFx0XHRcdC8vIENvcHkgc29tZSBhdHRyaWJ1dGVzIHRvIHRyZWUuZGF0YVxuXHRcdFx0XHRcdFx0JC5lYWNoKFRSRUVfQVRUUlMsIGZ1bmN0aW9uKGksIGF0dHIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG1ldGFEYXRhW2F0dHJdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHR0cmVlW2F0dHJdID0gbWV0YURhdGFbYXR0cl07XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG1ldGFEYXRhW2F0dHJdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdC8vIENvcHkgYWxsIG90aGVyIGF0dHJpYnV0ZXMgdG8gdHJlZS5kYXRhLk5BTUVcblx0XHRcdFx0XHRcdCQuZXh0ZW5kKHRyZWUuZGF0YSwgbWV0YURhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRfYXNzZXJ0KCQuaXNBcnJheShjaGlsZHJlbiksIFwiZXhwZWN0ZWQgYXJyYXkgb2YgY2hpbGRyZW5cIik7XG5cdFx0XHRcdFx0bm9kZS5fc2V0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuXG5cdFx0XHRcdFx0aWYgKHRyZWUub3B0aW9ucy5ub2RhdGEgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRyZWUub3B0aW9ucy5ub2RhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdG5vRGF0YVJlcyA9IHRyZWUub3B0aW9ucy5ub2RhdGEuY2FsbChcblx0XHRcdFx0XHRcdFx0XHR0cmVlLFxuXHRcdFx0XHRcdFx0XHRcdHsgdHlwZTogXCJub2RhdGFcIiB9LFxuXHRcdFx0XHRcdFx0XHRcdGN0eFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRcdFx0dHJlZS5vcHRpb25zLm5vZGF0YSA9PT0gdHJ1ZSAmJlxuXHRcdFx0XHRcdFx0XHRub2RlLmlzUm9vdE5vZGUoKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdG5vRGF0YVJlcyA9IHRyZWUub3B0aW9ucy5zdHJpbmdzLm5vZGF0YTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdHR5cGVvZiB0cmVlLm9wdGlvbnMubm9kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdFx0XHRcdG5vZGUuaXNSb290Tm9kZSgpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0bm9EYXRhUmVzID0gdHJlZS5vcHRpb25zLm5vZGF0YTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChub0RhdGFSZXMpIHtcblx0XHRcdFx0XHRcdFx0bm9kZS5zZXRTdGF0dXMoXCJub2RhdGFcIiwgbm9EYXRhUmVzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gdHJpZ2dlciBmYW5jeXRyZWVsb2FkY2hpbGRyZW5cblx0XHRcdFx0XHR0cmVlLl90cmlnZ2VyTm9kZUV2ZW50KFwibG9hZENoaWxkcmVuXCIsIG5vZGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvKiogW05vdCBJbXBsZW1lbnRlZF0gICovXG5cdFx0XHRub2RlTG9hZEtleVBhdGg6IGZ1bmN0aW9uKGN0eCwga2V5UGF0aExpc3QpIHtcblx0XHRcdFx0Ly8gVE9ETzogaW1wbGVtZW50IGFuZCBpbXByb3ZlXG5cdFx0XHRcdC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9keW5hdHJlZS9pc3N1ZXMvZGV0YWlsP2lkPTIyMlxuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogUmVtb3ZlIGEgc2luZ2xlIGRpcmVjdCBjaGlsZCBvZiBjdHgubm9kZS5cblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gY2hpbGROb2RlIGRpcmNlY3QgY2hpbGQgb2YgY3R4Lm5vZGVcblx0XHRcdCAqL1xuXHRcdFx0bm9kZVJlbW92ZUNoaWxkOiBmdW5jdGlvbihjdHgsIGNoaWxkTm9kZSkge1xuXHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdG5vZGUgPSBjdHgubm9kZSxcblx0XHRcdFx0XHQvLyBvcHRzID0gY3R4Lm9wdGlvbnMsXG5cdFx0XHRcdFx0c3ViQ3R4ID0gJC5leHRlbmQoe30sIGN0eCwgeyBub2RlOiBjaGlsZE5vZGUgfSksXG5cdFx0XHRcdFx0Y2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG5cdFx0XHRcdC8vIEZULmRlYnVnKFwibm9kZVJlbW92ZUNoaWxkKClcIiwgbm9kZS50b1N0cmluZygpLCBjaGlsZE5vZGUudG9TdHJpbmcoKSk7XG5cblx0XHRcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdF9hc3NlcnQoY2hpbGROb2RlID09PSBjaGlsZHJlblswXSwgXCJpbnZhbGlkIHNpbmdsZSBjaGlsZFwiKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlUmVtb3ZlQ2hpbGRyZW4oY3R4KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5hY3RpdmVOb2RlICYmXG5cdFx0XHRcdFx0KGNoaWxkTm9kZSA9PT0gdGhpcy5hY3RpdmVOb2RlIHx8XG5cdFx0XHRcdFx0XHR0aGlzLmFjdGl2ZU5vZGUuaXNEZXNjZW5kYW50T2YoY2hpbGROb2RlKSlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5hY3RpdmVOb2RlLnNldEFjdGl2ZShmYWxzZSk7IC8vIFRPRE86IGRvbid0IGZpcmUgZXZlbnRzXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuZm9jdXNOb2RlICYmXG5cdFx0XHRcdFx0KGNoaWxkTm9kZSA9PT0gdGhpcy5mb2N1c05vZGUgfHxcblx0XHRcdFx0XHRcdHRoaXMuZm9jdXNOb2RlLmlzRGVzY2VuZGFudE9mKGNoaWxkTm9kZSkpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPOiBwZXJzaXN0IG11c3QgdGFrZSBjYXJlIHRvIGNsZWFyIHNlbGVjdCBhbmQgZXhwYW5kIGNvb2tpZXNcblx0XHRcdFx0dGhpcy5ub2RlUmVtb3ZlTWFya3VwKHN1YkN0eCk7XG5cdFx0XHRcdHRoaXMubm9kZVJlbW92ZUNoaWxkcmVuKHN1YkN0eCk7XG5cdFx0XHRcdGlkeCA9ICQuaW5BcnJheShjaGlsZE5vZGUsIGNoaWxkcmVuKTtcblx0XHRcdFx0X2Fzc2VydChpZHggPj0gMCwgXCJpbnZhbGlkIGNoaWxkXCIpO1xuXHRcdFx0XHQvLyBOb3RpZnkgbGlzdGVuZXJzXG5cdFx0XHRcdG5vZGUudHJpZ2dlck1vZGlmeUNoaWxkKFwicmVtb3ZlXCIsIGNoaWxkTm9kZSk7XG5cdFx0XHRcdC8vIFVubGluayB0byBzdXBwb3J0IEdDXG5cdFx0XHRcdGNoaWxkTm9kZS52aXNpdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdFx0bi5wYXJlbnQgPSBudWxsO1xuXHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0dGhpcy5fY2FsbEhvb2soXCJ0cmVlUmVnaXN0ZXJOb2RlXCIsIHRoaXMsIGZhbHNlLCBjaGlsZE5vZGUpO1xuXHRcdFx0XHQvLyByZW1vdmUgZnJvbSBjaGlsZCBsaXN0XG5cdFx0XHRcdGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0fSxcblx0XHRcdC8qKlJlbW92ZSBIVE1MIG1hcmt1cCBmb3IgYWxsIGRlc2NlbmRlbnRzIG9mIGN0eC5ub2RlLlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICovXG5cdFx0XHRub2RlUmVtb3ZlQ2hpbGRNYXJrdXA6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IGN0eC5ub2RlO1xuXG5cdFx0XHRcdC8vIEZULmRlYnVnKFwibm9kZVJlbW92ZUNoaWxkTWFya3VwKClcIiwgbm9kZS50b1N0cmluZygpKTtcblx0XHRcdFx0Ly8gVE9ETzogVW5saW5rIGF0dHIuZnRub2RlIHRvIHN1cHBvcnQgR0Ncblx0XHRcdFx0aWYgKG5vZGUudWwpIHtcblx0XHRcdFx0XHRpZiAobm9kZS5pc1Jvb3ROb2RlKCkpIHtcblx0XHRcdFx0XHRcdCQobm9kZS51bCkuZW1wdHkoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JChub2RlLnVsKS5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdG5vZGUudWwgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlLnZpc2l0KGZ1bmN0aW9uKG4pIHtcblx0XHRcdFx0XHRcdG4ubGkgPSBuLnVsID0gbnVsbDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKlJlbW92ZSBhbGwgZGVzY2VuZGFudHMgb2YgY3R4Lm5vZGUuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKi9cblx0XHRcdG5vZGVSZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRcdHZhciAvL3N1YkN0eCxcblx0XHRcdFx0XHR0cmVlID0gY3R4LnRyZWUsXG5cdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblx0XHRcdFx0Ly8gb3B0cyA9IGN0eC5vcHRpb25zO1xuXG5cdFx0XHRcdC8vIEZULmRlYnVnKFwibm9kZVJlbW92ZUNoaWxkcmVuKClcIiwgbm9kZS50b1N0cmluZygpKTtcblx0XHRcdFx0aWYgKCFjaGlsZHJlbikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5hY3RpdmVOb2RlICYmIHRoaXMuYWN0aXZlTm9kZS5pc0Rlc2NlbmRhbnRPZihub2RlKSkge1xuXHRcdFx0XHRcdHRoaXMuYWN0aXZlTm9kZS5zZXRBY3RpdmUoZmFsc2UpOyAvLyBUT0RPOiBkb24ndCBmaXJlIGV2ZW50c1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLmZvY3VzTm9kZSAmJiB0aGlzLmZvY3VzTm9kZS5pc0Rlc2NlbmRhbnRPZihub2RlKSkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPOiBwZXJzaXN0IG11c3QgdGFrZSBjYXJlIHRvIGNsZWFyIHNlbGVjdCBhbmQgZXhwYW5kIGNvb2tpZXNcblx0XHRcdFx0dGhpcy5ub2RlUmVtb3ZlQ2hpbGRNYXJrdXAoY3R4KTtcblx0XHRcdFx0Ly8gVW5saW5rIGNoaWxkcmVuIHRvIHN1cHBvcnQgR0Ncblx0XHRcdFx0Ly8gVE9ETzogYWxzbyBkZWxldGUgdGhpcy5jaGlsZHJlbiAobm90IHBvc3NpYmxlIHVzaW5nIHZpc2l0KCkpXG5cdFx0XHRcdC8vIHN1YkN0eCA9ICQuZXh0ZW5kKHt9LCBjdHgpO1xuXHRcdFx0XHRub2RlLnRyaWdnZXJNb2RpZnlDaGlsZChcInJlbW92ZVwiLCBudWxsKTtcblx0XHRcdFx0bm9kZS52aXNpdChmdW5jdGlvbihuKSB7XG5cdFx0XHRcdFx0bi5wYXJlbnQgPSBudWxsO1xuXHRcdFx0XHRcdHRyZWUuX2NhbGxIb29rKFwidHJlZVJlZ2lzdGVyTm9kZVwiLCB0cmVlLCBmYWxzZSwgbik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAobm9kZS5sYXp5KSB7XG5cdFx0XHRcdFx0Ly8gJ3VuZGVmaW5lZCcgd291bGQgYmUgaW50ZXJwcmV0ZWQgYXMgJ25vdCB5ZXQgbG9hZGVkJyBmb3IgbGF6eSBub2Rlc1xuXHRcdFx0XHRcdG5vZGUuY2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLmNoaWxkcmVuID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIW5vZGUuaXNSb290Tm9kZSgpKSB7XG5cdFx0XHRcdFx0bm9kZS5leHBhbmRlZCA9IGZhbHNlOyAvLyAjNDQ5LCAjNDU5XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ub2RlUmVuZGVyU3RhdHVzKGN0eCk7XG5cdFx0XHR9LFxuXHRcdFx0LyoqUmVtb3ZlIEhUTUwgbWFya3VwIGZvciBjdHgubm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kZW50cy5cblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqL1xuXHRcdFx0bm9kZVJlbW92ZU1hcmt1cDogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRcdHZhciBub2RlID0gY3R4Lm5vZGU7XG5cdFx0XHRcdC8vIEZULmRlYnVnKFwibm9kZVJlbW92ZU1hcmt1cCgpXCIsIG5vZGUudG9TdHJpbmcoKSk7XG5cdFx0XHRcdC8vIFRPRE86IFVubGluayBhdHRyLmZ0bm9kZSB0byBzdXBwb3J0IEdDXG5cdFx0XHRcdGlmIChub2RlLmxpKSB7XG5cdFx0XHRcdFx0JChub2RlLmxpKS5yZW1vdmUoKTtcblx0XHRcdFx0XHRub2RlLmxpID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm5vZGVSZW1vdmVDaGlsZE1hcmt1cChjdHgpO1xuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlIGA8bGk+PHNwYW4+Li48L3NwYW4+IC4uIDwvbGk+YCB0YWdzIGZvciB0aGlzIG5vZGUuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBtZXRob2QgdGFrZXMgY2FyZSB0aGF0IGFsbCBIVE1MIG1hcmt1cCBpcyBjcmVhdGVkIHRoYXQgaXMgcmVxdWlyZWRcblx0XHRcdCAqIHRvIGRpc3BsYXkgdGhpcyBub2RlIGluIGl0cyBjdXJyZW50IHN0YXRlLlxuXHRcdFx0ICpcblx0XHRcdCAqIENhbGwgdGhpcyBtZXRob2QgdG8gY3JlYXRlIG5ldyBub2Rlcywgb3IgYWZ0ZXIgdGhlIHN0cnVjdXR1cmVcblx0XHRcdCAqIHdhcyBjaGFuZ2VkIChlLmcuIGFmdGVyIG1vdmluZyB0aGlzIG5vZGUgb3IgYWRkaW5nL3JlbW92aW5nIGNoaWxkcmVuKVxuXHRcdFx0ICogbm9kZVJlbmRlclRpdGxlKCkgYW5kIG5vZGVSZW5kZXJTdGF0dXMoKSBhcmUgaW1wbGllZC5cblx0XHRcdCAqIGBgYGh0bWxcblx0XHRcdCAqIDxsaSBpZD0nS0VZJyBmdG5vZGU9Tk9ERT5cblx0XHRcdCAqICAgICA8c3BhbiBjbGFzcz0nZmFuY3l0cmVlLW5vZGUgZmFuY3l0cmVlLWV4cGFuZGVkIGZhbmN5dHJlZS1oYXMtY2hpbGRyZW4gZmFuY3l0cmVlLWxhc3RzaWIgZmFuY3l0cmVlLWV4cC1lbCBmYW5jeXRyZWUtaWNvLWUnPlxuXHRcdFx0ICogICAgICAgICA8c3BhbiBjbGFzcz1cImZhbmN5dHJlZS1leHBhbmRlclwiPjwvc3Bhbj5cblx0XHRcdCAqICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYW5jeXRyZWUtY2hlY2tib3hcIj48L3NwYW4+IC8vIG9ubHkgcHJlc2VudCBpbiBjaGVja2JveCBtb2RlXG5cdFx0XHQgKiAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFuY3l0cmVlLWljb25cIj48L3NwYW4+XG5cdFx0XHQgKiAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJmYW5jeXRyZWUtdGl0bGVcIj4gTm9kZSAxIDwvYT5cblx0XHRcdCAqICAgICA8L3NwYW4+XG5cdFx0XHQgKiAgICAgPHVsPiAvLyBvbmx5IHByZXNlbnQgaWYgbm9kZSBoYXMgY2hpbGRyZW5cblx0XHRcdCAqICAgICAgICAgPGxpIGlkPSdLRVknIGZ0bm9kZT1OT0RFPiBjaGlsZDEgLi4uIDwvbGk+XG5cdFx0XHQgKiAgICAgICAgIDxsaSBpZD0nS0VZJyBmdG5vZGU9Tk9ERT4gY2hpbGQyIC4uLiA8L2xpPlxuXHRcdFx0ICogICAgIDwvdWw+XG5cdFx0XHQgKiA8L2xpPlxuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIHJlLXJlbmRlciwgZXZlbiBpZiBodG1sIG1hcmt1cCB3YXMgYWxyZWFkeSBjcmVhdGVkXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWVwPWZhbHNlXSBhbHNvIHJlbmRlciBhbGwgZGVzY2VuZGFudHMsIGV2ZW4gaWYgcGFyZW50IGlzIGNvbGxhcHNlZFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBbY29sbGFwc2VkPWZhbHNlXSBmb3JjZSByb290IG5vZGUgdG8gYmUgY29sbGFwc2VkLCBzbyB3ZSBjYW4gYXBwbHkgYW5pbWF0ZWQgZXhwYW5kIGxhdGVyXG5cdFx0XHQgKi9cblx0XHRcdG5vZGVSZW5kZXI6IGZ1bmN0aW9uKGN0eCwgZm9yY2UsIGRlZXAsIGNvbGxhcHNlZCwgX3JlY3Vyc2l2ZSkge1xuXHRcdFx0XHQvKiBUaGlzIG1ldGhvZCBtdXN0IHRha2UgY2FyZSBvZiBhbGwgY2FzZXMgd2hlcmUgdGhlIGN1cnJlbnQgZGF0YSBtb2RlXG5cdFx0XHRcdCAqIChpLmUuIG5vZGUgaGllcmFyY2h5KSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBtYXJrdXAuXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIC0gbm9kZSB3YXMgbm90IHlldCByZW5kZXJlZDpcblx0XHRcdFx0ICogICBjcmVhdGUgbWFya3VwXG5cdFx0XHRcdCAqIC0gbm9kZSB3YXMgcmVuZGVyZWQ6IGV4aXQgZmFzdFxuXHRcdFx0XHQgKiAtIGNoaWxkcmVuIGhhdmUgYmVlbiBhZGRlZFxuXHRcdFx0XHQgKiAtIGNoaWxkcmVuIGhhdmUgYmVlbiByZW1vdmVkXG5cdFx0XHRcdCAqL1xuXHRcdFx0XHR2YXIgY2hpbGRMSSxcblx0XHRcdFx0XHRjaGlsZE5vZGUxLFxuXHRcdFx0XHRcdGNoaWxkTm9kZTIsXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRsLFxuXHRcdFx0XHRcdG5leHQsXG5cdFx0XHRcdFx0c3ViQ3R4LFxuXHRcdFx0XHRcdG5vZGUgPSBjdHgubm9kZSxcblx0XHRcdFx0XHR0cmVlID0gY3R4LnRyZWUsXG5cdFx0XHRcdFx0b3B0cyA9IGN0eC5vcHRpb25zLFxuXHRcdFx0XHRcdGFyaWEgPSBvcHRzLmFyaWEsXG5cdFx0XHRcdFx0Zmlyc3RUaW1lID0gZmFsc2UsXG5cdFx0XHRcdFx0cGFyZW50ID0gbm9kZS5wYXJlbnQsXG5cdFx0XHRcdFx0aXNSb290Tm9kZSA9ICFwYXJlbnQsXG5cdFx0XHRcdFx0Y2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuXHRcdFx0XHRcdHN1Y2Nlc3NvckxpID0gbnVsbDtcblx0XHRcdFx0Ly8gRlQuZGVidWcoXCJub2RlUmVuZGVyKFwiICsgISFmb3JjZSArIFwiLCBcIiArICEhZGVlcCArIFwiKVwiLCBub2RlLnRvU3RyaW5nKCkpO1xuXG5cdFx0XHRcdGlmICh0cmVlLl9lbmFibGVVcGRhdGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gdHJlZS5kZWJ1ZyhcIm5vIHJlbmRlclwiLCB0cmVlLl9lbmFibGVVcGRhdGUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWlzUm9vdE5vZGUgJiYgIXBhcmVudC51bCkge1xuXHRcdFx0XHRcdC8vIENhbGxpbmcgbm9kZS5jb2xsYXBzZSBvbiBhIGRlZXAsIHVucmVuZGVyZWQgbm9kZVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRfYXNzZXJ0KGlzUm9vdE5vZGUgfHwgcGFyZW50LnVsLCBcInBhcmVudCBVTCBtdXN0IGV4aXN0XCIpO1xuXG5cdFx0XHRcdC8vIFJlbmRlciB0aGUgbm9kZVxuXHRcdFx0XHRpZiAoIWlzUm9vdE5vZGUpIHtcblx0XHRcdFx0XHQvLyBEaXNjYXJkIG1hcmt1cCBvbiBmb3JjZS1tb2RlLCBvciBpZiBpdCBpcyBub3QgbGlua2VkIHRvIHBhcmVudCA8dWw+XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0bm9kZS5saSAmJlxuXHRcdFx0XHRcdFx0KGZvcmNlIHx8IG5vZGUubGkucGFyZW50Tm9kZSAhPT0gbm9kZS5wYXJlbnQudWwpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRpZiAobm9kZS5saS5wYXJlbnROb2RlID09PSBub2RlLnBhcmVudC51bCkge1xuXHRcdFx0XHRcdFx0XHQvLyAjNDg2OiBzdG9yZSBmb2xsb3dpbmcgbm9kZSwgc28gd2UgY2FuIGluc2VydCB0aGUgbmV3IG1hcmt1cCB0aGVyZSBsYXRlclxuXHRcdFx0XHRcdFx0XHRzdWNjZXNzb3JMaSA9IG5vZGUubGkubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBNYXkgaGFwcGVuLCB3aGVuIGEgdG9wLWxldmVsIG5vZGUgd2FzIGRyb3BwZWQgb3ZlciBhbm90aGVyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVidWcoXG5cdFx0XHRcdFx0XHRcdFx0XCJVbmxpbmtpbmcgXCIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9kZSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIiAobXVzdCBiZSBjaGlsZCBvZiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0XHRub2RlLnBhcmVudCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIilcIlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly9cdCAgICAgICAgICAgIHRoaXMuZGVidWcoXCJub2RlUmVtb3ZlTWFya3VwLi4uXCIpO1xuXHRcdFx0XHRcdFx0dGhpcy5ub2RlUmVtb3ZlTWFya3VwKGN0eCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIENyZWF0ZSA8bGk+PHNwYW4gLz4gPC9saT5cblx0XHRcdFx0XHQvLyBub2RlLmRlYnVnKFwicmVuZGVyLi4uXCIpO1xuXHRcdFx0XHRcdGlmIChub2RlLmxpKSB7XG5cdFx0XHRcdFx0XHQvLyB0aGlzLm5vZGVSZW5kZXJUaXRsZShjdHgpO1xuXHRcdFx0XHRcdFx0dGhpcy5ub2RlUmVuZGVyU3RhdHVzKGN0eCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIG5vZGUuZGVidWcoXCJyZW5kZXIuLi4gcmVhbGx5XCIpO1xuXHRcdFx0XHRcdFx0Zmlyc3RUaW1lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdG5vZGUubGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG5cdFx0XHRcdFx0XHRub2RlLmxpLmZ0bm9kZSA9IG5vZGU7XG5cblx0XHRcdFx0XHRcdGlmIChub2RlLmtleSAmJiBvcHRzLmdlbmVyYXRlSWRzKSB7XG5cdFx0XHRcdFx0XHRcdG5vZGUubGkuaWQgPSBvcHRzLmlkUHJlZml4ICsgbm9kZS5rZXk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRub2RlLnNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblx0XHRcdFx0XHRcdG5vZGUuc3Bhbi5jbGFzc05hbWUgPSBcImZhbmN5dHJlZS1ub2RlXCI7XG5cdFx0XHRcdFx0XHRpZiAoYXJpYSAmJiAhbm9kZS50cikge1xuXHRcdFx0XHRcdFx0XHQkKG5vZGUubGkpLmF0dHIoXCJyb2xlXCIsIFwidHJlZWl0ZW1cIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRub2RlLmxpLmFwcGVuZENoaWxkKG5vZGUuc3Bhbik7XG5cblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBpbm5lciBIVE1MIGZvciB0aGUgPHNwYW4+IChleHBhbmRlciwgY2hlY2tib3gsIGljb24sIGFuZCB0aXRsZSlcblx0XHRcdFx0XHRcdHRoaXMubm9kZVJlbmRlclRpdGxlKGN0eCk7XG5cblx0XHRcdFx0XHRcdC8vIEFsbG93IHR3ZWFraW5nIGFuZCBiaW5kaW5nLCBhZnRlciBub2RlIHdhcyBjcmVhdGVkIGZvciB0aGUgZmlyc3QgdGltZVxuXHRcdFx0XHRcdFx0aWYgKG9wdHMuY3JlYXRlTm9kZSkge1xuXHRcdFx0XHRcdFx0XHRvcHRzLmNyZWF0ZU5vZGUuY2FsbChcblx0XHRcdFx0XHRcdFx0XHR0cmVlLFxuXHRcdFx0XHRcdFx0XHRcdHsgdHlwZTogXCJjcmVhdGVOb2RlXCIgfSxcblx0XHRcdFx0XHRcdFx0XHRjdHhcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQWxsb3cgdHdlYWtpbmcgYWZ0ZXIgbm9kZSBzdGF0ZSB3YXMgcmVuZGVyZWRcblx0XHRcdFx0XHRpZiAob3B0cy5yZW5kZXJOb2RlKSB7XG5cdFx0XHRcdFx0XHRvcHRzLnJlbmRlck5vZGUuY2FsbCh0cmVlLCB7IHR5cGU6IFwicmVuZGVyTm9kZVwiIH0sIGN0eCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVmlzaXQgY2hpbGQgbm9kZXNcblx0XHRcdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0aWYgKGlzUm9vdE5vZGUgfHwgbm9kZS5leHBhbmRlZCB8fCBkZWVwID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHQvLyBDcmVhdGUgYSBVTCB0byBob2xkIHRoZSBjaGlsZHJlblxuXHRcdFx0XHRcdFx0aWYgKCFub2RlLnVsKSB7XG5cdFx0XHRcdFx0XHRcdG5vZGUudWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG5cdFx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0XHQoY29sbGFwc2VkID09PSB0cnVlICYmICFfcmVjdXJzaXZlKSB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlLmV4cGFuZGVkXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGhpZGUgdG9wIFVMLCBzbyB3ZSBjYW4gdXNlIGFuIGFuaW1hdGlvbiB0byBzaG93IGl0IGxhdGVyXG5cdFx0XHRcdFx0XHRcdFx0bm9kZS51bC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKGFyaWEpIHtcblx0XHRcdFx0XHRcdFx0XHQkKG5vZGUudWwpLmF0dHIoXCJyb2xlXCIsIFwiZ3JvdXBcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKG5vZGUubGkpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBpc3N1ZSAjNjdcblx0XHRcdFx0XHRcdFx0XHRub2RlLmxpLmFwcGVuZENoaWxkKG5vZGUudWwpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUudHJlZS4kZGl2LmFwcGVuZChub2RlLnVsKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gQWRkIGNoaWxkIG1hcmt1cFxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRzdWJDdHggPSAkLmV4dGVuZCh7fSwgY3R4LCB7IG5vZGU6IGNoaWxkcmVuW2ldIH0pO1xuXHRcdFx0XHRcdFx0XHR0aGlzLm5vZGVSZW5kZXIoc3ViQ3R4LCBmb3JjZSwgZGVlcCwgZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIDxsaT4gaWYgbm9kZXMgaGF2ZSBtb3ZlZCB0byBhbm90aGVyIHBhcmVudFxuXHRcdFx0XHRcdFx0Y2hpbGRMSSA9IG5vZGUudWwuZmlyc3RDaGlsZDtcblx0XHRcdFx0XHRcdHdoaWxlIChjaGlsZExJKSB7XG5cdFx0XHRcdFx0XHRcdGNoaWxkTm9kZTIgPSBjaGlsZExJLmZ0bm9kZTtcblx0XHRcdFx0XHRcdFx0aWYgKGNoaWxkTm9kZTIgJiYgY2hpbGROb2RlMi5wYXJlbnQgIT09IG5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlLmRlYnVnKFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJfZml4UGFyZW50OiByZW1vdmUgbWlzc2luZyBcIiArIGNoaWxkTm9kZTIsXG5cdFx0XHRcdFx0XHRcdFx0XHRjaGlsZExJXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRuZXh0ID0gY2hpbGRMSS5uZXh0U2libGluZztcblx0XHRcdFx0XHRcdFx0XHRjaGlsZExJLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGRMSSk7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRMSSA9IG5leHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRMSSA9IGNoaWxkTEkubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSwgdGhhdCA8bGk+IG9yZGVyIG1hdGNoZXMgbm9kZS5jaGlsZHJlbiBvcmRlci5cblx0XHRcdFx0XHRcdGNoaWxkTEkgPSBub2RlLnVsLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdFx0XHRmb3IgKGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRjaGlsZE5vZGUxID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdFx0XHRcdGNoaWxkTm9kZTIgPSBjaGlsZExJLmZ0bm9kZTtcblx0XHRcdFx0XHRcdFx0aWYgKGNoaWxkTm9kZTEgPT09IGNoaWxkTm9kZTIpIHtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZExJID0gY2hpbGRMSS5uZXh0U2libGluZztcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBub2RlLmRlYnVnKFwiX2ZpeE9yZGVyOiBtaXNtYXRjaCBhdCBpbmRleCBcIiArIGkgKyBcIjogXCIgKyBjaGlsZE5vZGUxICsgXCIgIT0gXCIgKyBjaGlsZE5vZGUyKTtcblx0XHRcdFx0XHRcdFx0XHRub2RlLnVsLmluc2VydEJlZm9yZShcblx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkTm9kZTEubGksXG5cdFx0XHRcdFx0XHRcdFx0XHRjaGlsZE5vZGUyLmxpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBObyBjaGlsZHJlbjogcmVtb3ZlIG1hcmt1cCBpZiBhbnlcblx0XHRcdFx0XHRpZiAobm9kZS51bCkge1xuXHRcdFx0XHRcdFx0Ly8gYWxlcnQoXCJyZW1vdmUgY2hpbGQgbWFya3VwIGZvciBcIiArIG5vZGUpO1xuXHRcdFx0XHRcdFx0dGhpcy53YXJuKFwicmVtb3ZlIGNoaWxkIG1hcmt1cCBmb3IgXCIgKyBub2RlKTtcblx0XHRcdFx0XHRcdHRoaXMubm9kZVJlbW92ZUNoaWxkTWFya3VwKGN0eCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghaXNSb290Tm9kZSkge1xuXHRcdFx0XHRcdC8vIFVwZGF0ZSBlbGVtZW50IGNsYXNzZXMgYWNjb3JkaW5nIHRvIG5vZGUgc3RhdGVcblx0XHRcdFx0XHQvLyB0aGlzLm5vZGVSZW5kZXJTdGF0dXMoY3R4KTtcblx0XHRcdFx0XHQvLyBGaW5hbGx5IGFkZCB0aGUgd2hvbGUgc3RydWN0dXJlIHRvIHRoZSBET00sIHNvIHRoZSBicm93c2VyIGNhbiByZW5kZXJcblx0XHRcdFx0XHRpZiAoZmlyc3RUaW1lKSB7XG5cdFx0XHRcdFx0XHQvLyAjNDg2OiBzdWNjZXNzb3JMaSBpcyBzZXQsIGlmIHdlIHJlLXJlbmRlcmVkIChpLmUuIGRpc2NhcmRlZClcblx0XHRcdFx0XHRcdC8vIGV4aXN0aW5nIG1hcmt1cCwgd2hpY2ggIHdlIHdhbnQgdG8gaW5zZXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuXHRcdFx0XHRcdFx0Ly8gKG51bGwgaXMgZXF1aXZhbGVudCB0byBhcHBlbmQpXG5cdFx0XHRcdFx0XHQvLyBcdFx0cGFyZW50LnVsLmFwcGVuZENoaWxkKG5vZGUubGkpO1xuXHRcdFx0XHRcdFx0cGFyZW50LnVsLmluc2VydEJlZm9yZShub2RlLmxpLCBzdWNjZXNzb3JMaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIENyZWF0ZSBIVE1MIGluc2lkZSB0aGUgbm9kZSdzIG91dGVyIGA8c3Bhbj5gIChpLmUuIGV4cGFuZGVyLCBjaGVja2JveCxcblx0XHRcdCAqIGljb24sIGFuZCB0aXRsZSkuXG5cdFx0XHQgKlxuXHRcdFx0ICogbm9kZVJlbmRlclN0YXR1cygpIGlzIGltcGxpZWQuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW3RpdGxlXSBvcHRpbmFsIG5ldyB0aXRsZVxuXHRcdFx0ICovXG5cdFx0XHRub2RlUmVuZGVyVGl0bGU6IGZ1bmN0aW9uKGN0eCwgdGl0bGUpIHtcblx0XHRcdFx0Ly8gc2V0IG5vZGUgY29ubmVjdG9yIGltYWdlcywgbGlua3MgYW5kIHRleHRcblx0XHRcdFx0dmFyIGNoZWNrYm94LFxuXHRcdFx0XHRcdGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpY29uLFxuXHRcdFx0XHRcdG5vZGVUaXRsZSxcblx0XHRcdFx0XHRyb2xlLFxuXHRcdFx0XHRcdHRhYmluZGV4LFxuXHRcdFx0XHRcdHRvb2x0aXAsXG5cdFx0XHRcdFx0aWNvblRvb2x0aXAsXG5cdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdHRyZWUgPSBjdHgudHJlZSxcblx0XHRcdFx0XHRvcHRzID0gY3R4Lm9wdGlvbnMsXG5cdFx0XHRcdFx0YXJpYSA9IG9wdHMuYXJpYSxcblx0XHRcdFx0XHRsZXZlbCA9IG5vZGUuZ2V0TGV2ZWwoKSxcblx0XHRcdFx0XHRhcmVzID0gW107XG5cblx0XHRcdFx0aWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRub2RlLnRpdGxlID0gdGl0bGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFub2RlLnNwYW4gfHwgdHJlZS5fZW5hYmxlVXBkYXRlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIFNpbGVudGx5IGJhaWwgb3V0IGlmIG5vZGUgd2FzIG5vdCByZW5kZXJlZCB5ZXQsIGFzc3VtaW5nXG5cdFx0XHRcdFx0Ly8gbm9kZS5yZW5kZXIoKSB3aWxsIGJlIGNhbGxlZCBhcyB0aGUgbm9kZSBiZWNvbWVzIHZpc2libGVcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ29ubmVjdG9yIChleHBhbmRlZCwgZXhwYW5kYWJsZSBvciBzaW1wbGUpXG5cdFx0XHRcdHJvbGUgPVxuXHRcdFx0XHRcdGFyaWEgJiYgbm9kZS5oYXNDaGlsZHJlbigpICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0PyBcIiByb2xlPSdidXR0b24nXCJcblx0XHRcdFx0XHRcdDogXCJcIjtcblx0XHRcdFx0aWYgKGxldmVsIDwgb3B0cy5taW5FeHBhbmRMZXZlbCkge1xuXHRcdFx0XHRcdGlmICghbm9kZS5sYXp5KSB7XG5cdFx0XHRcdFx0XHRub2RlLmV4cGFuZGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxldmVsID4gMSkge1xuXHRcdFx0XHRcdFx0YXJlcy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcIjxzcGFuIFwiICtcblx0XHRcdFx0XHRcdFx0XHRyb2xlICtcblx0XHRcdFx0XHRcdFx0XHRcIiBjbGFzcz0nZmFuY3l0cmVlLWV4cGFuZGVyIGZhbmN5dHJlZS1leHBhbmRlci1maXhlZCc+PC9zcGFuPlwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyAuLiBlbHNlIChpLmUuIGZvciByb290IGxldmVsKSBza2lwIGV4cGFuZGVyL2Nvbm5lY3RvciBhbGx0b2dldGhlclxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFyZXMucHVzaChcblx0XHRcdFx0XHRcdFwiPHNwYW4gXCIgKyByb2xlICsgXCIgY2xhc3M9J2ZhbmN5dHJlZS1leHBhbmRlcic+PC9zcGFuPlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDaGVja2JveCBtb2RlXG5cdFx0XHRcdGNoZWNrYm94ID0gRlQuZXZhbE9wdGlvbihcImNoZWNrYm94XCIsIG5vZGUsIG5vZGUsIG9wdHMsIGZhbHNlKTtcblxuXHRcdFx0XHRpZiAoY2hlY2tib3ggJiYgIW5vZGUuaXNTdGF0dXNOb2RlKCkpIHtcblx0XHRcdFx0XHRyb2xlID0gYXJpYSA/IFwiIHJvbGU9J2NoZWNrYm94J1wiIDogXCJcIjtcblx0XHRcdFx0XHRjbGFzc05hbWUgPSBcImZhbmN5dHJlZS1jaGVja2JveFwiO1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGNoZWNrYm94ID09PSBcInJhZGlvXCIgfHxcblx0XHRcdFx0XHRcdChub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5yYWRpb2dyb3VwKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lICs9IFwiIGZhbmN5dHJlZS1yYWRpb1wiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhcmVzLnB1c2goXG5cdFx0XHRcdFx0XHRcIjxzcGFuIFwiICsgcm9sZSArIFwiIGNsYXNzPSdcIiArIGNsYXNzTmFtZSArIFwiJz48L3NwYW4+XCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEZvbGRlciBvciBkb2N0eXBlIGljb25cblx0XHRcdFx0aWYgKG5vZGUuZGF0YS5pY29uQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIDIwMTUtMTEtMTZcblx0XHRcdFx0XHQvLyBIYW5kbGUgLyB3YXJuIGFib3V0IGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0XHRcdFx0XHRpZiAobm9kZS5pY29uKSB7XG5cdFx0XHRcdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIidpY29uQ2xhc3MnIG5vZGUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuMTQuMDogdXNlICdpY29uJyBvbmx5IGluc3RlYWRcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS53YXJuKFxuXHRcdFx0XHRcdFx0XHRcIidpY29uQ2xhc3MnIG5vZGUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuMTQuMDogdXNlICdpY29uJyBpbnN0ZWFkXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRub2RlLmljb24gPSBub2RlLmRhdGEuaWNvbkNsYXNzO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiBvcHRzLmljb24gaXMgYSBjYWxsYmFjayBhbmQgcmV0dXJucyBzb21ldGhpbmcgb3RoZXIgdGhhbiB1bmRlZmluZWQsIHVzZSB0aGF0XG5cdFx0XHRcdC8vIGVsc2UgaWYgbm9kZS5pY29uIGlzIGEgYm9vbGVhbiBvciBzdHJpbmcsIHVzZSB0aGF0XG5cdFx0XHRcdC8vIGVsc2UgaWYgb3B0cy5pY29uIGlzIGEgYm9vbGVhbiBvciBzdHJpbmcsIHVzZSB0aGF0XG5cdFx0XHRcdC8vIGVsc2Ugc2hvdyBzdGFuZGFyZCBpY29uICh3aGljaCBtYXkgYmUgZGlmZmVyZW50IGZvciBmb2xkZXJzIG9yIGRvY3VtZW50cylcblx0XHRcdFx0aWNvbiA9IEZULmV2YWxPcHRpb24oXCJpY29uXCIsIG5vZGUsIG5vZGUsIG9wdHMsIHRydWUpO1xuXHRcdFx0XHQvLyBpZiggdHlwZW9mIGljb24gIT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHQvLyBcdC8vIGljb24gaXMgZGVmaW5lZCwgYnV0IG5vdCB0cnVlL2ZhbHNlOiBtdXN0IGJlIGEgc3RyaW5nXG5cdFx0XHRcdC8vIFx0aWNvbiA9IFwiXCIgKyBpY29uO1xuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdGlmIChpY29uICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJvbGUgPSBhcmlhID8gXCIgcm9sZT0ncHJlc2VudGF0aW9uJ1wiIDogXCJcIjtcblxuXHRcdFx0XHRcdGljb25Ub29sdGlwID0gRlQuZXZhbE9wdGlvbihcblx0XHRcdFx0XHRcdFwiaWNvblRvb2x0aXBcIixcblx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0b3B0cyxcblx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGljb25Ub29sdGlwID0gaWNvblRvb2x0aXBcblx0XHRcdFx0XHRcdD8gXCIgdGl0bGU9J1wiICsgX2VzY2FwZVRvb2x0aXAoaWNvblRvb2x0aXApICsgXCInXCJcblx0XHRcdFx0XHRcdDogXCJcIjtcblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdFx0aWYgKFRFU1RfSU1HLnRlc3QoaWNvbikpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbm9kZS5pY29uIGlzIGFuIGltYWdlIHVybC4gUHJlcGVuZCBpbWFnZVBhdGhcblx0XHRcdFx0XHRcdFx0aWNvbiA9XG5cdFx0XHRcdFx0XHRcdFx0aWNvbi5jaGFyQXQoMCkgPT09IFwiL1wiXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGljb25cblx0XHRcdFx0XHRcdFx0XHRcdDogKG9wdHMuaW1hZ2VQYXRoIHx8IFwiXCIpICsgaWNvbjtcblx0XHRcdFx0XHRcdFx0YXJlcy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdFwiPGltZyBzcmM9J1wiICtcblx0XHRcdFx0XHRcdFx0XHRcdGljb24gK1xuXHRcdFx0XHRcdFx0XHRcdFx0XCInIGNsYXNzPSdmYW5jeXRyZWUtaWNvbidcIiArXG5cdFx0XHRcdFx0XHRcdFx0XHRpY29uVG9vbHRpcCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIiBhbHQ9JycgLz5cIlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YXJlcy5wdXNoKFxuXHRcdFx0XHRcdFx0XHRcdFwiPHNwYW4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0cm9sZSArXG5cdFx0XHRcdFx0XHRcdFx0XHRcIiBjbGFzcz0nZmFuY3l0cmVlLWN1c3RvbS1pY29uIFwiICtcblx0XHRcdFx0XHRcdFx0XHRcdGljb24gK1xuXHRcdFx0XHRcdFx0XHRcdFx0XCInXCIgK1xuXHRcdFx0XHRcdFx0XHRcdFx0aWNvblRvb2x0aXAgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XCI+PC9zcGFuPlwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpY29uLnRleHQpIHtcblx0XHRcdFx0XHRcdGFyZXMucHVzaChcblx0XHRcdFx0XHRcdFx0XCI8c3BhbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cm9sZSArXG5cdFx0XHRcdFx0XHRcdFx0XCIgY2xhc3M9J2ZhbmN5dHJlZS1jdXN0b20taWNvbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0KGljb24uYWRkQ2xhc3MgfHwgXCJcIikgK1xuXHRcdFx0XHRcdFx0XHRcdFwiJ1wiICtcblx0XHRcdFx0XHRcdFx0XHRpY29uVG9vbHRpcCArXG5cdFx0XHRcdFx0XHRcdFx0XCI+XCIgK1xuXHRcdFx0XHRcdFx0XHRcdEZULmVzY2FwZUh0bWwoaWNvbi50ZXh0KSArXG5cdFx0XHRcdFx0XHRcdFx0XCI8L3NwYW4+XCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpY29uLmh0bWwpIHtcblx0XHRcdFx0XHRcdGFyZXMucHVzaChcblx0XHRcdFx0XHRcdFx0XCI8c3BhbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cm9sZSArXG5cdFx0XHRcdFx0XHRcdFx0XCIgY2xhc3M9J2ZhbmN5dHJlZS1jdXN0b20taWNvbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0KGljb24uYWRkQ2xhc3MgfHwgXCJcIikgK1xuXHRcdFx0XHRcdFx0XHRcdFwiJ1wiICtcblx0XHRcdFx0XHRcdFx0XHRpY29uVG9vbHRpcCArXG5cdFx0XHRcdFx0XHRcdFx0XCI+XCIgK1xuXHRcdFx0XHRcdFx0XHRcdGljb24uaHRtbCArXG5cdFx0XHRcdFx0XHRcdFx0XCI8L3NwYW4+XCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIHN0YW5kYXJkIGljb246IHRoZW1lIGNzcyB3aWxsIHRha2UgY2FyZSBvZiB0aGlzXG5cdFx0XHRcdFx0XHRhcmVzLnB1c2goXG5cdFx0XHRcdFx0XHRcdFwiPHNwYW4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJvbGUgK1xuXHRcdFx0XHRcdFx0XHRcdFwiIGNsYXNzPSdmYW5jeXRyZWUtaWNvbidcIiArXG5cdFx0XHRcdFx0XHRcdFx0aWNvblRvb2x0aXAgK1xuXHRcdFx0XHRcdFx0XHRcdFwiPjwvc3Bhbj5cIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTm9kZSB0aXRsZVxuXHRcdFx0XHRub2RlVGl0bGUgPSBcIlwiO1xuXHRcdFx0XHRpZiAob3B0cy5yZW5kZXJUaXRsZSkge1xuXHRcdFx0XHRcdG5vZGVUaXRsZSA9XG5cdFx0XHRcdFx0XHRvcHRzLnJlbmRlclRpdGxlLmNhbGwoXG5cdFx0XHRcdFx0XHRcdHRyZWUsXG5cdFx0XHRcdFx0XHRcdHsgdHlwZTogXCJyZW5kZXJUaXRsZVwiIH0sXG5cdFx0XHRcdFx0XHRcdGN0eFxuXHRcdFx0XHRcdFx0KSB8fCBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghbm9kZVRpdGxlKSB7XG5cdFx0XHRcdFx0dG9vbHRpcCA9IEZULmV2YWxPcHRpb24oXCJ0b29sdGlwXCIsIG5vZGUsIG5vZGUsIG9wdHMsIG51bGwpO1xuXHRcdFx0XHRcdGlmICh0b29sdGlwID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHR0b29sdGlwID0gbm9kZS50aXRsZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gaWYoIG5vZGUudG9vbHRpcCApIHtcblx0XHRcdFx0XHQvLyBcdHRvb2x0aXAgPSBub2RlLnRvb2x0aXA7XG5cdFx0XHRcdFx0Ly8gfSBlbHNlIGlmICggb3B0cy50b29sdGlwICkge1xuXHRcdFx0XHRcdC8vIFx0dG9vbHRpcCA9IG9wdHMudG9vbHRpcCA9PT0gdHJ1ZSA/IG5vZGUudGl0bGUgOiBvcHRzLnRvb2x0aXAuY2FsbCh0cmVlLCBub2RlKTtcblx0XHRcdFx0XHQvLyB9XG5cdFx0XHRcdFx0dG9vbHRpcCA9IHRvb2x0aXBcblx0XHRcdFx0XHRcdD8gXCIgdGl0bGU9J1wiICsgX2VzY2FwZVRvb2x0aXAodG9vbHRpcCkgKyBcIidcIlxuXHRcdFx0XHRcdFx0OiBcIlwiO1xuXHRcdFx0XHRcdHRhYmluZGV4ID0gb3B0cy50aXRsZXNUYWJiYWJsZSA/IFwiIHRhYmluZGV4PScwJ1wiIDogXCJcIjtcblxuXHRcdFx0XHRcdG5vZGVUaXRsZSA9XG5cdFx0XHRcdFx0XHRcIjxzcGFuIGNsYXNzPSdmYW5jeXRyZWUtdGl0bGUnXCIgK1xuXHRcdFx0XHRcdFx0dG9vbHRpcCArXG5cdFx0XHRcdFx0XHR0YWJpbmRleCArXG5cdFx0XHRcdFx0XHRcIj5cIiArXG5cdFx0XHRcdFx0XHQob3B0cy5lc2NhcGVUaXRsZXNcblx0XHRcdFx0XHRcdFx0PyBGVC5lc2NhcGVIdG1sKG5vZGUudGl0bGUpXG5cdFx0XHRcdFx0XHRcdDogbm9kZS50aXRsZSkgK1xuXHRcdFx0XHRcdFx0XCI8L3NwYW4+XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXJlcy5wdXNoKG5vZGVUaXRsZSk7XG5cdFx0XHRcdC8vIE5vdGU6IHRoaXMgd2lsbCB0cmlnZ2VyIGZvY3Vzb3V0LCBpZiBub2RlIGhhZCB0aGUgZm9jdXNcblx0XHRcdFx0Ly8kKG5vZGUuc3BhbikuaHRtbChhcmVzLmpvaW4oXCJcIikpOyAvLyBpdCB3aWxsIGNsZWFudXAgdGhlIGpRdWVyeSBkYXRhIGN1cnJlbnRseSBhc3NvY2lhdGVkIHdpdGggU1BBTiAoaWYgYW55KSwgYnV0IGl0IGV4ZWN1dGVzIG1vcmUgc2xvd2x5XG5cdFx0XHRcdG5vZGUuc3Bhbi5pbm5lckhUTUwgPSBhcmVzLmpvaW4oXCJcIik7XG5cdFx0XHRcdC8vIFVwZGF0ZSBDU1MgY2xhc3Nlc1xuXHRcdFx0XHR0aGlzLm5vZGVSZW5kZXJTdGF0dXMoY3R4KTtcblx0XHRcdFx0aWYgKG9wdHMuZW5oYW5jZVRpdGxlKSB7XG5cdFx0XHRcdFx0Y3R4LiR0aXRsZSA9ICQoXCI+c3Bhbi5mYW5jeXRyZWUtdGl0bGVcIiwgbm9kZS5zcGFuKTtcblx0XHRcdFx0XHRub2RlVGl0bGUgPVxuXHRcdFx0XHRcdFx0b3B0cy5lbmhhbmNlVGl0bGUuY2FsbChcblx0XHRcdFx0XHRcdFx0dHJlZSxcblx0XHRcdFx0XHRcdFx0eyB0eXBlOiBcImVuaGFuY2VUaXRsZVwiIH0sXG5cdFx0XHRcdFx0XHRcdGN0eFxuXHRcdFx0XHRcdFx0KSB8fCBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFVwZGF0ZSBlbGVtZW50IGNsYXNzZXMgYWNjb3JkaW5nIHRvIG5vZGUgc3RhdGUuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKi9cblx0XHRcdG5vZGVSZW5kZXJTdGF0dXM6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHQvLyBTZXQgY2xhc3NlcyBmb3IgY3VycmVudCBzdGF0dXNcblx0XHRcdFx0dmFyICRhcmlhRWxlbSxcblx0XHRcdFx0XHRub2RlID0gY3R4Lm5vZGUsXG5cdFx0XHRcdFx0dHJlZSA9IGN0eC50cmVlLFxuXHRcdFx0XHRcdG9wdHMgPSBjdHgub3B0aW9ucyxcblx0XHRcdFx0XHQvLyBcdG5vZGVDb250YWluZXIgPSBub2RlW3RyZWUubm9kZUNvbnRhaW5lckF0dHJOYW1lXSxcblx0XHRcdFx0XHRoYXNDaGlsZHJlbiA9IG5vZGUuaGFzQ2hpbGRyZW4oKSxcblx0XHRcdFx0XHRpc0xhc3RTaWIgPSBub2RlLmlzTGFzdFNpYmxpbmcoKSxcblx0XHRcdFx0XHRhcmlhID0gb3B0cy5hcmlhLFxuXHRcdFx0XHRcdGNuID0gb3B0cy5fY2xhc3NOYW1lcyxcblx0XHRcdFx0XHRjbkxpc3QgPSBbXSxcblx0XHRcdFx0XHRzdGF0dXNFbGVtID0gbm9kZVt0cmVlLnN0YXR1c0NsYXNzUHJvcE5hbWVdO1xuXG5cdFx0XHRcdGlmICghc3RhdHVzRWxlbSB8fCB0cmVlLl9lbmFibGVVcGRhdGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGFuIHVucmVuZGVyZWQgbm9kZSwgaWdub3JlIGl0ICh3aWxsIGJlIHVwZGF0ZWQgb24gbmVjdCByZW5kZXIgYW55d2F5KVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYXJpYSkge1xuXHRcdFx0XHRcdCRhcmlhRWxlbSA9ICQobm9kZS50ciB8fCBub2RlLmxpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBCdWlsZCBhIGxpc3Qgb2YgY2xhc3MgbmFtZXMgdGhhdCB3ZSB3aWxsIGFkZCB0byB0aGUgbm9kZSA8c3Bhbj5cblx0XHRcdFx0Y25MaXN0LnB1c2goY24ubm9kZSk7XG5cdFx0XHRcdGlmICh0cmVlLmFjdGl2ZU5vZGUgPT09IG5vZGUpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5hY3RpdmUpO1xuXHRcdFx0XHRcdC8vIFx0XHQkKFwiPnNwYW4uZmFuY3l0cmVlLXRpdGxlXCIsIHN0YXR1c0VsZW0pLmF0dHIoXCJ0YWJpbmRleFwiLCBcIjBcIik7XG5cdFx0XHRcdFx0Ly8gXHRcdHRyZWUuJGNvbnRhaW5lci5yZW1vdmVBdHRyKFwidGFiaW5kZXhcIik7XG5cdFx0XHRcdFx0Ly8gfWVsc2V7XG5cdFx0XHRcdFx0Ly8gXHRcdCQoXCI+c3Bhbi5mYW5jeXRyZWUtdGl0bGVcIiwgc3RhdHVzRWxlbSkucmVtb3ZlQXR0cihcInRhYmluZGV4XCIpO1xuXHRcdFx0XHRcdC8vIFx0XHR0cmVlLiRjb250YWluZXIuYXR0cihcInRhYmluZGV4XCIsIFwiMFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHJlZS5mb2N1c05vZGUgPT09IG5vZGUpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5mb2N1c2VkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9kZS5leHBhbmRlZCkge1xuXHRcdFx0XHRcdGNuTGlzdC5wdXNoKGNuLmV4cGFuZGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYXJpYSkge1xuXHRcdFx0XHRcdGlmIChoYXNDaGlsZHJlbiA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdCRhcmlhRWxlbS5yZW1vdmVBdHRyKFwiYXJpYS1leHBhbmRlZFwiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JGFyaWFFbGVtLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsIEJvb2xlYW4obm9kZS5leHBhbmRlZCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9kZS5mb2xkZXIpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5mb2xkZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYXNDaGlsZHJlbiAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5oYXNDaGlsZHJlbik7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETzogcmVxdWlyZWQ/XG5cdFx0XHRcdGlmIChpc0xhc3RTaWIpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5sYXN0c2liKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9kZS5sYXp5ICYmIG5vZGUuY2hpbGRyZW4gPT0gbnVsbCkge1xuXHRcdFx0XHRcdGNuTGlzdC5wdXNoKGNuLmxhenkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub2RlLnBhcnRsb2FkKSB7XG5cdFx0XHRcdFx0Y25MaXN0LnB1c2goY24ucGFydGxvYWQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub2RlLnBhcnRzZWwpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5wYXJ0c2VsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoRlQuZXZhbE9wdGlvbihcInVuc2VsZWN0YWJsZVwiLCBub2RlLCBub2RlLCBvcHRzLCBmYWxzZSkpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi51bnNlbGVjdGFibGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub2RlLl9pc0xvYWRpbmcpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5sb2FkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobm9kZS5fZXJyb3IpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5lcnJvcik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vZGUuc3RhdHVzTm9kZVR5cGUpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5zdGF0dXNOb2RlUHJlZml4ICsgbm9kZS5zdGF0dXNOb2RlVHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vZGUuc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRjbkxpc3QucHVzaChjbi5zZWxlY3RlZCk7XG5cdFx0XHRcdFx0aWYgKGFyaWEpIHtcblx0XHRcdFx0XHRcdCRhcmlhRWxlbS5hdHRyKFwiYXJpYS1zZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJpYSkge1xuXHRcdFx0XHRcdCRhcmlhRWxlbS5hdHRyKFwiYXJpYS1zZWxlY3RlZFwiLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vZGUuZXh0cmFDbGFzc2VzKSB7XG5cdFx0XHRcdFx0Y25MaXN0LnB1c2gobm9kZS5leHRyYUNsYXNzZXMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElFNiBkb2Vzbid0IGNvcnJlY3RseSBldmFsdWF0ZSBtdWx0aXBsZSBjbGFzcyBuYW1lcyxcblx0XHRcdFx0Ly8gc28gd2UgY3JlYXRlIGNvbWJpbmVkIGNsYXNzIG5hbWVzIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIENTU1xuXHRcdFx0XHRpZiAoaGFzQ2hpbGRyZW4gPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Y25MaXN0LnB1c2goXG5cdFx0XHRcdFx0XHRjbi5jb21iaW5lZEV4cGFuZGVyUHJlZml4ICsgXCJuXCIgKyAoaXNMYXN0U2liID8gXCJsXCIgOiBcIlwiKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y25MaXN0LnB1c2goXG5cdFx0XHRcdFx0XHRjbi5jb21iaW5lZEV4cGFuZGVyUHJlZml4ICtcblx0XHRcdFx0XHRcdFx0KG5vZGUuZXhwYW5kZWQgPyBcImVcIiA6IFwiY1wiKSArXG5cdFx0XHRcdFx0XHRcdChub2RlLmxhenkgJiYgbm9kZS5jaGlsZHJlbiA9PSBudWxsID8gXCJkXCIgOiBcIlwiKSArXG5cdFx0XHRcdFx0XHRcdChpc0xhc3RTaWIgPyBcImxcIiA6IFwiXCIpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbkxpc3QucHVzaChcblx0XHRcdFx0XHRjbi5jb21iaW5lZEljb25QcmVmaXggK1xuXHRcdFx0XHRcdFx0KG5vZGUuZXhwYW5kZWQgPyBcImVcIiA6IFwiY1wiKSArXG5cdFx0XHRcdFx0XHQobm9kZS5mb2xkZXIgPyBcImZcIiA6IFwiXCIpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdC8vIG5vZGUuc3Bhbi5jbGFzc05hbWUgPSBjbkxpc3Quam9pbihcIiBcIik7XG5cdFx0XHRcdHN0YXR1c0VsZW0uY2xhc3NOYW1lID0gY25MaXN0LmpvaW4oXCIgXCIpO1xuXG5cdFx0XHRcdC8vIFRPRE86IHdlIHNob3VsZCBub3Qgc2V0IHRoaXMgaW4gdGhlIDxzcGFuPiB0YWcgYWxzbywgaWYgd2Ugc2V0IGl0IGhlcmU6XG5cdFx0XHRcdC8vIE1heWJlIG1vc3QgKGFsbCkgb2YgdGhlIGNsYXNzZXMgc2hvdWxkIGJlIHNldCBpbiBMSSBpbnN0ZWFkIG9mIFNQQU4/XG5cdFx0XHRcdGlmIChub2RlLmxpKSB7XG5cdFx0XHRcdFx0Ly8gIzcxOTogd2UgaGF2ZSB0byBjb25zaWRlciB0aGF0IHRoZXJlIG1heSBiZSBhbHJlYWR5IG90aGVyIGNsYXNzZXM6XG5cdFx0XHRcdFx0JChub2RlLmxpKS50b2dnbGVDbGFzcyhjbi5sYXN0c2liLCBpc0xhc3RTaWIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIEFjdGl2YXRlIG5vZGUuXG5cdFx0XHQgKiBmbGFnIGRlZmF1bHRzIHRvIHRydWUuXG5cdFx0XHQgKiBJZiBmbGFnIGlzIHRydWUsIHRoZSBub2RlIGlzIGFjdGl2YXRlZCAobXVzdCBiZSBhIHN5bmNocm9ub3VzIG9wZXJhdGlvbilcblx0XHRcdCAqIElmIGZsYWcgaXMgZmFsc2UsIHRoZSBub2RlIGlzIGRlYWN0aXZhdGVkIChtdXN0IGJlIGEgc3luY2hyb25vdXMgb3BlcmF0aW9uKVxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhZz10cnVlXVxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSBhZGRpdGlvbmFsIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtub0V2ZW50czogZmFsc2UsIG5vRm9jdXM6IGZhbHNlfVxuXHRcdFx0ICogQHJldHVybnMgeyQuUHJvbWlzZX1cblx0XHRcdCAqL1xuXHRcdFx0bm9kZVNldEFjdGl2ZTogZnVuY3Rpb24oY3R4LCBmbGFnLCBjYWxsT3B0cykge1xuXHRcdFx0XHQvLyBIYW5kbGUgdXNlciBjbGljayAvIFtzcGFjZV0gLyBbZW50ZXJdLCBhY2NvcmRpbmcgdG8gY2xpY2tGb2xkZXJNb2RlLlxuXHRcdFx0XHRjYWxsT3B0cyA9IGNhbGxPcHRzIHx8IHt9O1xuXHRcdFx0XHR2YXIgc3ViQ3R4LFxuXHRcdFx0XHRcdG5vZGUgPSBjdHgubm9kZSxcblx0XHRcdFx0XHR0cmVlID0gY3R4LnRyZWUsXG5cdFx0XHRcdFx0b3B0cyA9IGN0eC5vcHRpb25zLFxuXHRcdFx0XHRcdG5vRXZlbnRzID0gY2FsbE9wdHMubm9FdmVudHMgPT09IHRydWUsXG5cdFx0XHRcdFx0bm9Gb2N1cyA9IGNhbGxPcHRzLm5vRm9jdXMgPT09IHRydWUsXG5cdFx0XHRcdFx0c2Nyb2xsID0gY2FsbE9wdHMuc2Nyb2xsSW50b1ZpZXcgIT09IGZhbHNlLFxuXHRcdFx0XHRcdGlzQWN0aXZlID0gbm9kZSA9PT0gdHJlZS5hY3RpdmVOb2RlO1xuXG5cdFx0XHRcdC8vIGZsYWcgZGVmYXVsdHMgdG8gdHJ1ZVxuXHRcdFx0XHRmbGFnID0gZmxhZyAhPT0gZmFsc2U7XG5cdFx0XHRcdC8vIG5vZGUuZGVidWcoXCJub2RlU2V0QWN0aXZlXCIsIGZsYWcpO1xuXG5cdFx0XHRcdGlmIChpc0FjdGl2ZSA9PT0gZmxhZykge1xuXHRcdFx0XHRcdC8vIE5vdGhpbmcgdG8gZG9cblx0XHRcdFx0XHRyZXR1cm4gX2dldFJlc29sdmVkUHJvbWlzZShub2RlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0XHRmbGFnICYmXG5cdFx0XHRcdFx0IW5vRXZlbnRzICYmXG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFwiYmVmb3JlQWN0aXZhdGVcIixcblx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRjdHgub3JpZ2luYWxFdmVudFxuXHRcdFx0XHRcdCkgPT09IGZhbHNlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIENhbGxiYWNrIHJldHVybmVkIGZhbHNlXG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRSZWplY3RlZFByb21pc2Uobm9kZSwgW1wicmVqZWN0ZWRcIl0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmbGFnKSB7XG5cdFx0XHRcdFx0aWYgKHRyZWUuYWN0aXZlTm9kZSkge1xuXHRcdFx0XHRcdFx0X2Fzc2VydChcblx0XHRcdFx0XHRcdFx0dHJlZS5hY3RpdmVOb2RlICE9PSBub2RlLFxuXHRcdFx0XHRcdFx0XHRcIm5vZGUgd2FzIGFjdGl2ZSAoaW5jb25zaXN0ZW5jeSlcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHN1YkN0eCA9ICQuZXh0ZW5kKHt9LCBjdHgsIHsgbm9kZTogdHJlZS5hY3RpdmVOb2RlIH0pO1xuXHRcdFx0XHRcdFx0dHJlZS5ub2RlU2V0QWN0aXZlKHN1YkN0eCwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0X2Fzc2VydChcblx0XHRcdFx0XHRcdFx0dHJlZS5hY3RpdmVOb2RlID09PSBudWxsLFxuXHRcdFx0XHRcdFx0XHRcImRlYWN0aXZhdGUgd2FzIG91dCBvZiBzeW5jP1wiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChvcHRzLmFjdGl2ZVZpc2libGUpIHtcblx0XHRcdFx0XHRcdC8vIElmIG5vIGZvY3VzIGlzIHNldCAobm9Gb2N1czogdHJ1ZSkgYW5kIHRoZXJlIGlzIG5vIGZvY3VzZWQgbm9kZSwgdGhpcyBub2RlIGlzIG1hZGUgdmlzaWJsZS5cblx0XHRcdFx0XHRcdC8vIHNjcm9sbCA9IG5vRm9jdXMgJiYgdHJlZS5mb2N1c05vZGUgPT0gbnVsbDtcblx0XHRcdFx0XHRcdC8vICM4NjM6IHNjcm9sbCBieSBkZWZhdWx0ICh1bmxlc3MgYHNjcm9sbEludG9WaWV3OiBmYWxzZWAgd2FzIHBhc3NlZClcblx0XHRcdFx0XHRcdG5vZGUubWFrZVZpc2libGUoeyBzY3JvbGxJbnRvVmlldzogc2Nyb2xsIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cmVlLmFjdGl2ZU5vZGUgPSBub2RlO1xuXHRcdFx0XHRcdHRyZWUubm9kZVJlbmRlclN0YXR1cyhjdHgpO1xuXHRcdFx0XHRcdGlmICghbm9Gb2N1cykge1xuXHRcdFx0XHRcdFx0dHJlZS5ub2RlU2V0Rm9jdXMoY3R4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFub0V2ZW50cykge1xuXHRcdFx0XHRcdFx0dHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XCJhY3RpdmF0ZVwiLFxuXHRcdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0XHRjdHgub3JpZ2luYWxFdmVudFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X2Fzc2VydChcblx0XHRcdFx0XHRcdHRyZWUuYWN0aXZlTm9kZSA9PT0gbm9kZSxcblx0XHRcdFx0XHRcdFwibm9kZSB3YXMgbm90IGFjdGl2ZSAoaW5jb25zaXN0ZW5jeSlcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0dHJlZS5hY3RpdmVOb2RlID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLm5vZGVSZW5kZXJTdGF0dXMoY3R4KTtcblx0XHRcdFx0XHRpZiAoIW5vRXZlbnRzKSB7XG5cdFx0XHRcdFx0XHRjdHgudHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XCJkZWFjdGl2YXRlXCIsXG5cdFx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRcdGN0eC5vcmlnaW5hbEV2ZW50XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gX2dldFJlc29sdmVkUHJvbWlzZShub2RlKTtcblx0XHRcdH0sXG5cdFx0XHQvKiogRXhwYW5kIG9yIGNvbGxhcHNlIG5vZGUsIHJldHVybiBEZWZlcnJlZC5wcm9taXNlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV1cblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gYWRkaXRpb25hbCBvcHRpb25zLiBEZWZhdWx0cyB0byBge25vQW5pbWF0aW9uOiBmYWxzZSwgbm9FdmVudHM6IGZhbHNlfWBcblx0XHRcdCAqIEByZXR1cm5zIHskLlByb21pc2V9IFRoZSBkZWZlcnJlZCB3aWxsIGJlIHJlc29sdmVkIGFzIHNvb24gYXMgdGhlIChsYXp5KVxuXHRcdFx0ICogICAgIGRhdGEgd2FzIHJldHJpZXZlZCwgcmVuZGVyZWQsIGFuZCB0aGUgZXhwYW5kIGFuaW1hdGlvbiBmaW5pc2hlZC5cblx0XHRcdCAqL1xuXHRcdFx0bm9kZVNldEV4cGFuZGVkOiBmdW5jdGlvbihjdHgsIGZsYWcsIGNhbGxPcHRzKSB7XG5cdFx0XHRcdGNhbGxPcHRzID0gY2FsbE9wdHMgfHwge307XG5cdFx0XHRcdHZhciBfYWZ0ZXJMb2FkLFxuXHRcdFx0XHRcdGRmZCxcblx0XHRcdFx0XHRpLFxuXHRcdFx0XHRcdGwsXG5cdFx0XHRcdFx0cGFyZW50cyxcblx0XHRcdFx0XHRwcmV2QUMsXG5cdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdHRyZWUgPSBjdHgudHJlZSxcblx0XHRcdFx0XHRvcHRzID0gY3R4Lm9wdGlvbnMsXG5cdFx0XHRcdFx0bm9BbmltYXRpb24gPSBjYWxsT3B0cy5ub0FuaW1hdGlvbiA9PT0gdHJ1ZSxcblx0XHRcdFx0XHRub0V2ZW50cyA9IGNhbGxPcHRzLm5vRXZlbnRzID09PSB0cnVlO1xuXG5cdFx0XHRcdC8vIGZsYWcgZGVmYXVsdHMgdG8gdHJ1ZVxuXHRcdFx0XHRmbGFnID0gZmxhZyAhPT0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gbm9kZS5kZWJ1ZyhcIm5vZGVTZXRFeHBhbmRlZChcIiArIGZsYWcgKyBcIilcIik7XG5cblx0XHRcdFx0aWYgKChub2RlLmV4cGFuZGVkICYmIGZsYWcpIHx8ICghbm9kZS5leHBhbmRlZCAmJiAhZmxhZykpIHtcblx0XHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvXG5cdFx0XHRcdFx0Ly8gbm9kZS5kZWJ1ZyhcIm5vZGVTZXRFeHBhbmRlZChcIiArIGZsYWcgKyBcIik6IG5vdGhpbmcgdG8gZG9cIik7XG5cdFx0XHRcdFx0cmV0dXJuIF9nZXRSZXNvbHZlZFByb21pc2Uobm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZmxhZyAmJiAhbm9kZS5sYXp5ICYmICFub2RlLmhhc0NoaWxkcmVuKCkpIHtcblx0XHRcdFx0XHQvLyBQcmV2ZW50IGV4cGFuZGluZyBvZiBlbXB0eSBub2Rlc1xuXHRcdFx0XHRcdC8vIHJldHVybiBfZ2V0UmVqZWN0ZWRQcm9taXNlKG5vZGUsIFtcImVtcHR5XCJdKTtcblx0XHRcdFx0XHRyZXR1cm4gX2dldFJlc29sdmVkUHJvbWlzZShub2RlKTtcblx0XHRcdFx0fSBlbHNlIGlmICghZmxhZyAmJiBub2RlLmdldExldmVsKCkgPCBvcHRzLm1pbkV4cGFuZExldmVsKSB7XG5cdFx0XHRcdFx0Ly8gUHJldmVudCBjb2xsYXBzaW5nIGxvY2tlZCBsZXZlbHNcblx0XHRcdFx0XHRyZXR1cm4gX2dldFJlamVjdGVkUHJvbWlzZShub2RlLCBbXCJsb2NrZWRcIl0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdCFub0V2ZW50cyAmJlxuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXJOb2RlRXZlbnQoXG5cdFx0XHRcdFx0XHRcImJlZm9yZUV4cGFuZFwiLFxuXHRcdFx0XHRcdFx0bm9kZSxcblx0XHRcdFx0XHRcdGN0eC5vcmlnaW5hbEV2ZW50XG5cdFx0XHRcdFx0KSA9PT0gZmFsc2Vcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gQ2FsbGJhY2sgcmV0dXJuZWQgZmFsc2Vcblx0XHRcdFx0XHRyZXR1cm4gX2dldFJlamVjdGVkUHJvbWlzZShub2RlLCBbXCJyZWplY3RlZFwiXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgdGhpcyBub2RlIGluc2lkZSBhIGNvbGxwYXNlZCBub2RlLCBubyBhbmltYXRpb24gYW5kIHNjcm9sbGluZyBpcyBuZWVkZWRcblx0XHRcdFx0aWYgKCFub0FuaW1hdGlvbiAmJiAhbm9kZS5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdG5vQW5pbWF0aW9uID0gY2FsbE9wdHMubm9BbmltYXRpb24gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGZkID0gbmV3ICQuRGVmZXJyZWQoKTtcblxuXHRcdFx0XHQvLyBBdXRvLWNvbGxhcHNlIG1vZGU6IGNvbGxhcHNlIGFsbCBzaWJsaW5nc1xuXHRcdFx0XHRpZiAoZmxhZyAmJiAhbm9kZS5leHBhbmRlZCAmJiBvcHRzLmF1dG9Db2xsYXBzZSkge1xuXHRcdFx0XHRcdHBhcmVudHMgPSBub2RlLmdldFBhcmVudExpc3QoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHRcdHByZXZBQyA9IG9wdHMuYXV0b0NvbGxhcHNlO1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRvcHRzLmF1dG9Db2xsYXBzZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IHBhcmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IHNob3VsZCByZXR1cm4gcHJvbWlzZT9cblx0XHRcdFx0XHRcdFx0dGhpcy5fY2FsbEhvb2soXG5cdFx0XHRcdFx0XHRcdFx0XCJub2RlQ29sbGFwc2VTaWJsaW5nc1wiLFxuXHRcdFx0XHRcdFx0XHRcdHBhcmVudHNbaV0sXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbE9wdHNcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0b3B0cy5hdXRvQ29sbGFwc2UgPSBwcmV2QUM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRyaWdnZXIgZXhwYW5kL2NvbGxhcHNlIGFmdGVyIGV4cGFuZGluZ1xuXHRcdFx0XHRkZmQuZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgbGFzdENoaWxkID0gbm9kZS5nZXRMYXN0Q2hpbGQoKTtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdGZsYWcgJiZcblx0XHRcdFx0XHRcdG9wdHMuYXV0b1Njcm9sbCAmJlxuXHRcdFx0XHRcdFx0IW5vQW5pbWF0aW9uICYmXG5cdFx0XHRcdFx0XHRsYXN0Q2hpbGQgJiZcblx0XHRcdFx0XHRcdHRyZWUuX2VuYWJsZVVwZGF0ZVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Ly8gU2Nyb2xsIGRvd24gdG8gbGFzdCBjaGlsZCwgYnV0IGtlZXAgY3VycmVudCBub2RlIHZpc2libGVcblx0XHRcdFx0XHRcdGxhc3RDaGlsZFxuXHRcdFx0XHRcdFx0XHQuc2Nyb2xsSW50b1ZpZXcodHJ1ZSwgeyB0b3BOb2RlOiBub2RlIH0pXG5cdFx0XHRcdFx0XHRcdC5hbHdheXMoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFub0V2ZW50cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3R4LnRyZWUuX3RyaWdnZXJOb2RlRXZlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZsYWcgPyBcImV4cGFuZFwiIDogXCJjb2xsYXBzZVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdHhcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKCFub0V2ZW50cykge1xuXHRcdFx0XHRcdFx0XHRjdHgudHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XHRmbGFnID8gXCJleHBhbmRcIiA6IFwiY29sbGFwc2VcIixcblx0XHRcdFx0XHRcdFx0XHRjdHhcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHQvLyB2dnYgQ29kZSBiZWxvdyBpcyBleGVjdXRlZCBhZnRlciBsb2FkaW5nIGZpbmlzaGVkOlxuXHRcdFx0XHRfYWZ0ZXJMb2FkID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRcdFx0XHR2YXIgY24gPSBvcHRzLl9jbGFzc05hbWVzLFxuXHRcdFx0XHRcdFx0aXNWaXNpYmxlLFxuXHRcdFx0XHRcdFx0aXNFeHBhbmRlZCxcblx0XHRcdFx0XHRcdGVmZmVjdCA9IG9wdHMudG9nZ2xlRWZmZWN0O1xuXG5cdFx0XHRcdFx0bm9kZS5leHBhbmRlZCA9IGZsYWc7XG5cdFx0XHRcdFx0dHJlZS5fY2FsbEhvb2soXG5cdFx0XHRcdFx0XHRcInRyZWVTdHJ1Y3R1cmVDaGFuZ2VkXCIsXG5cdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRmbGFnID8gXCJleHBhbmRcIiA6IFwiY29sbGFwc2VcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIHJlcXVpcmVkIG1hcmt1cCwgYnV0IG1ha2Ugc3VyZSB0aGUgdG9wIFVMIGlzIGhpZGRlbiwgc28gd2Vcblx0XHRcdFx0XHQvLyBjYW4gYW5pbWF0ZSBsYXRlclxuXHRcdFx0XHRcdHRyZWUuX2NhbGxIb29rKFwibm9kZVJlbmRlclwiLCBjdHgsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG5cblx0XHRcdFx0XHQvLyBIaWRlIGNoaWxkcmVuLCBpZiBub2RlIGlzIGNvbGxhcHNlZFxuXHRcdFx0XHRcdGlmIChub2RlLnVsKSB7XG5cdFx0XHRcdFx0XHRpc1Zpc2libGUgPSBub2RlLnVsLnN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiO1xuXHRcdFx0XHRcdFx0aXNFeHBhbmRlZCA9ICEhbm9kZS5leHBhbmRlZDtcblx0XHRcdFx0XHRcdGlmIChpc1Zpc2libGUgPT09IGlzRXhwYW5kZWQpIHtcblx0XHRcdFx0XHRcdFx0bm9kZS53YXJuKFxuXHRcdFx0XHRcdFx0XHRcdFwibm9kZVNldEV4cGFuZGVkOiBVTC5zdHlsZS5kaXNwbGF5IGFscmVhZHkgc2V0XCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIWVmZmVjdCB8fCBub0FuaW1hdGlvbikge1xuXHRcdFx0XHRcdFx0XHRub2RlLnVsLnN0eWxlLmRpc3BsYXkgPVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUuZXhwYW5kZWQgfHwgIXBhcmVudCA/IFwiXCIgOiBcIm5vbmVcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBVSSB0b2dnbGUoKSBlZmZlY3Qgd29ya3Mgd2l0aCB0aGUgZXh0LXdpZGUgZXh0ZW5zaW9uLFxuXHRcdFx0XHRcdFx0XHQvLyB3aGlsZSBqUXVlcnkuYW5pbWF0ZSgpIGhhcyBwcm9ibGVtcyB3aGVuIHRoZSB0aXRsZSBzcGFuXG5cdFx0XHRcdFx0XHRcdC8vIGhhcyBwb3NpdGlvbjogYWJzb2x1dGUuXG5cdFx0XHRcdFx0XHRcdC8vIFNpbmNlIGpRdWVyeSBVSSAxLjEyLCB0aGUgYmxpbmQgZWZmZWN0IHJlcXVpcmVzIHRoZSBwYXJlbnRcblx0XHRcdFx0XHRcdFx0Ly8gZWxlbWVudCB0byBoYXZlICdwb3NpdGlvbjogcmVsYXRpdmUnLlxuXHRcdFx0XHRcdFx0XHQvLyBTZWUgIzcxNiwgIzcxN1xuXHRcdFx0XHRcdFx0XHQkKG5vZGUubGkpLmFkZENsYXNzKGNuLmFuaW1hdGluZyk7IC8vICM3MTdcblxuXHRcdFx0XHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKCQobm9kZS51bClbZWZmZWN0LmVmZmVjdF0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdHJlZS5kZWJ1ZyggXCJ1c2UganF1ZXJ5LlwiICsgZWZmZWN0LmVmZmVjdCArIFwiIG1ldGhvZFwiICk7XG5cdFx0XHRcdFx0XHRcdFx0JChub2RlLnVsKVtlZmZlY3QuZWZmZWN0XSh7XG5cdFx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogZWZmZWN0LmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gbm9kZS5kZWJ1ZyhcImZhbmN5dHJlZS1hbmltYXRpbmcgZW5kOiBcIiArIG5vZGUubGkuY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0JCh0aGlzKS5yZW1vdmVDbGFzcyhjbi5hbmltYXRpbmcpOyAvLyAjNzE2XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCQobm9kZS5saSkucmVtb3ZlQ2xhc3MoY24uYW5pbWF0aW5nKTsgLy8gIzcxN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBUaGUgVUkgdG9nZ2xlKCkgZWZmZWN0IHdvcmtzIHdpdGggdGhlIGV4dC13aWRlIGV4dGVuc2lvbixcblx0XHRcdFx0XHRcdFx0XHQvLyB3aGlsZSBqUXVlcnkuYW5pbWF0ZSgpIGhhcyBwcm9ibGVtcyB3aGVuIHRoZSB0aXRsZSBzcGFuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gaGFzIHBvc2l0b246IGFic29sdXRlLlxuXHRcdFx0XHRcdFx0XHRcdC8vIFNpbmNlIGpRdWVyeSBVSSAxLjEyLCB0aGUgYmxpbmQgZWZmZWN0IHJlcXVpcmVzIHRoZSBwYXJlbnRcblx0XHRcdFx0XHRcdFx0XHQvLyBlbGVtZW50IHRvIGhhdmUgJ3Bvc2l0aW9uOiByZWxhdGl2ZScuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU2VlICM3MTYsICM3MTdcblx0XHRcdFx0XHRcdFx0XHQvLyB0cmVlLmRlYnVnKFwidXNlIHNwZWNpZmllZCBlZmZlY3QgKFwiICsgZWZmZWN0LmVmZmVjdCArIFwiKSB3aXRoIHRoZSBqcXVlcnl1aS50b2dnbGUgbWV0aG9kXCIpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdHJ5IHRvIHN0b3AgYW4gYW5pbWF0aW9uIHRoYXQgbWlnaHQgYmUgYWxyZWFkeSBpbiBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdCQobm9kZS51bCkuc3RvcCh0cnVlLCB0cnVlKTsgLy88IGRvZXMgbm90IHdvcmsgYWZ0ZXIgcmVzZXRMYXp5IGhhcyBiZWVuIGNhbGxlZCBmb3IgYSBub2RlIHdob3NlIGFuaW1hdGlvbiB3YXNuJ3QgY29tcGxldGUgYW5kIGVmZmVjdCB3YXMgXCJibGluZFwiXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBkaXJ0eSBmaXggdG8gcmVtb3ZlIGEgZGVmdW5jdCBhbmltYXRpb24gKGVmZmVjdDogXCJibGluZFwiKSBhZnRlciByZXNldExhenkgaGFzIGJlZW4gY2FsbGVkXG5cdFx0XHRcdFx0XHRcdFx0JChub2RlLnVsKVxuXHRcdFx0XHRcdFx0XHRcdFx0LnBhcmVudCgpXG5cdFx0XHRcdFx0XHRcdFx0XHQuZmluZChcIi51aS1lZmZlY3RzLXBsYWNlaG9sZGVyXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHRcdFx0XHQkKG5vZGUudWwpLnRvZ2dsZShcblx0XHRcdFx0XHRcdFx0XHRcdGVmZmVjdC5lZmZlY3QsXG5cdFx0XHRcdFx0XHRcdFx0XHRlZmZlY3Qub3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0XHRcdGVmZmVjdC5kdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBub2RlLmRlYnVnKFwiZmFuY3l0cmVlLWFuaW1hdGluZyBlbmQ6IFwiICsgbm9kZS5saS5jbGFzc05hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQkKHRoaXMpLnJlbW92ZUNsYXNzKGNuLmFuaW1hdGluZyk7IC8vICM3MTZcblx0XHRcdFx0XHRcdFx0XHRcdFx0JChub2RlLmxpKS5yZW1vdmVDbGFzcyhjbi5hbmltYXRpbmcpOyAvLyAjNzE3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdC8vIF5eXiBDb2RlIGFib3ZlIGlzIGV4ZWN1dGVkIGFmdGVyIGxvYWRpbmcgZmluc2hlZC5cblxuXHRcdFx0XHQvLyBMb2FkIGxhenkgbm9kZXMsIGlmIGFueS4gVGhlbiBjb250aW51ZSB3aXRoIF9hZnRlckxvYWQoKVxuXHRcdFx0XHRpZiAoZmxhZyAmJiBub2RlLmxhenkgJiYgbm9kZS5oYXNDaGlsZHJlbigpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBub2RlLmRlYnVnKFwibm9kZVNldEV4cGFuZGVkOiBsb2FkIHN0YXJ0Li4uXCIpO1xuXHRcdFx0XHRcdG5vZGUubG9hZCgpXG5cdFx0XHRcdFx0XHQuZG9uZShmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Ly8gbm9kZS5kZWJ1ZyhcIm5vZGVTZXRFeHBhbmRlZDogbG9hZCBkb25lXCIpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZGZkLm5vdGlmeVdpdGgpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyByZXF1aXJlcyBqUXVlcnkgMS42K1xuXHRcdFx0XHRcdFx0XHRcdGRmZC5ub3RpZnlXaXRoKG5vZGUsIFtcImxvYWRlZFwiXSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0X2FmdGVyTG9hZChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRkZmQucmVzb2x2ZVdpdGgobm9kZSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdC5mYWlsKGZ1bmN0aW9uKGVyck1zZykge1xuXHRcdFx0XHRcdFx0XHRfYWZ0ZXJMb2FkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGRmZC5yZWplY3RXaXRoKG5vZGUsIFtcblx0XHRcdFx0XHRcdFx0XHRcdFwibG9hZCBmYWlsZWQgKFwiICsgZXJyTXNnICsgXCIpXCIsXG5cdFx0XHRcdFx0XHRcdFx0XSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHR2YXIgc291cmNlID0gdHJlZS5fdHJpZ2dlck5vZGVFdmVudChcImxhenlMb2FkXCIsIG5vZGUsIGN0eC5vcmlnaW5hbEV2ZW50KTtcblx0XHRcdFx0XHRfYXNzZXJ0KHR5cGVvZiBzb3VyY2UgIT09IFwiYm9vbGVhblwiLCBcImxhenlMb2FkIGV2ZW50IG11c3QgcmV0dXJuIHNvdXJjZSBpbiBkYXRhLnJlc3VsdFwiKTtcblx0XHRcdFx0XHRub2RlLmRlYnVnKFwibm9kZVNldEV4cGFuZGVkOiBsb2FkIHN0YXJ0Li4uXCIpO1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxIb29rKFwibm9kZUxvYWRDaGlsZHJlblwiLCBjdHgsIHNvdXJjZSkuZG9uZShmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0bm9kZS5kZWJ1ZyhcIm5vZGVTZXRFeHBhbmRlZDogbG9hZCBkb25lXCIpO1xuXHRcdFx0XHRcdFx0aWYoZGZkLm5vdGlmeVdpdGgpeyAvLyByZXF1aXJlcyBqUXVlcnkgMS42K1xuXHRcdFx0XHRcdFx0XHRkZmQubm90aWZ5V2l0aChub2RlLCBbXCJsb2FkZWRcIl0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0X2FmdGVyTG9hZC5jYWxsKHRyZWUpO1xuXHRcdFx0XHRcdH0pLmZhaWwoZnVuY3Rpb24oZXJyTXNnKXtcblx0XHRcdFx0XHRcdGRmZC5yZWplY3RXaXRoKG5vZGUsIFtcImxvYWQgZmFpbGVkIChcIiArIGVyck1zZyArIFwiKVwiXSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Ki9cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRfYWZ0ZXJMb2FkKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0ZGZkLnJlc29sdmVXaXRoKG5vZGUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG5vZGUuZGVidWcoXCJub2RlU2V0RXhwYW5kZWQ6IHJldHVybnNcIik7XG5cdFx0XHRcdHJldHVybiBkZmQucHJvbWlzZSgpO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBGb2N1cyBvciBibHVyIHRoaXMgbm9kZS5cblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV1cblx0XHRcdCAqL1xuXHRcdFx0bm9kZVNldEZvY3VzOiBmdW5jdGlvbihjdHgsIGZsYWcpIHtcblx0XHRcdFx0Ly8gY3R4Lm5vZGUuZGVidWcoXCJub2RlU2V0Rm9jdXMoXCIgKyBmbGFnICsgXCIpXCIpO1xuXHRcdFx0XHR2YXIgY3R4Mixcblx0XHRcdFx0XHR0cmVlID0gY3R4LnRyZWUsXG5cdFx0XHRcdFx0bm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdG9wdHMgPSB0cmVlLm9wdGlvbnMsXG5cdFx0XHRcdFx0Ly8gZXQgPSBjdHgub3JpZ2luYWxFdmVudCAmJiBjdHgub3JpZ2luYWxFdmVudC50eXBlLFxuXHRcdFx0XHRcdGlzSW5wdXQgPSBjdHgub3JpZ2luYWxFdmVudFxuXHRcdFx0XHRcdFx0PyAkKGN0eC5vcmlnaW5hbEV2ZW50LnRhcmdldCkuaXMoXCI6aW5wdXRcIilcblx0XHRcdFx0XHRcdDogZmFsc2U7XG5cblx0XHRcdFx0ZmxhZyA9IGZsYWcgIT09IGZhbHNlO1xuXG5cdFx0XHRcdC8vIChub2RlIHx8IHRyZWUpLmRlYnVnKFwibm9kZVNldEZvY3VzKFwiICsgZmxhZyArIFwiKSwgZXZlbnQ6IFwiICsgZXQgKyBcIiwgaXNJbnB1dDogXCIrIGlzSW5wdXQpO1xuXHRcdFx0XHQvLyBCbHVyIHByZXZpb3VzIG5vZGUgaWYgYW55XG5cdFx0XHRcdGlmICh0cmVlLmZvY3VzTm9kZSkge1xuXHRcdFx0XHRcdGlmICh0cmVlLmZvY3VzTm9kZSA9PT0gbm9kZSAmJiBmbGFnKSB7XG5cdFx0XHRcdFx0XHQvLyBub2RlLmRlYnVnKFwibm9kZVNldEZvY3VzKFwiICsgZmxhZyArIFwiKTogbm90aGluZyB0byBkb1wiKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4MiA9ICQuZXh0ZW5kKHt9LCBjdHgsIHsgbm9kZTogdHJlZS5mb2N1c05vZGUgfSk7XG5cdFx0XHRcdFx0dHJlZS5mb2N1c05vZGUgPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXJOb2RlRXZlbnQoXCJibHVyXCIsIGN0eDIpO1xuXHRcdFx0XHRcdHRoaXMuX2NhbGxIb29rKFwibm9kZVJlbmRlclN0YXR1c1wiLCBjdHgyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBTZXQgZm9jdXMgdG8gY29udGFpbmVyIGFuZCBub2RlXG5cdFx0XHRcdGlmIChmbGFnKSB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcblx0XHRcdFx0XHRcdG5vZGUuZGVidWcoXCJub2RlU2V0Rm9jdXM6IGZvcmNpbmcgY29udGFpbmVyIGZvY3VzXCIpO1xuXHRcdFx0XHRcdFx0dGhpcy5fY2FsbEhvb2soXCJ0cmVlU2V0Rm9jdXNcIiwgY3R4LCB0cnVlLCB7XG5cdFx0XHRcdFx0XHRcdGNhbGxlZEJ5Tm9kZTogdHJ1ZSxcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRub2RlLm1ha2VWaXNpYmxlKHsgc2Nyb2xsSW50b1ZpZXc6IGZhbHNlIH0pO1xuXHRcdFx0XHRcdHRyZWUuZm9jdXNOb2RlID0gbm9kZTtcblx0XHRcdFx0XHRpZiAob3B0cy50aXRsZXNUYWJiYWJsZSkge1xuXHRcdFx0XHRcdFx0aWYgKCFpc0lucHV0KSB7XG5cdFx0XHRcdFx0XHRcdC8vICM2MjFcblx0XHRcdFx0XHRcdFx0JChub2RlLnNwYW4pXG5cdFx0XHRcdFx0XHRcdFx0LmZpbmQoXCIuZmFuY3l0cmVlLXRpdGxlXCIpXG5cdFx0XHRcdFx0XHRcdFx0LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChvcHRzLmFyaWEpIHtcblx0XHRcdFx0XHRcdC8vIFNldCBhY3RpdmUgZGVzY2VuZGFudCB0byBub2RlJ3Mgc3BhbiBJRCAoY3JlYXRlIG9uZSwgaWYgbmVlZGVkKVxuXHRcdFx0XHRcdFx0JCh0cmVlLiRjb250YWluZXIpLmF0dHIoXG5cdFx0XHRcdFx0XHRcdFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIsXG5cdFx0XHRcdFx0XHRcdCQobm9kZS50ciB8fCBub2RlLmxpKVxuXHRcdFx0XHRcdFx0XHRcdC51bmlxdWVJZCgpXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoXCJpZFwiKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdC8vIFwiZnRhbF9cIiArIG9wdHMuaWRQcmVmaXggKyBub2RlLmtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vICQobm9kZS5zcGFuKS5maW5kKFwiLmZhbmN5dHJlZS10aXRsZVwiKS5mb2N1cygpO1xuXHRcdFx0XHRcdHRoaXMuX3RyaWdnZXJOb2RlRXZlbnQoXCJmb2N1c1wiLCBjdHgpO1xuXG5cdFx0XHRcdFx0Ly8gZGV0ZXJtaW5lIGlmIHdlIGhhdmUgZm9jdXMgb24gb3IgaW5zaWRlIHRyZWUgY29udGFpbmVyXG5cdFx0XHRcdFx0dmFyIGhhc0ZhbmN5dHJlZUZvY3VzID1cblx0XHRcdFx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRyZWUuJGNvbnRhaW5lci5nZXQoMCkgfHxcblx0XHRcdFx0XHRcdCQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCwgdHJlZS4kY29udGFpbmVyKS5sZW5ndGggPj0gMTtcblxuXHRcdFx0XHRcdGlmICghaGFzRmFuY3l0cmVlRm9jdXMpIHtcblx0XHRcdFx0XHRcdC8vIFdlIGNhbm5vdCBzZXQgS0IgZm9jdXMgdG8gYSBub2RlLCBzbyB1c2UgdGhlIHRyZWUgY29udGFpbmVyXG5cdFx0XHRcdFx0XHQvLyAjNTYzLCAjNTcwOiBJRSBzY3JvbGxzIG9uIGV2ZXJ5IGNhbGwgdG8gLmZvY3VzKCksIGlmIHRoZSBjb250YWluZXJcblx0XHRcdFx0XHRcdC8vIGlzIHBhcnRpYWxseSBvdXRzaWRlIHRoZSB2aWV3cG9ydC4gU28gZG8gaXQgb25seSwgd2hlbiBhYnNvbHV0ZWx5XG5cdFx0XHRcdFx0XHQvLyBuZWNlc3NhcnkuXG5cdFx0XHRcdFx0XHQkKHRyZWUuJGNvbnRhaW5lcikuZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBpZiggb3B0cy5hdXRvQWN0aXZhdGUgKXtcblx0XHRcdFx0XHQvLyBcdHRyZWUubm9kZVNldEFjdGl2ZShjdHgsIHRydWUpO1xuXHRcdFx0XHRcdC8vIH1cblx0XHRcdFx0XHRpZiAob3B0cy5hdXRvU2Nyb2xsKSB7XG5cdFx0XHRcdFx0XHRub2RlLnNjcm9sbEludG9WaWV3KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX2NhbGxIb29rKFwibm9kZVJlbmRlclN0YXR1c1wiLCBjdHgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIChEZSlTZWxlY3Qgbm9kZSwgcmV0dXJuIG5ldyBzdGF0dXMgKHN5bmMpLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV1cblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gYWRkaXRpb25hbCBvcHRpb25zLiBEZWZhdWx0cyB0byB7bm9FdmVudHM6IGZhbHNlLFxuXHRcdFx0ICogICAgIHByb3BhZ2F0ZURvd246IG51bGwsIHByb3BhZ2F0ZVVwOiBudWxsLFxuXHRcdFx0ICogICAgIGNhbGxiYWNrOiBudWxsLFxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIEByZXR1cm5zIHtib29sZWFufSBwcmV2aW91cyBzdGF0dXNcblx0XHRcdCAqL1xuXHRcdFx0bm9kZVNldFNlbGVjdGVkOiBmdW5jdGlvbihjdHgsIGZsYWcsIGNhbGxPcHRzKSB7XG5cdFx0XHRcdGNhbGxPcHRzID0gY2FsbE9wdHMgfHwge307XG5cdFx0XHRcdHZhciBub2RlID0gY3R4Lm5vZGUsXG5cdFx0XHRcdFx0dHJlZSA9IGN0eC50cmVlLFxuXHRcdFx0XHRcdG9wdHMgPSBjdHgub3B0aW9ucyxcblx0XHRcdFx0XHRub0V2ZW50cyA9IGNhbGxPcHRzLm5vRXZlbnRzID09PSB0cnVlLFxuXHRcdFx0XHRcdHBhcmVudCA9IG5vZGUucGFyZW50O1xuXG5cdFx0XHRcdC8vIGZsYWcgZGVmYXVsdHMgdG8gdHJ1ZVxuXHRcdFx0XHRmbGFnID0gZmxhZyAhPT0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gbm9kZS5kZWJ1ZyhcIm5vZGVTZXRTZWxlY3RlZChcIiArIGZsYWcgKyBcIilcIiwgY3R4KTtcblxuXHRcdFx0XHQvLyBDYW5ub3QgKGRlKXNlbGVjdCB1bnNlbGVjdGFibGUgbm9kZXMgZGlyZWN0bHkgKG9ubHkgYnkgcHJvcGFnYXRpb24gb3Jcblx0XHRcdFx0Ly8gYnkgc2V0dGluZyB0aGUgYC5zZWxlY3RlZGAgcHJvcGVydHkpXG5cdFx0XHRcdGlmIChGVC5ldmFsT3B0aW9uKFwidW5zZWxlY3RhYmxlXCIsIG5vZGUsIG5vZGUsIG9wdHMsIGZhbHNlKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB1c2VyJ3MgaW50ZW50LCBpbiBjYXNlIGRvd24gLT4gdXAgcHJvcGFnYXRpb24gcHJldmVudHNcblx0XHRcdFx0Ly8gYXBwbHlpbmcgaXQgdG8gbm9kZS5zZWxlY3RlZFxuXHRcdFx0XHRub2RlLl9sYXN0U2VsZWN0SW50ZW50ID0gZmxhZzsgLy8gQ29uZnVzaW5nIHVzZSBvZiAnISdcblxuXHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvP1xuXHRcdFx0XHRpZiAoISFub2RlLnNlbGVjdGVkID09PSBmbGFnKSB7XG5cdFx0XHRcdFx0aWYgKG9wdHMuc2VsZWN0TW9kZSA9PT0gMyAmJiBub2RlLnBhcnRzZWwgJiYgIWZsYWcpIHtcblx0XHRcdFx0XHRcdC8vIElmIHByb3BhZ2F0aW9uIHByZXZlbnRlZCBzZWxlY3RpbmcgdGhpcyBub2RlIGxhc3QgdGltZSwgd2Ugc3RpbGxcblx0XHRcdFx0XHRcdC8vIHdhbnQgdG8gYWxsb3cgdG8gYXBwbHkgc2V0U2VsZWN0ZWQoZmFsc2UpIG5vd1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmxhZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IW5vRXZlbnRzICYmXG5cdFx0XHRcdFx0dGhpcy5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFwiYmVmb3JlU2VsZWN0XCIsXG5cdFx0XHRcdFx0XHRub2RlLFxuXHRcdFx0XHRcdFx0Y3R4Lm9yaWdpbmFsRXZlbnRcblx0XHRcdFx0XHQpID09PSBmYWxzZVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gISFub2RlLnNlbGVjdGVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChmbGFnICYmIG9wdHMuc2VsZWN0TW9kZSA9PT0gMSkge1xuXHRcdFx0XHRcdC8vIHNpbmdsZSBzZWxlY3Rpb24gbW9kZSAod2UgZG9uJ3QgdW5jaGVjayBhbGwgdHJlZSBub2RlcywgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMpXG5cdFx0XHRcdFx0aWYgKHRyZWUubGFzdFNlbGVjdGVkTm9kZSkge1xuXHRcdFx0XHRcdFx0dHJlZS5sYXN0U2VsZWN0ZWROb2RlLnNldFNlbGVjdGVkKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZS5zZWxlY3RlZCA9IGZsYWc7XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0b3B0cy5zZWxlY3RNb2RlID09PSAzICYmXG5cdFx0XHRcdFx0cGFyZW50ICYmXG5cdFx0XHRcdFx0IXBhcmVudC5yYWRpb2dyb3VwICYmXG5cdFx0XHRcdFx0IW5vZGUucmFkaW9ncm91cFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBtdWx0aS1oaWVyYXJjaGljYWwgc2VsZWN0aW9uIG1vZGVcblx0XHRcdFx0XHRub2RlLnNlbGVjdGVkID0gZmxhZztcblx0XHRcdFx0XHRub2RlLmZpeFNlbGVjdGlvbjNBZnRlckNsaWNrKGNhbGxPcHRzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChwYXJlbnQgJiYgcGFyZW50LnJhZGlvZ3JvdXApIHtcblx0XHRcdFx0XHRub2RlLnZpc2l0U2libGluZ3MoZnVuY3Rpb24obikge1xuXHRcdFx0XHRcdFx0bi5fY2hhbmdlU2VsZWN0U3RhdHVzQXR0cnMoZmxhZyAmJiBuID09PSBub2RlKTtcblx0XHRcdFx0XHR9LCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBkZWZhdWx0OiBzZWxlY3RNb2RlOiAyLCBtdWx0aSBzZWxlY3Rpb24gbW9kZVxuXHRcdFx0XHRcdG5vZGUuc2VsZWN0ZWQgPSBmbGFnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubm9kZVJlbmRlclN0YXR1cyhjdHgpO1xuXHRcdFx0XHR0cmVlLmxhc3RTZWxlY3RlZE5vZGUgPSBmbGFnID8gbm9kZSA6IG51bGw7XG5cdFx0XHRcdGlmICghbm9FdmVudHMpIHtcblx0XHRcdFx0XHR0cmVlLl90cmlnZ2VyTm9kZUV2ZW50KFwic2VsZWN0XCIsIGN0eCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKiogU2hvdyBub2RlIHN0YXR1cyAob2ssIGxvYWRpbmcsIGVycm9yLCBub2RhdGEpIHVzaW5nIHN0eWxlcyBhbmQgYSBkdW1teSBjaGlsZCBub2RlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqIEBwYXJhbSBzdGF0dXNcblx0XHRcdCAqIEBwYXJhbSBtZXNzYWdlXG5cdFx0XHQgKiBAcGFyYW0gZGV0YWlsc1xuXHRcdFx0ICogQHNpbmNlIDIuM1xuXHRcdFx0ICovXG5cdFx0XHRub2RlU2V0U3RhdHVzOiBmdW5jdGlvbihjdHgsIHN0YXR1cywgbWVzc2FnZSwgZGV0YWlscykge1xuXHRcdFx0XHR2YXIgbm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdHRyZWUgPSBjdHgudHJlZTtcblxuXHRcdFx0XHRmdW5jdGlvbiBfY2xlYXJTdGF0dXNOb2RlKCkge1xuXHRcdFx0XHRcdC8vIFJlbW92ZSBkZWRpY2F0ZWQgZHVtbXkgbm9kZSwgaWYgYW55XG5cdFx0XHRcdFx0dmFyIGZpcnN0Q2hpbGQgPSBub2RlLmNoaWxkcmVuID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5pc1N0YXR1c05vZGUoKSkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ly8gSSd2ZSBzZWVuIGV4Y2VwdGlvbnMgaGVyZSB3aXRoIGxvYWRLZXlQYXRoLi4uXG5cdFx0XHRcdFx0XHRcdGlmIChub2RlLnVsKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZS51bC5yZW1vdmVDaGlsZChmaXJzdENoaWxkLmxpKTtcblx0XHRcdFx0XHRcdFx0XHRmaXJzdENoaWxkLmxpID0gbnVsbDsgLy8gYXZvaWQgbGVha3MgKERUIGlzc3VlIDIxNSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHRcdFx0XHRcdGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRub2RlLmNoaWxkcmVuLnNoaWZ0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0cmVlLl9jYWxsSG9vayhcblx0XHRcdFx0XHRcdFx0XCJ0cmVlU3RydWN0dXJlQ2hhbmdlZFwiLFxuXHRcdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRcdFwiY2xlYXJTdGF0dXNOb2RlXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIF9zZXRTdGF0dXNOb2RlKGRhdGEsIHR5cGUpIHtcblx0XHRcdFx0XHQvLyBDcmVhdGUvbW9kaWZ5IHRoZSBkZWRpY2F0ZWQgZHVtbXkgbm9kZSBmb3IgJ2xvYWRpbmcuLi4nIG9yXG5cdFx0XHRcdFx0Ly8gJ2Vycm9yIScgc3RhdHVzLiAob25seSBjYWxsZWQgZm9yIGRpcmVjdCBjaGlsZCBvZiB0aGUgaW52aXNpYmxlXG5cdFx0XHRcdFx0Ly8gc3lzdGVtIHJvb3QpXG5cdFx0XHRcdFx0dmFyIGZpcnN0Q2hpbGQgPSBub2RlLmNoaWxkcmVuID8gbm9kZS5jaGlsZHJlblswXSA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5pc1N0YXR1c05vZGUoKSkge1xuXHRcdFx0XHRcdFx0JC5leHRlbmQoZmlyc3RDaGlsZCwgZGF0YSk7XG5cdFx0XHRcdFx0XHRmaXJzdENoaWxkLnN0YXR1c05vZGVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHRcdHRyZWUuX2NhbGxIb29rKFwibm9kZVJlbmRlclRpdGxlXCIsIGZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRub2RlLl9zZXRDaGlsZHJlbihbZGF0YV0pO1xuXHRcdFx0XHRcdFx0dHJlZS5fY2FsbEhvb2soXG5cdFx0XHRcdFx0XHRcdFwidHJlZVN0cnVjdHVyZUNoYW5nZWRcIixcblx0XHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0XHRcInNldFN0YXR1c05vZGVcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdG5vZGUuY2hpbGRyZW5bMF0uc3RhdHVzTm9kZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdFx0dHJlZS5yZW5kZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuY2hpbGRyZW5bMF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzd2l0Y2ggKHN0YXR1cykge1xuXHRcdFx0XHRcdGNhc2UgXCJva1wiOlxuXHRcdFx0XHRcdFx0X2NsZWFyU3RhdHVzTm9kZSgpO1xuXHRcdFx0XHRcdFx0bm9kZS5faXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRub2RlLl9lcnJvciA9IG51bGw7XG5cdFx0XHRcdFx0XHRub2RlLnJlbmRlclN0YXR1cygpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImxvYWRpbmdcIjpcblx0XHRcdFx0XHRcdGlmICghbm9kZS5wYXJlbnQpIHtcblx0XHRcdFx0XHRcdFx0X3NldFN0YXR1c05vZGUoXG5cdFx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdFx0dGl0bGU6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyZWUub3B0aW9ucy5zdHJpbmdzLmxvYWRpbmcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQobWVzc2FnZSA/IFwiIChcIiArIG1lc3NhZ2UgKyBcIilcIiA6IFwiXCIpLFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaWNvbjogdHJ1ZSwgIC8vIG5lZWRlZCBmb3IgJ2xvZGluZycgaWNvblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2hlY2tib3g6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdFx0dG9vbHRpcDogZGV0YWlscyxcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bm9kZS5faXNMb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdG5vZGUuX2Vycm9yID0gbnVsbDtcblx0XHRcdFx0XHRcdG5vZGUucmVuZGVyU3RhdHVzKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwiZXJyb3JcIjpcblx0XHRcdFx0XHRcdF9zZXRTdGF0dXNOb2RlKFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dGl0bGU6XG5cdFx0XHRcdFx0XHRcdFx0XHR0cmVlLm9wdGlvbnMuc3RyaW5ncy5sb2FkRXJyb3IgK1xuXHRcdFx0XHRcdFx0XHRcdFx0KG1lc3NhZ2UgPyBcIiAoXCIgKyBtZXNzYWdlICsgXCIpXCIgOiBcIlwiKSxcblx0XHRcdFx0XHRcdFx0XHQvLyBpY29uOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRjaGVja2JveDogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0dG9vbHRpcDogZGV0YWlscyxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0c3RhdHVzXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0bm9kZS5faXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRub2RlLl9lcnJvciA9IHsgbWVzc2FnZTogbWVzc2FnZSwgZGV0YWlsczogZGV0YWlscyB9O1xuXHRcdFx0XHRcdFx0bm9kZS5yZW5kZXJTdGF0dXMoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJub2RhdGFcIjpcblx0XHRcdFx0XHRcdF9zZXRTdGF0dXNOb2RlKFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dGl0bGU6IG1lc3NhZ2UgfHwgdHJlZS5vcHRpb25zLnN0cmluZ3Mubm9EYXRhLFxuXHRcdFx0XHRcdFx0XHRcdC8vIGljb246IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdGNoZWNrYm94OiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHR0b29sdGlwOiBkZXRhaWxzLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRzdGF0dXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRub2RlLl9pc0xvYWRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdG5vZGUuX2Vycm9yID0gbnVsbDtcblx0XHRcdFx0XHRcdG5vZGUucmVuZGVyU3RhdHVzKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0JC5lcnJvcihcImludmFsaWQgbm9kZSBzdGF0dXMgXCIgKyBzdGF0dXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICovXG5cdFx0XHRub2RlVG9nZ2xlRXhwYW5kZWQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlU2V0RXhwYW5kZWQoY3R4LCAhY3R4Lm5vZGUuZXhwYW5kZWQpO1xuXHRcdFx0fSxcblx0XHRcdC8qKlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICovXG5cdFx0XHRub2RlVG9nZ2xlU2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IGN0eC5ub2RlLFxuXHRcdFx0XHRcdGZsYWcgPSAhbm9kZS5zZWxlY3RlZDtcblxuXHRcdFx0XHQvLyBJbiBzZWxlY3RNb2RlOiAzIHRoaXMgbm9kZSBtYXkgYmUgdW5zZWxlY3RlZCtwYXJ0c2VsLCBldmVuIGlmXG5cdFx0XHRcdC8vIHNldFNlbGVjdGVkKHRydWUpIHdhcyBjYWxsZWQgYmVmb3JlLCBkdWUgdG8gYHVuc2VsZWN0YWJsZWAgY2hpbGRyZW4uXG5cdFx0XHRcdC8vIEluIHRoaXMgY2FzZSwgd2Ugbm93IHRvZ2dsZSBhcyBgc2V0U2VsZWN0ZWQoZmFsc2UpYFxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bm9kZS5wYXJ0c2VsICYmXG5cdFx0XHRcdFx0IW5vZGUuc2VsZWN0ZWQgJiZcblx0XHRcdFx0XHRub2RlLl9sYXN0U2VsZWN0SW50ZW50ID09PSB0cnVlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGZsYWcgPSBmYWxzZTtcblx0XHRcdFx0XHRub2RlLnNlbGVjdGVkID0gdHJ1ZTsgLy8gc28gaXQgaXMgbm90IGNvbnNpZGVyZWQgJ25vdGhpbmcgdG8gZG8nXG5cdFx0XHRcdH1cblx0XHRcdFx0bm9kZS5fbGFzdFNlbGVjdEludGVudCA9IGZsYWc7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGVTZXRTZWxlY3RlZChjdHgsIGZsYWcpO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBSZW1vdmUgYWxsIG5vZGVzLlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICovXG5cdFx0XHR0cmVlQ2xlYXI6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHR2YXIgdHJlZSA9IGN0eC50cmVlO1xuXHRcdFx0XHR0cmVlLmFjdGl2ZU5vZGUgPSBudWxsO1xuXHRcdFx0XHR0cmVlLmZvY3VzTm9kZSA9IG51bGw7XG5cdFx0XHRcdHRyZWUuJGRpdi5maW5kKFwiPnVsLmZhbmN5dHJlZS1jb250YWluZXJcIikuZW1wdHkoKTtcblx0XHRcdFx0Ly8gVE9ETzogY2FsbCBkZXN0cnVjdG9ycyBhbmQgcmVtb3ZlIHJlZmVyZW5jZSBsb29wc1xuXHRcdFx0XHR0cmVlLnJvb3ROb2RlLmNoaWxkcmVuID0gbnVsbDtcblx0XHRcdFx0dHJlZS5fY2FsbEhvb2soXCJ0cmVlU3RydWN0dXJlQ2hhbmdlZFwiLCBjdHgsIFwiY2xlYXJcIik7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFdpZGdldCB3YXMgY3JlYXRlZCAoY2FsbGVkIG9ubHkgb25jZSwgZXZlbiBpdCByZS1pbml0aWFsaXplZCkuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKi9cblx0XHRcdHRyZWVDcmVhdGU6IGZ1bmN0aW9uKGN0eCkge30sXG5cdFx0XHQvKiogV2lkZ2V0IHdhcyBkZXN0cm95ZWQuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKi9cblx0XHRcdHRyZWVEZXN0cm95OiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdFx0dGhpcy4kZGl2LmZpbmQoXCI+dWwuZmFuY3l0cmVlLWNvbnRhaW5lclwiKS5yZW1vdmUoKTtcblx0XHRcdFx0aWYgKHRoaXMuJHNvdXJjZSkge1xuXHRcdFx0XHRcdHRoaXMuJHNvdXJjZS5yZW1vdmVDbGFzcyhcImZhbmN5dHJlZS1oZWxwZXItaGlkZGVuXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFdpZGdldCB3YXMgKHJlLSlpbml0aWFsaXplZC5cblx0XHRcdCAqIEBwYXJhbSB7RXZlbnREYXRhfSBjdHhcblx0XHRcdCAqL1xuXHRcdFx0dHJlZUluaXQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0XHR2YXIgdHJlZSA9IGN0eC50cmVlLFxuXHRcdFx0XHRcdG9wdHMgPSB0cmVlLm9wdGlvbnM7XG5cblx0XHRcdFx0Ly90aGlzLmRlYnVnKFwiRmFuY3l0cmVlLnRyZWVJbml0KClcIik7XG5cdFx0XHRcdC8vIEFkZCBjb250YWluZXIgdG8gdGhlIFRBQiBjaGFpblxuXHRcdFx0XHQvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvd2FpLWFyaWEtcHJhY3RpY2VzLyNmb2N1c19hY3RpdmVkZXNjZW5kYW50XG5cdFx0XHRcdC8vICM1Nzc6IEFsbG93IHRvIHNldCB0YWJpbmRleCB0byBcIjBcIiwgXCItMVwiIGFuZCBcIlwiXG5cdFx0XHRcdHRyZWUuJGNvbnRhaW5lci5hdHRyKFwidGFiaW5kZXhcIiwgb3B0cy50YWJpbmRleCk7XG5cblx0XHRcdFx0Ly8gQ29weSBzb21lIGF0dHJpYnV0ZXMgdG8gdHJlZS5kYXRhXG5cdFx0XHRcdCQuZWFjaChUUkVFX0FUVFJTLCBmdW5jdGlvbihpLCBhdHRyKSB7XG5cdFx0XHRcdFx0aWYgKG9wdHNbYXR0cl0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dHJlZS5pbmZvKFwiTW92ZSBvcHRpb24gXCIgKyBhdHRyICsgXCIgdG8gdHJlZVwiKTtcblx0XHRcdFx0XHRcdHRyZWVbYXR0cl0gPSBvcHRzW2F0dHJdO1xuXHRcdFx0XHRcdFx0ZGVsZXRlIG9wdHNbYXR0cl07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAob3B0cy5jaGVja2JveEF1dG9IaWRlKSB7XG5cdFx0XHRcdFx0dHJlZS4kY29udGFpbmVyLmFkZENsYXNzKFwiZmFuY3l0cmVlLWNoZWNrYm94LWF1dG8taGlkZVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3B0cy5ydGwpIHtcblx0XHRcdFx0XHR0cmVlLiRjb250YWluZXJcblx0XHRcdFx0XHRcdC5hdHRyKFwiRElSXCIsIFwiUlRMXCIpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3MoXCJmYW5jeXRyZWUtcnRsXCIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRyZWUuJGNvbnRhaW5lclxuXHRcdFx0XHRcdFx0LnJlbW92ZUF0dHIoXCJESVJcIilcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcImZhbmN5dHJlZS1ydGxcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdHMuYXJpYSkge1xuXHRcdFx0XHRcdHRyZWUuJGNvbnRhaW5lci5hdHRyKFwicm9sZVwiLCBcInRyZWVcIik7XG5cdFx0XHRcdFx0aWYgKG9wdHMuc2VsZWN0TW9kZSAhPT0gMSkge1xuXHRcdFx0XHRcdFx0dHJlZS4kY29udGFpbmVyLmF0dHIoXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy50cmVlTG9hZChjdHgpO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBQYXJzZSBGYW5jeXRyZWUgZnJvbSBzb3VyY2UsIGFzIGNvbmZpZ3VyZWQgaW4gdGhlIG9wdGlvbnMuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKiBAcGFyYW0ge29iamVjdH0gW3NvdXJjZV0gb3B0aW9uYWwgbmV3IHNvdXJjZSAodXNlIGxhc3QgZGF0YSBvdGhlcndpc2UpXG5cdFx0XHQgKi9cblx0XHRcdHRyZWVMb2FkOiBmdW5jdGlvbihjdHgsIHNvdXJjZSkge1xuXHRcdFx0XHR2YXIgbWV0YURhdGEsXG5cdFx0XHRcdFx0dHlwZSxcblx0XHRcdFx0XHQkdWwsXG5cdFx0XHRcdFx0dHJlZSA9IGN0eC50cmVlLFxuXHRcdFx0XHRcdCRjb250YWluZXIgPSBjdHgud2lkZ2V0LmVsZW1lbnQsXG5cdFx0XHRcdFx0ZGZkLFxuXHRcdFx0XHRcdC8vIGNhbGxpbmcgY29udGV4dCBmb3Igcm9vdCBub2RlXG5cdFx0XHRcdFx0cm9vdEN0eCA9ICQuZXh0ZW5kKHt9LCBjdHgsIHsgbm9kZTogdGhpcy5yb290Tm9kZSB9KTtcblxuXHRcdFx0XHRpZiAodHJlZS5yb290Tm9kZS5jaGlsZHJlbikge1xuXHRcdFx0XHRcdHRoaXMudHJlZUNsZWFyKGN0eCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c291cmNlID0gc291cmNlIHx8IHRoaXMub3B0aW9ucy5zb3VyY2U7XG5cblx0XHRcdFx0aWYgKCFzb3VyY2UpIHtcblx0XHRcdFx0XHR0eXBlID0gJGNvbnRhaW5lci5kYXRhKFwidHlwZVwiKSB8fCBcImh0bWxcIjtcblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgXCJodG1sXCI6XG5cdFx0XHRcdFx0XHRcdC8vIFRoZXJlIHNob3VsZCBiZSBhbiBlbWJlZGRlZCBgPHVsPmAgd2l0aCBpbml0aWFsIG5vZGVzLFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgYW5vdGhlciBgPHVsIGNsYXNzPSdmYW5jeXRyZWUtY29udGFpbmVyJz5gIGlzIGFwcGVuZGVkXG5cdFx0XHRcdFx0XHRcdC8vIHRvIHRoZSB0cmVlJ3MgPGRpdj4gb24gc3RhcnR1cCBhbnl3YXkuXG5cdFx0XHRcdFx0XHRcdCR1bCA9ICRjb250YWluZXJcblx0XHRcdFx0XHRcdFx0XHQuZmluZChcIj51bFwiKVxuXHRcdFx0XHRcdFx0XHRcdC5ub3QoXCIuZmFuY3l0cmVlLWNvbnRhaW5lclwiKVxuXHRcdFx0XHRcdFx0XHRcdC5maXJzdCgpO1xuXG5cdFx0XHRcdFx0XHRcdGlmICgkdWwubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0JHVsLmFkZENsYXNzKFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJ1aS1mYW5jeXRyZWUtc291cmNlIGZhbmN5dHJlZS1oZWxwZXItaGlkZGVuXCJcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdHNvdXJjZSA9ICQudWkuZmFuY3l0cmVlLnBhcnNlSHRtbCgkdWwpO1xuXHRcdFx0XHRcdFx0XHRcdC8vIGFsbG93IHRvIGluaXQgdHJlZS5kYXRhLmZvbyBmcm9tIDx1bCBkYXRhLWZvbz0nJz5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLmRhdGEgPSAkLmV4dGVuZChcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuZGF0YSxcblx0XHRcdFx0XHRcdFx0XHRcdF9nZXRFbGVtZW50RGF0YUFzRGljdCgkdWwpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRGVC53YXJuKFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJObyBgc291cmNlYCBvcHRpb24gd2FzIHBhc3NlZCBhbmQgY29udGFpbmVyIGRvZXMgbm90IGNvbnRhaW4gYDx1bD5gOiBhc3N1bWluZyBgc291cmNlOiBbXWAuXCJcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdHNvdXJjZSA9IFtdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBcImpzb25cIjpcblx0XHRcdFx0XHRcdFx0c291cmNlID0gJC5wYXJzZUpTT04oJGNvbnRhaW5lci50ZXh0KCkpO1xuXHRcdFx0XHRcdFx0XHQvLyAkY29udGFpbmVyIGFscmVhZHkgY29udGFpbnMgdGhlIDx1bD4sIGJ1dCB3ZSByZW1vdmUgdGhlIHBsYWluIChqc29uKSB0ZXh0XG5cdFx0XHRcdFx0XHRcdC8vICRjb250YWluZXIuZW1wdHkoKTtcblx0XHRcdFx0XHRcdFx0JGNvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHRcdC5jb250ZW50cygpXG5cdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAzO1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdFx0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBXZSBnb3Qge2ZvbzogJ2FiYycsIGNoaWxkcmVuOiBbLi4uXX1cblx0XHRcdFx0XHRcdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHRcdFx0XHRcdFx0JC5pc0FycmF5KHNvdXJjZS5jaGlsZHJlbiksXG5cdFx0XHRcdFx0XHRcdFx0XHRcImlmIGFuIG9iamVjdCBpcyBwYXNzZWQgYXMgc291cmNlLCBpdCBtdXN0IGNvbnRhaW4gYSAnY2hpbGRyZW4nIGFycmF5IChhbGwgb3RoZXIgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gJ3RyZWUuZGF0YScpXCJcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdG1ldGFEYXRhID0gc291cmNlO1xuXHRcdFx0XHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZS5jaGlsZHJlbjtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgbWV0YURhdGEuY2hpbGRyZW47XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29weSBzb21lIGF0dHJpYnV0ZXMgdG8gdHJlZS5kYXRhXG5cdFx0XHRcdFx0XHRcdFx0JC5lYWNoKFRSRUVfQVRUUlMsIGZ1bmN0aW9uKGksIGF0dHIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChtZXRhRGF0YVthdHRyXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyZWVbYXR0cl0gPSBtZXRhRGF0YVthdHRyXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG1ldGFEYXRhW2F0dHJdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvcHkgZXh0cmEgcHJvcGVydGllcyB0byB0cmVlLmRhdGEuZm9vXG5cdFx0XHRcdFx0XHRcdFx0JC5leHRlbmQodHJlZS5kYXRhLCBtZXRhRGF0YSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHQkLmVycm9yKFwiSW52YWxpZCBkYXRhLXR5cGU6IFwiICsgdHlwZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHQvLyBUT0RPOiBzb3VyY2UgaXMgYW4gZWxlbWVudCBJRFxuXHRcdFx0XHRcdCQuZXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBwcmVJbml0IGlzIGZpcmVkIHdoZW4gdGhlIHdpZGdldCBtYXJrdXAgaXMgY3JlYXRlZCwgYnV0IG5vZGVzXG5cdFx0XHRcdC8vIG5vdCB5ZXQgbG9hZGVkXG5cdFx0XHRcdHRyZWUuX3RyaWdnZXJUcmVlRXZlbnQoXCJwcmVJbml0XCIsIG51bGwpO1xuXG5cdFx0XHRcdC8vIFRyaWdnZXIgZmFuY3l0cmVlaW5pdCBhZnRlciBub2RlcyBoYXZlIGJlZW4gbG9hZGVkXG5cdFx0XHRcdGRmZCA9IHRoaXMubm9kZUxvYWRDaGlsZHJlbihyb290Q3R4LCBzb3VyY2UpXG5cdFx0XHRcdFx0LmRvbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0cmVlLl9jYWxsSG9vayhcblx0XHRcdFx0XHRcdFx0XCJ0cmVlU3RydWN0dXJlQ2hhbmdlZFwiLFxuXHRcdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRcdFwibG9hZENoaWxkcmVuXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR0cmVlLnJlbmRlcigpO1xuXHRcdFx0XHRcdFx0aWYgKGN0eC5vcHRpb25zLnNlbGVjdE1vZGUgPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0dHJlZS5yb290Tm9kZS5maXhTZWxlY3Rpb24zRnJvbUVuZE5vZGVzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAodHJlZS5hY3RpdmVOb2RlICYmIHRyZWUub3B0aW9ucy5hY3RpdmVWaXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRcdHRyZWUuYWN0aXZlTm9kZS5tYWtlVmlzaWJsZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJlZS5fdHJpZ2dlclRyZWVFdmVudChcImluaXRcIiwgbnVsbCwgeyBzdGF0dXM6IHRydWUgfSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQuZmFpbChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRyZWUucmVuZGVyKCk7XG5cdFx0XHRcdFx0XHR0cmVlLl90cmlnZ2VyVHJlZUV2ZW50KFwiaW5pdFwiLCBudWxsLCB7IHN0YXR1czogZmFsc2UgfSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBkZmQ7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIE5vZGUgd2FzIGluc2VydGVkIGludG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLlxuXHRcdFx0ICogQHBhcmFtIHtFdmVudERhdGF9IGN0eFxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBhZGRcblx0XHRcdCAqIEBwYXJhbSB7RmFuY3l0cmVlTm9kZX0gbm9kZVxuXHRcdFx0ICovXG5cdFx0XHR0cmVlUmVnaXN0ZXJOb2RlOiBmdW5jdGlvbihjdHgsIGFkZCwgbm9kZSkge1xuXHRcdFx0XHRjdHgudHJlZS5fY2FsbEhvb2soXG5cdFx0XHRcdFx0XCJ0cmVlU3RydWN0dXJlQ2hhbmdlZFwiLFxuXHRcdFx0XHRcdGN0eCxcblx0XHRcdFx0XHRhZGQgPyBcImFkZE5vZGVcIiA6IFwicmVtb3ZlTm9kZVwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFdpZGdldCBnb3QgZm9jdXMuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbGFnPXRydWVdXG5cdFx0XHQgKi9cblx0XHRcdHRyZWVTZXRGb2N1czogZnVuY3Rpb24oY3R4LCBmbGFnLCBjYWxsT3B0cykge1xuXHRcdFx0XHR2YXIgdGFyZ2V0Tm9kZTtcblxuXHRcdFx0XHRmbGFnID0gZmxhZyAhPT0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcInRyZWVTZXRGb2N1cyhcIiArIGZsYWcgKyBcIiksIGNhbGxPcHRzOiBcIiwgY2FsbE9wdHMsIHRoaXMuaGFzRm9jdXMoKSk7XG5cdFx0XHRcdC8vIHRoaXMuZGVidWcoXCIgICAgZm9jdXNOb2RlOiBcIiArIHRoaXMuZm9jdXNOb2RlKTtcblx0XHRcdFx0Ly8gdGhpcy5kZWJ1ZyhcIiAgICBhY3RpdmVOb2RlOiBcIiArIHRoaXMuYWN0aXZlTm9kZSk7XG5cdFx0XHRcdGlmIChmbGFnICE9PSB0aGlzLmhhc0ZvY3VzKCkpIHtcblx0XHRcdFx0XHR0aGlzLl9oYXNGb2N1cyA9IGZsYWc7XG5cdFx0XHRcdFx0aWYgKCFmbGFnICYmIHRoaXMuZm9jdXNOb2RlKSB7XG5cdFx0XHRcdFx0XHQvLyBOb2RlIGFsc28gbG9vc2VzIGZvY3VzIGlmIHdpZGdldCBibHVyc1xuXHRcdFx0XHRcdFx0dGhpcy5mb2N1c05vZGUuc2V0Rm9jdXMoZmFsc2UpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZmxhZyAmJiAoIWNhbGxPcHRzIHx8ICFjYWxsT3B0cy5jYWxsZWRCeU5vZGUpKSB7XG5cdFx0XHRcdFx0XHQkKHRoaXMuJGNvbnRhaW5lcikuZm9jdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy4kY29udGFpbmVyLnRvZ2dsZUNsYXNzKFwiZmFuY3l0cmVlLXRyZWVmb2N1c1wiLCBmbGFnKTtcblx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyVHJlZUV2ZW50KGZsYWcgPyBcImZvY3VzVHJlZVwiIDogXCJibHVyVHJlZVwiKTtcblx0XHRcdFx0XHRpZiAoZmxhZyAmJiAhdGhpcy5hY3RpdmVOb2RlKSB7XG5cdFx0XHRcdFx0XHQvLyAjNzEyOiBVc2UgbGFzdCBtb3VzZWRvd25lZCBub2RlICgnY2xpY2snIGV2ZW50IGZpcmVzIGFmdGVyIGZvY3VzaW4pXG5cdFx0XHRcdFx0XHR0YXJnZXROb2RlID1cblx0XHRcdFx0XHRcdFx0dGhpcy5fbGFzdE1vdXNlZG93bk5vZGUgfHwgdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0Tm9kZSkge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXROb2RlLnNldEZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFdpZGdldCBvcHRpb24gd2FzIHNldCB1c2luZyBgJCgpLmZhbmN5dHJlZShcIm9wdGlvblwiLCBcIktFWVwiLCBWQUxVRSlgLlxuXHRcdFx0ICpcblx0XHRcdCAqIE5vdGU6IGBrZXlgIG1heSByZWZlcmVuY2UgYSBuZXN0ZWQgb3B0aW9uLCBlLmcuICdkbmQ1LnNjcm9sbCcuXG5cdFx0XHQgKiBJbiB0aGlzIGNhc2UgYHZhbHVlYGNvbnRhaW5zIHRoZSBjb21wbGV0ZSwgbW9kaWZpZWQgYGRuZDVgIG9wdGlvbiBoYXNoLlxuXHRcdFx0ICogV2UgY2FuIGNoZWNrIGZvciBjaGFuZ2VkIHZhbHVlcyBsaWtlXG5cdFx0XHQgKiAgICAgaWYoIHZhbHVlLnNjcm9sbCAhPT0gdHJlZS5vcHRpb25zLmRuZDUuc2Nyb2xsICkgey4uLn1cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IG9wdGlvbiBuYW1lXG5cdFx0XHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgb3B0aW9uIHZhbHVlXG5cdFx0XHQgKi9cblx0XHRcdHRyZWVTZXRPcHRpb246IGZ1bmN0aW9uKGN0eCwga2V5LCB2YWx1ZSkge1xuXHRcdFx0XHR2YXIgdHJlZSA9IGN0eC50cmVlLFxuXHRcdFx0XHRcdGNhbGxEZWZhdWx0ID0gdHJ1ZSxcblx0XHRcdFx0XHRjYWxsQ3JlYXRlID0gZmFsc2UsXG5cdFx0XHRcdFx0Y2FsbFJlbmRlciA9IGZhbHNlO1xuXG5cdFx0XHRcdHN3aXRjaCAoa2V5KSB7XG5cdFx0XHRcdFx0Y2FzZSBcImFyaWFcIjpcblx0XHRcdFx0XHRjYXNlIFwiY2hlY2tib3hcIjpcblx0XHRcdFx0XHRjYXNlIFwiaWNvblwiOlxuXHRcdFx0XHRcdGNhc2UgXCJtaW5FeHBhbmRMZXZlbFwiOlxuXHRcdFx0XHRcdGNhc2UgXCJ0YWJpbmRleFwiOlxuXHRcdFx0XHRcdFx0Ly8gdHJlZS5fY2FsbEhvb2soXCJ0cmVlQ3JlYXRlXCIsIHRyZWUpO1xuXHRcdFx0XHRcdFx0Y2FsbENyZWF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRjYWxsUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJjaGVja2JveEF1dG9IaWRlXCI6XG5cdFx0XHRcdFx0XHR0cmVlLiRjb250YWluZXIudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdFwiZmFuY3l0cmVlLWNoZWNrYm94LWF1dG8taGlkZVwiLFxuXHRcdFx0XHRcdFx0XHQhIXZhbHVlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBcImVzY2FwZVRpdGxlc1wiOlxuXHRcdFx0XHRcdGNhc2UgXCJ0b29sdGlwXCI6XG5cdFx0XHRcdFx0XHRjYWxsUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJydGxcIjpcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0dHJlZS4kY29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdFx0LnJlbW92ZUF0dHIoXCJESVJcIilcblx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJmYW5jeXRyZWUtcnRsXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dHJlZS4kY29udGFpbmVyXG5cdFx0XHRcdFx0XHRcdFx0LmF0dHIoXCJESVJcIiwgXCJSVExcIilcblx0XHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoXCJmYW5jeXRyZWUtcnRsXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbFJlbmRlciA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic291cmNlXCI6XG5cdFx0XHRcdFx0XHRjYWxsRGVmYXVsdCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dHJlZS5fY2FsbEhvb2soXCJ0cmVlTG9hZFwiLCB0cmVlLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRjYWxsUmVuZGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRyZWUuZGVidWcoXG5cdFx0XHRcdFx0XCJzZXQgb3B0aW9uIFwiICtcblx0XHRcdFx0XHRcdGtleSArXG5cdFx0XHRcdFx0XHRcIj1cIiArXG5cdFx0XHRcdFx0XHR2YWx1ZSArXG5cdFx0XHRcdFx0XHRcIiA8XCIgK1xuXHRcdFx0XHRcdFx0dHlwZW9mIHZhbHVlICtcblx0XHRcdFx0XHRcdFwiPlwiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGlmIChjYWxsRGVmYXVsdCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLndpZGdldC5fc3VwZXIpIHtcblx0XHRcdFx0XHRcdC8vIGpRdWVyeSBVSSAxLjkrXG5cdFx0XHRcdFx0XHR0aGlzLndpZGdldC5fc3VwZXIuY2FsbCh0aGlzLndpZGdldCwga2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGpRdWVyeSBVSSA8PSAxLjgsIHdlIGhhdmUgdG8gbWFudWFsbHkgaW52b2tlIHRoZSBfc2V0T3B0aW9uIG1ldGhvZCBmcm9tIHRoZSBiYXNlIHdpZGdldFxuXHRcdFx0XHRcdFx0JC5XaWRnZXQucHJvdG90eXBlLl9zZXRPcHRpb24uY2FsbChcblx0XHRcdFx0XHRcdFx0dGhpcy53aWRnZXQsXG5cdFx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsQ3JlYXRlKSB7XG5cdFx0XHRcdFx0dHJlZS5fY2FsbEhvb2soXCJ0cmVlQ3JlYXRlXCIsIHRyZWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYWxsUmVuZGVyKSB7XG5cdFx0XHRcdFx0dHJlZS5yZW5kZXIodHJ1ZSwgZmFsc2UpOyAvLyBmb3JjZSwgbm90LWRlZXBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKiBBIE5vZGUgd2FzIGFkZGVkLCByZW1vdmVkLCBtb3ZlZCwgb3IgaXQncyB2aXNpYmlsaXR5IGNoYW5nZWQuXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50RGF0YX0gY3R4XG5cdFx0XHQgKi9cblx0XHRcdHRyZWVTdHJ1Y3R1cmVDaGFuZ2VkOiBmdW5jdGlvbihjdHgsIHR5cGUpIHt9LFxuXHRcdH1cblx0KTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBqUXVlcnkgVUkgd2lkZ2V0IGJvaWxlcnBsYXRlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBUaGUgcGx1Z2luIChkZXJyaXZlZCBmcm9tIDxhIGhyZWY9XCIgaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cIj5qUXVlcnkuV2lkZ2V0PC9hPikuPGJyPlxuXHQgKiBUaGlzIGNvbnN0cnVjdG9yIGlzIG5vdCBjYWxsZWQgZGlyZWN0bHkuIFVzZSBgJChzZWxlY3RvcikuZmFuY3l0cmVlKHt9KWBcblx0ICogdG8gaW5pdGlhbGl6ZSB0aGUgcGx1Z2luIGluc3RlYWQuPGJyPlxuXHQgKiA8cHJlIGNsYXNzPVwic2hfamF2YXNjcmlwdCBzdW5saWdodC1oaWdobGlnaHQtamF2YXNjcmlwdFwiPi8vIEFjY2VzcyB3aWRnZXQgbWV0aG9kcyBhbmQgbWVtYmVyczpcblx0ICogdmFyIHRyZWUgPSAkKFwiI3RyZWVcIikuZmFuY3l0cmVlKFwiZ2V0VHJlZVwiKTtcblx0ICogdmFyIG5vZGUgPSAkKFwiI3RyZWVcIikuZmFuY3l0cmVlKFwiZ2V0QWN0aXZlTm9kZVwiLCBcIjEyMzRcIik7XG5cdCAqIDwvcHJlPlxuXHQgKlxuXHQgKiBAbWl4aW4gRmFuY3l0cmVlX1dpZGdldFxuXHQgKi9cblxuXHQkLndpZGdldChcblx0XHRcInVpLmZhbmN5dHJlZVwiLFxuXHRcdC8qKiBAbGVuZHMgRmFuY3l0cmVlX1dpZGdldCMgKi9cblx0XHR7XG5cdFx0XHQvKipUaGVzZSBvcHRpb25zIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0c1xuXHRcdFx0ICogQHR5cGUge0ZhbmN5dHJlZU9wdGlvbnN9XG5cdFx0XHQgKi9cblx0XHRcdG9wdGlvbnM6IHtcblx0XHRcdFx0YWN0aXZlVmlzaWJsZTogdHJ1ZSxcblx0XHRcdFx0YWpheDoge1xuXHRcdFx0XHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0XHRcdFx0Y2FjaGU6IGZhbHNlLCAvLyBmYWxzZTogQXBwZW5kIHJhbmRvbSAnXycgYXJndW1lbnQgdG8gdGhlIHJlcXVlc3QgdXJsIHRvIHByZXZlbnQgY2FjaGluZy5cblx0XHRcdFx0XHQvLyB0aW1lb3V0OiAwLCAvLyA+MDogTWFrZSBzdXJlIHdlIGdldCBhbiBhamF4IGVycm9yIGlmIHNlcnZlciBpcyB1bnJlYWNoYWJsZVxuXHRcdFx0XHRcdGRhdGFUeXBlOiBcImpzb25cIiwgLy8gRXhwZWN0IGpzb24gZm9ybWF0IGFuZCBwYXNzIGpzb24gb2JqZWN0IHRvIGNhbGxiYWNrcy5cblx0XHRcdFx0fSxcblx0XHRcdFx0YXJpYTogdHJ1ZSxcblx0XHRcdFx0YXV0b0FjdGl2YXRlOiB0cnVlLFxuXHRcdFx0XHRhdXRvQ29sbGFwc2U6IGZhbHNlLFxuXHRcdFx0XHRhdXRvU2Nyb2xsOiBmYWxzZSxcblx0XHRcdFx0Y2hlY2tib3g6IGZhbHNlLFxuXHRcdFx0XHRjbGlja0ZvbGRlck1vZGU6IDQsXG5cdFx0XHRcdGRlYnVnTGV2ZWw6IG51bGwsIC8vIDAuLjQgKG51bGw6IHVzZSBnbG9iYWwgc2V0dGluZyAkLnVpLmZhbmN5dHJlZS5kZWJ1Z0xldmVsKVxuXHRcdFx0XHRkaXNhYmxlZDogZmFsc2UsIC8vIFRPRE86IHJlcXVpcmVkIGFueW1vcmU/XG5cdFx0XHRcdGVuYWJsZUFzcHg6IHRydWUsXG5cdFx0XHRcdGVzY2FwZVRpdGxlczogZmFsc2UsXG5cdFx0XHRcdGV4dGVuc2lvbnM6IFtdLFxuXHRcdFx0XHQvLyBmeDogeyBoZWlnaHQ6IFwidG9nZ2xlXCIsIGR1cmF0aW9uOiAyMDAgfSxcblx0XHRcdFx0Ly8gdG9nZ2xlRWZmZWN0OiB7IGVmZmVjdDogXCJkcm9wXCIsIG9wdGlvbnM6IHtkaXJlY3Rpb246IFwibGVmdFwifSwgZHVyYXRpb246IDIwMCB9LFxuXHRcdFx0XHQvLyB0b2dnbGVFZmZlY3Q6IHsgZWZmZWN0OiBcInNsaWRlXCIsIG9wdGlvbnM6IHtkaXJlY3Rpb246IFwidXBcIn0sIGR1cmF0aW9uOiAyMDAgfSxcblx0XHRcdFx0Ly90b2dnbGVFZmZlY3Q6IHsgZWZmZWN0OiBcImJsaW5kXCIsIG9wdGlvbnM6IHtkaXJlY3Rpb246IFwidmVydGljYWxcIiwgc2NhbGU6IFwiYm94XCJ9LCBkdXJhdGlvbjogMjAwIH0sXG5cdFx0XHRcdHRvZ2dsZUVmZmVjdDogeyBlZmZlY3Q6IFwic2xpZGVUb2dnbGVcIiwgZHVyYXRpb246IDIwMCB9LCAvLzwgXCJ0b2dnbGVcIiBvciBcInNsaWRlVG9nZ2xlXCIgdG8gdXNlIGpRdWVyeSBpbnN0ZWFkIG9mIGpRdWVyeVVJIGZvciB0b2dnbGVFZmZlY3QgYW5pbWF0aW9uXG5cdFx0XHRcdGdlbmVyYXRlSWRzOiBmYWxzZSxcblx0XHRcdFx0aWNvbjogdHJ1ZSxcblx0XHRcdFx0aWRQcmVmaXg6IFwiZnRfXCIsXG5cdFx0XHRcdGZvY3VzT25TZWxlY3Q6IGZhbHNlLFxuXHRcdFx0XHRrZXlib2FyZDogdHJ1ZSxcblx0XHRcdFx0a2V5UGF0aFNlcGFyYXRvcjogXCIvXCIsXG5cdFx0XHRcdG1pbkV4cGFuZExldmVsOiAxLFxuXHRcdFx0XHRub2RhdGE6IHRydWUsIC8vIChib29sLCBzdHJpbmcsIG9yIGNhbGxiYWNrKSBkaXNwbGF5IG1lc3NhZ2UsIHdoZW4gbm8gZGF0YSBhdmFpbGFibGVcblx0XHRcdFx0cXVpY2tzZWFyY2g6IGZhbHNlLFxuXHRcdFx0XHRydGw6IGZhbHNlLFxuXHRcdFx0XHRzY3JvbGxPZnM6IHsgdG9wOiAwLCBib3R0b206IDAgfSxcblx0XHRcdFx0c2Nyb2xsUGFyZW50OiBudWxsLFxuXHRcdFx0XHRzZWxlY3RNb2RlOiAyLFxuXHRcdFx0XHRzdHJpbmdzOiB7XG5cdFx0XHRcdFx0bG9hZGluZzogXCJMb2FkaW5nLi4uXCIsIC8vICYjODIzMDsgd291bGQgYmUgZXNjYXBlZCB3aGVuIGVzY2FwZVRpdGxlcyBpcyB0cnVlXG5cdFx0XHRcdFx0bG9hZEVycm9yOiBcIkxvYWQgZXJyb3IhXCIsXG5cdFx0XHRcdFx0bW9yZURhdGE6IFwiTW9yZS4uLlwiLFxuXHRcdFx0XHRcdG5vRGF0YTogXCJObyBkYXRhLlwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR0YWJpbmRleDogXCIwXCIsXG5cdFx0XHRcdHRpdGxlc1RhYmJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dG9vbHRpcDogZmFsc2UsXG5cdFx0XHRcdHRyZWVJZDogbnVsbCxcblx0XHRcdFx0X2NsYXNzTmFtZXM6IHtcblx0XHRcdFx0XHRub2RlOiBcImZhbmN5dHJlZS1ub2RlXCIsXG5cdFx0XHRcdFx0Zm9sZGVyOiBcImZhbmN5dHJlZS1mb2xkZXJcIixcblx0XHRcdFx0XHRhbmltYXRpbmc6IFwiZmFuY3l0cmVlLWFuaW1hdGluZ1wiLFxuXHRcdFx0XHRcdGNvbWJpbmVkRXhwYW5kZXJQcmVmaXg6IFwiZmFuY3l0cmVlLWV4cC1cIixcblx0XHRcdFx0XHRjb21iaW5lZEljb25QcmVmaXg6IFwiZmFuY3l0cmVlLWljby1cIixcblx0XHRcdFx0XHRoYXNDaGlsZHJlbjogXCJmYW5jeXRyZWUtaGFzLWNoaWxkcmVuXCIsXG5cdFx0XHRcdFx0YWN0aXZlOiBcImZhbmN5dHJlZS1hY3RpdmVcIixcblx0XHRcdFx0XHRzZWxlY3RlZDogXCJmYW5jeXRyZWUtc2VsZWN0ZWRcIixcblx0XHRcdFx0XHRleHBhbmRlZDogXCJmYW5jeXRyZWUtZXhwYW5kZWRcIixcblx0XHRcdFx0XHRsYXp5OiBcImZhbmN5dHJlZS1sYXp5XCIsXG5cdFx0XHRcdFx0Zm9jdXNlZDogXCJmYW5jeXRyZWUtZm9jdXNlZFwiLFxuXHRcdFx0XHRcdHBhcnRsb2FkOiBcImZhbmN5dHJlZS1wYXJ0bG9hZFwiLFxuXHRcdFx0XHRcdHBhcnRzZWw6IFwiZmFuY3l0cmVlLXBhcnRzZWxcIixcblx0XHRcdFx0XHRyYWRpbzogXCJmYW5jeXRyZWUtcmFkaW9cIixcblx0XHRcdFx0XHQvLyByYWRpb2dyb3VwOiBcImZhbmN5dHJlZS1yYWRpb2dyb3VwXCIsXG5cdFx0XHRcdFx0dW5zZWxlY3RhYmxlOiBcImZhbmN5dHJlZS11bnNlbGVjdGFibGVcIixcblx0XHRcdFx0XHRsYXN0c2liOiBcImZhbmN5dHJlZS1sYXN0c2liXCIsXG5cdFx0XHRcdFx0bG9hZGluZzogXCJmYW5jeXRyZWUtbG9hZGluZ1wiLFxuXHRcdFx0XHRcdGVycm9yOiBcImZhbmN5dHJlZS1lcnJvclwiLFxuXHRcdFx0XHRcdHN0YXR1c05vZGVQcmVmaXg6IFwiZmFuY3l0cmVlLXN0YXR1c25vZGUtXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGV2ZW50c1xuXHRcdFx0XHRsYXp5TG9hZDogbnVsbCxcblx0XHRcdFx0cG9zdFByb2Nlc3M6IG51bGwsXG5cdFx0XHR9LFxuXHRcdFx0LyogU2V0IHVwIHRoZSB3aWRnZXQsIENhbGxlZCBvbiBmaXJzdCAkKCkuZmFuY3l0cmVlKCkgKi9cblx0XHRcdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRyZWUgPSBuZXcgRmFuY3l0cmVlKHRoaXMpO1xuXG5cdFx0XHRcdHRoaXMuJHNvdXJjZSA9XG5cdFx0XHRcdFx0dGhpcy5zb3VyY2UgfHwgdGhpcy5lbGVtZW50LmRhdGEoXCJ0eXBlXCIpID09PSBcImpzb25cIlxuXHRcdFx0XHRcdFx0PyB0aGlzLmVsZW1lbnRcblx0XHRcdFx0XHRcdDogdGhpcy5lbGVtZW50LmZpbmQoXCI+dWxcIikuZmlyc3QoKTtcblx0XHRcdFx0Ly8gU3ViY2xhc3MgRmFuY3l0cmVlIGluc3RhbmNlIHdpdGggYWxsIGVuYWJsZWQgZXh0ZW5zaW9uc1xuXHRcdFx0XHR2YXIgZXh0ZW5zaW9uLFxuXHRcdFx0XHRcdGV4dE5hbWUsXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRvcHRzID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRcdGV4dGVuc2lvbnMgPSBvcHRzLmV4dGVuc2lvbnMsXG5cdFx0XHRcdFx0YmFzZSA9IHRoaXMudHJlZTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGV4dE5hbWUgPSBleHRlbnNpb25zW2ldO1xuXHRcdFx0XHRcdGV4dGVuc2lvbiA9ICQudWkuZmFuY3l0cmVlLl9leHRlbnNpb25zW2V4dE5hbWVdO1xuXHRcdFx0XHRcdGlmICghZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdFx0XHQkLmVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkNvdWxkIG5vdCBhcHBseSBleHRlbnNpb24gJ1wiICtcblx0XHRcdFx0XHRcdFx0XHRleHROYW1lICtcblx0XHRcdFx0XHRcdFx0XHRcIicgKGl0IGlzIG5vdCByZWdpc3RlcmVkLCBkaWQgeW91IGZvcmdldCB0byBpbmNsdWRlIGl0PylcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQWRkIGV4dGVuc2lvbiBvcHRpb25zIGFzIHRyZWUub3B0aW9ucy5FWFRFTlNJT05cblx0XHRcdFx0XHQvLyBcdF9hc3NlcnQoIXRoaXMudHJlZS5vcHRpb25zW2V4dE5hbWVdLCBcIkV4dGVuc2lvbiBuYW1lIG11c3Qgbm90IGV4aXN0IGFzIG9wdGlvbiBuYW1lOiBcIiArIGV4dE5hbWUpO1xuXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5pbmZvKFwiZXh0ZW5kIFwiICsgZXh0TmFtZSwgZXh0ZW5zaW9uLm9wdGlvbnMsIHRoaXMudHJlZS5vcHRpb25zW2V4dE5hbWVdKVxuXHRcdFx0XHRcdC8vIGlzc3VlICM4NzY6IHdlIHdhbnQgdG8gcmVwbGFjZSBjdXN0b20gYXJyYXktb3B0aW9ucywgbm90IG1lcmdlIHRoZW1cblx0XHRcdFx0XHR0aGlzLnRyZWUub3B0aW9uc1tleHROYW1lXSA9IF9zaW1wbGVEZWVwTWVyZ2UoXG5cdFx0XHRcdFx0XHR7fSxcblx0XHRcdFx0XHRcdGV4dGVuc2lvbi5vcHRpb25zLFxuXHRcdFx0XHRcdFx0dGhpcy50cmVlLm9wdGlvbnNbZXh0TmFtZV1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdC8vIHRoaXMudHJlZS5vcHRpb25zW2V4dE5hbWVdID0gJC5leHRlbmQodHJ1ZSwge30sIGV4dGVuc2lvbi5vcHRpb25zLCB0aGlzLnRyZWUub3B0aW9uc1tleHROYW1lXSk7XG5cblx0XHRcdFx0XHQvLyBjb25zb2xlLmluZm8oXCJleHRlbmQgXCIgKyBleHROYW1lICsgXCIgPT5cIiwgdGhpcy50cmVlLm9wdGlvbnNbZXh0TmFtZV0pXG5cdFx0XHRcdFx0Ly8gY29uc29sZS5pbmZvKFwiZXh0ZW5kIFwiICsgZXh0TmFtZSArIFwiIG9yZyBkZWZhdWx0ID0+XCIsIGV4dGVuc2lvbi5vcHRpb25zKVxuXG5cdFx0XHRcdFx0Ly8gQWRkIGEgbmFtZXNwYWNlIHRyZWUuZXh0LkVYVEVOU0lPTiwgdG8gaG9sZCBpbnN0YW5jZSBkYXRhXG5cdFx0XHRcdFx0X2Fzc2VydChcblx0XHRcdFx0XHRcdHRoaXMudHJlZS5leHRbZXh0TmFtZV0gPT09IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFwiRXh0ZW5zaW9uIG5hbWUgbXVzdCBub3QgZXhpc3QgYXMgRmFuY3l0cmVlLmV4dCBhdHRyaWJ1dGU6ICdcIiArXG5cdFx0XHRcdFx0XHRcdGV4dE5hbWUgK1xuXHRcdFx0XHRcdFx0XHRcIidcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Ly8gdGhpcy50cmVlW2V4dE5hbWVdID0gZXh0ZW5zaW9uO1xuXHRcdFx0XHRcdHRoaXMudHJlZS5leHRbZXh0TmFtZV0gPSB7fTtcblx0XHRcdFx0XHQvLyBTdWJjbGFzcyBGYW5jeXRyZWUgbWV0aG9kcyB1c2luZyBwcm94aWVzLlxuXHRcdFx0XHRcdF9zdWJjbGFzc09iamVjdCh0aGlzLnRyZWUsIGJhc2UsIGV4dGVuc2lvbiwgZXh0TmFtZSk7XG5cdFx0XHRcdFx0Ly8gY3VycmVudCBleHRlbnNpb24gYmVjb21lcyBiYXNlIGZvciB0aGUgbmV4dCBleHRlbnNpb25cblx0XHRcdFx0XHRiYXNlID0gZXh0ZW5zaW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChvcHRzLmljb25zICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyAyMDE1LTExLTE2XG5cdFx0XHRcdFx0aWYgKG9wdHMuaWNvbiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0dGhpcy50cmVlLndhcm4oXG5cdFx0XHRcdFx0XHRcdFwiJ2ljb25zJyB0cmVlIG9wdGlvbiBpcyBkZXByZWNhdGVkIHNpbmNlIHYyLjE0LjA6IHVzZSAnaWNvbicgaW5zdGVhZFwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0b3B0cy5pY29uID0gb3B0cy5pY29ucztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0JC5lcnJvcihcblx0XHRcdFx0XHRcdFx0XCInaWNvbnMnIHRyZWUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuMTQuMDogdXNlICdpY29uJyBvbmx5IGluc3RlYWRcIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdHMuaWNvbkNsYXNzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyAyMDE1LTExLTE2XG5cdFx0XHRcdFx0aWYgKG9wdHMuaWNvbikge1xuXHRcdFx0XHRcdFx0JC5lcnJvcihcblx0XHRcdFx0XHRcdFx0XCInaWNvbkNsYXNzJyB0cmVlIG9wdGlvbiBpcyBkZXByZWNhdGVkIHNpbmNlIHYyLjE0LjA6IHVzZSAnaWNvbicgb25seSBpbnN0ZWFkXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMudHJlZS53YXJuKFxuXHRcdFx0XHRcdFx0XHRcIidpY29uQ2xhc3MnIHRyZWUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuMTQuMDogdXNlICdpY29uJyBpbnN0ZWFkXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRvcHRzLmljb24gPSBvcHRzLmljb25DbGFzcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdHMudGFiYmFibGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIDIwMTYtMDQtMDRcblx0XHRcdFx0XHRvcHRzLnRhYmluZGV4ID0gb3B0cy50YWJiYWJsZSA/IFwiMFwiIDogXCItMVwiO1xuXHRcdFx0XHRcdHRoaXMudHJlZS53YXJuKFxuXHRcdFx0XHRcdFx0XCIndGFiYmFibGUnIHRyZWUgb3B0aW9uIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuMTcuMDogdXNlICd0YWJpbmRleD0nXCIgK1xuXHRcdFx0XHRcdFx0XHRvcHRzLnRhYmluZGV4ICtcblx0XHRcdFx0XHRcdFx0XCInIGluc3RlYWRcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly9cblx0XHRcdFx0dGhpcy50cmVlLl9jYWxsSG9vayhcInRyZWVDcmVhdGVcIiwgdGhpcy50cmVlKTtcblx0XHRcdFx0Ly8gTm90ZTogJ2ZhbmN5dHJlZWNyZWF0ZScgZXZlbnQgaXMgZmlyZWQgYnkgd2lkZ2V0IGJhc2UgY2xhc3Ncblx0XHRcdFx0Ly8gICAgICAgIHRoaXMudHJlZS5fdHJpZ2dlclRyZWVFdmVudChcImNyZWF0ZVwiKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qIENhbGxlZCBvbiBldmVyeSAkKCkuZmFuY3l0cmVlKCkgKi9cblx0XHRcdF9pbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy50cmVlLl9jYWxsSG9vayhcInRyZWVJbml0XCIsIHRoaXMudHJlZSk7XG5cdFx0XHRcdC8vIFRPRE86IGN1cnJlbnRseSB3ZSBjYWxsIGJpbmQgYWZ0ZXIgdHJlZUluaXQsIGJlY2F1c2UgdHJlZUluaXRcblx0XHRcdFx0Ly8gbWlnaHQgY2hhbmdlIHRyZWUuJGNvbnRhaW5lci5cblx0XHRcdFx0Ly8gSXQgd291bGQgYmUgYmV0dGVyLCB0byBtb3ZlIGV2ZW50IGJpbmRpbmcgaW50byBob29rcyBhbHRvZ2V0aGVyXG5cdFx0XHRcdHRoaXMuX2JpbmQoKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qIFVzZSB0aGUgX3NldE9wdGlvbiBtZXRob2QgdG8gcmVzcG9uZCB0byBjaGFuZ2VzIHRvIG9wdGlvbnMuICovXG5cdFx0XHRfc2V0T3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyZWUuX2NhbGxIb29rKFxuXHRcdFx0XHRcdFwidHJlZVNldE9wdGlvblwiLFxuXHRcdFx0XHRcdHRoaXMudHJlZSxcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0KTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKiBVc2UgdGhlIGRlc3Ryb3kgbWV0aG9kIHRvIGNsZWFuIHVwIGFueSBtb2RpZmljYXRpb25zIHlvdXIgd2lkZ2V0IGhhcyBtYWRlIHRvIHRoZSBET00gKi9cblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl91bmJpbmQoKTtcblx0XHRcdFx0dGhpcy50cmVlLl9jYWxsSG9vayhcInRyZWVEZXN0cm95XCIsIHRoaXMudHJlZSk7XG5cdFx0XHRcdC8vIEluIGpRdWVyeSBVSSAxLjgsIHlvdSBtdXN0IGludm9rZSB0aGUgZGVzdHJveSBtZXRob2QgZnJvbSB0aGUgYmFzZSB3aWRnZXRcblx0XHRcdFx0JC5XaWRnZXQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblx0XHRcdFx0Ly8gVE9ETzogZGVsZXRlIHRyZWUgYW5kIG5vZGVzIHRvIG1ha2UgZ2FyYmFnZSBjb2xsZWN0IGVhc2llcj9cblx0XHRcdFx0Ly8gVE9ETzogSW4galF1ZXJ5IFVJIDEuOSBhbmQgYWJvdmUsIHlvdSB3b3VsZCBkZWZpbmUgX2Rlc3Ryb3kgaW5zdGVhZCBvZiBkZXN0cm95IGFuZCBub3QgY2FsbCB0aGUgYmFzZSBtZXRob2Rcblx0XHRcdH0sXG5cblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRcdFx0LyogUmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBmb3Igb3VyIG5hbWVzcGFjZSAqL1xuXHRcdFx0X3VuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBucyA9IHRoaXMudHJlZS5fbnM7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5vZmYobnMpO1xuXHRcdFx0XHR0aGlzLnRyZWUuJGNvbnRhaW5lci5vZmYobnMpO1xuXHRcdFx0XHQkKGRvY3VtZW50KS5vZmYobnMpO1xuXHRcdFx0fSxcblx0XHRcdC8qIEFkZCBtb3VzZSBhbmQga3lib2FyZCBoYW5kbGVycyB0byB0aGUgY29udGFpbmVyICovXG5cdFx0XHRfYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdFx0XHRvcHRzID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0XHRcdHRyZWUgPSB0aGlzLnRyZWUsXG5cdFx0XHRcdFx0bnMgPSB0cmVlLl9ucztcblx0XHRcdFx0Ly8gc2Vsc3RhcnRFdmVudCA9ICggJC5zdXBwb3J0LnNlbGVjdHN0YXJ0ID8gXCJzZWxlY3RzdGFydFwiIDogXCJtb3VzZWRvd25cIiApXG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFsbCBwcmV2aXVvdXMgaGFuZGxlcnMgZm9yIHRoaXMgdHJlZVxuXHRcdFx0XHR0aGlzLl91bmJpbmQoKTtcblxuXHRcdFx0XHQvL2FsZXJ0KFwia2V5ZG93blwiICsgbnMgKyBcImZvYz1cIiArIHRyZWUuaGFzRm9jdXMoKSArIHRyZWUuJGNvbnRhaW5lcik7XG5cdFx0XHRcdC8vIHRyZWUuZGVidWcoXCJiaW5kIGV2ZW50czsgY29udGFpbmVyOiBcIiwgdHJlZS4kY29udGFpbmVyKTtcblx0XHRcdFx0dHJlZS4kY29udGFpbmVyXG5cdFx0XHRcdFx0Lm9uKFwiZm9jdXNpblwiICsgbnMgKyBcIiBmb2N1c291dFwiICsgbnMsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHR2YXIgbm9kZSA9IEZULmdldE5vZGUoZXZlbnQpLFxuXHRcdFx0XHRcdFx0XHRmbGFnID0gZXZlbnQudHlwZSA9PT0gXCJmb2N1c2luXCI7XG5cblx0XHRcdFx0XHRcdGlmICghZmxhZyAmJiBub2RlICYmICQoZXZlbnQudGFyZ2V0KS5pcyhcImFcIikpIHtcblx0XHRcdFx0XHRcdFx0Ly8gIzc2NFxuXHRcdFx0XHRcdFx0XHRub2RlLmRlYnVnKFxuXHRcdFx0XHRcdFx0XHRcdFwiSWdub3JlZCBmb2N1c291dCBvbiBlbWJlZGRlZCA8YT4gZWxlbWVudC5cIlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyB0cmVlLnRyZWVPbkZvY3VzSW5PdXQuY2FsbCh0cmVlLCBldmVudCk7XG5cdFx0XHRcdFx0XHQvLyB0cmVlLmRlYnVnKFwiVHJlZSBjb250YWluZXIgZ290IGV2ZW50IFwiICsgZXZlbnQudHlwZSwgbm9kZSwgZXZlbnQsIEZULmdldEV2ZW50VGFyZ2V0KGV2ZW50KSk7XG5cdFx0XHRcdFx0XHRpZiAoZmxhZykge1xuXHRcdFx0XHRcdFx0XHRpZiAodHJlZS5fZ2V0RXhwaXJpbmdWYWx1ZShcImZvY3VzaW5cIikpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAjNzg5OiBJRSAxMSBtYXkgc2VuZCBkdXBsaWNhdGUgZm9jdXNpbiBldmVudHNcblx0XHRcdFx0XHRcdFx0XHR0cmVlLmRlYnVnKFwiSWdub3JlZCBkb3VibGUgZm9jdXNpbi5cIik7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRyZWUuX3NldEV4cGlyaW5nVmFsdWUoXCJmb2N1c2luXCIsIHRydWUsIDUwKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIW5vZGUpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAjNzg5OiBJRSAxMSBtYXkgc2VuZCBmb2N1c2luIGJlZm9yZSBtb3VzZG93big/KVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSB0cmVlLl9nZXRFeHBpcmluZ1ZhbHVlKFwibW91c2VEb3duTm9kZVwiKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJlZS5kZWJ1Zyhcblx0XHRcdFx0XHRcdFx0XHRcdFx0XCJSZWNvbnN0cnVjdCBtb3VzZSB0YXJnZXQgZm9yIGZvY3VzaW4gZnJvbSByZWNlbnQgZXZlbnQuXCJcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdFx0XHQvLyBGb3IgZXhhbXBsZSBjbGlja2luZyBpbnRvIGFuIDxpbnB1dD4gdGhhdCBpcyBwYXJ0IG9mIGEgbm9kZVxuXHRcdFx0XHRcdFx0XHR0cmVlLl9jYWxsSG9vayhcblx0XHRcdFx0XHRcdFx0XHRcIm5vZGVTZXRGb2N1c1wiLFxuXHRcdFx0XHRcdFx0XHRcdHRyZWUuX21ha2VIb29rQ29udGV4dChub2RlLCBldmVudCksXG5cdFx0XHRcdFx0XHRcdFx0ZmxhZ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdHRyZWUudGJvZHkgJiZcblx0XHRcdFx0XHRcdFx0XHQkKGV2ZW50LnRhcmdldCkucGFyZW50cyhcblx0XHRcdFx0XHRcdFx0XHRcdFwidGFibGUuZmFuY3l0cmVlLWNvbnRhaW5lciA+IHRoZWFkXCJcblx0XHRcdFx0XHRcdFx0XHQpLmxlbmd0aFxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAjNzY3OiBpZ25vcmUgZXZlbnRzIGluIHRoZSB0YWJsZSdzIGhlYWRlclxuXHRcdFx0XHRcdFx0XHRcdHRyZWUuZGVidWcoXG5cdFx0XHRcdFx0XHRcdFx0XHRcIklnbm9yZSBmb2N1cyBldmVudCBvdXRzaWRlIHRhYmxlIGJvZHkuXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJlZS5fY2FsbEhvb2soXCJ0cmVlU2V0Rm9jdXNcIiwgdHJlZSwgZmxhZyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5vbihcInNlbGVjdHN0YXJ0XCIgKyBucywgXCJzcGFuLmZhbmN5dHJlZS10aXRsZVwiLCBmdW5jdGlvbihcblx0XHRcdFx0XHRcdGV2ZW50XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IG1vdXNlLWRyYWdzIHRvIHNlbGVjdCB0ZXh0IHJhbmdlc1xuXHRcdFx0XHRcdFx0Ly8gdHJlZS5kZWJ1ZyhcIjxzcGFuIHRpdGxlPiBnb3QgZXZlbnQgXCIgKyBldmVudC50eXBlKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQub24oXCJrZXlkb3duXCIgKyBucywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IGFsc28gYmluZCBrZXl1cCBhbmQga2V5cHJlc3Ncblx0XHRcdFx0XHRcdC8vIHRyZWUuZGVidWcoXCJnb3QgZXZlbnQgXCIgKyBldmVudC50eXBlICsgXCIsIGhhc0ZvY3VzOlwiICsgdHJlZS5oYXNGb2N1cygpKTtcblx0XHRcdFx0XHRcdC8vIGlmKG9wdHMuZGlzYWJsZWQgfHwgb3B0cy5rZXlib2FyZCA9PT0gZmFsc2UgfHwgIXRyZWUuaGFzRm9jdXMoKSApe1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuZGlzYWJsZWQgfHwgb3B0cy5rZXlib2FyZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgcmVzLFxuXHRcdFx0XHRcdFx0XHRub2RlID0gdHJlZS5mb2N1c05vZGUsIC8vIG5vZGUgbWF5IGJlIG51bGxcblx0XHRcdFx0XHRcdFx0Y3R4ID0gdHJlZS5fbWFrZUhvb2tDb250ZXh0KG5vZGUgfHwgdHJlZSwgZXZlbnQpLFxuXHRcdFx0XHRcdFx0XHRwcmV2UGhhc2UgPSB0cmVlLnBoYXNlO1xuXG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHR0cmVlLnBoYXNlID0gXCJ1c2VyRXZlbnRcIjtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgYSAnZmFuY3l0cmVla2V5ZG93bicgaGFuZGxlciByZXR1cm5zIGZhbHNlLCBza2lwIHRoZSBkZWZhdWx0XG5cdFx0XHRcdFx0XHRcdC8vIGhhbmRsaW5nIChpbXBsZW1lbnRlZCBieSB0cmVlLm5vZGVLZXlkb3duKCkpLlxuXHRcdFx0XHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcyA9IHRyZWUuX3RyaWdnZXJOb2RlRXZlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcImtleWRvd25cIixcblx0XHRcdFx0XHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzID0gdHJlZS5fdHJpZ2dlclRyZWVFdmVudChcImtleWRvd25cIiwgZXZlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmIChyZXMgPT09IFwicHJldmVudE5hdlwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzID0gdHJ1ZTsgLy8gcHJldmVudCBrZXlib2FyZCBuYXZpZ2F0aW9uLCBidXQgZG9uJ3QgcHJldmVudCBkZWZhdWx0IGhhbmRsaW5nIG9mIGVtYmVkZGVkIGlucHV0IGNvbnRyb2xzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocmVzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcyA9IHRyZWUuX2NhbGxIb29rKFwibm9kZUtleWRvd25cIiwgY3R4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0dHJlZS5waGFzZSA9IHByZXZQaGFzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5vbihcIm1vdXNlZG93blwiICsgbnMsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHR2YXIgZXQgPSBGVC5nZXRFdmVudFRhcmdldChldmVudCk7XG5cdFx0XHRcdFx0XHQvLyBzZWxmLnRyZWUuZGVidWcoXCJldmVudChcIiArIGV2ZW50LnR5cGUgKyBcIik6IG5vZGU6IFwiLCBldC5ub2RlKTtcblx0XHRcdFx0XHRcdC8vICM3MTI6IFN0b3JlIHRoZSBjbGlja2VkIG5vZGUsIHNvIHdlIGNhbiB1c2UgaXQgd2hlbiB3ZSBnZXQgYSBmb2N1c2luIGV2ZW50XG5cdFx0XHRcdFx0XHQvLyAgICAgICAoJ2NsaWNrJyBldmVudCBmaXJlcyBhZnRlciBmb2N1c2luKVxuXHRcdFx0XHRcdFx0Ly8gdHJlZS5kZWJ1ZyhcImV2ZW50KFwiICsgZXZlbnQudHlwZSArIFwiKTogbm9kZTogXCIsIGV0Lm5vZGUpO1xuXHRcdFx0XHRcdFx0dHJlZS5fbGFzdE1vdXNlZG93bk5vZGUgPSBldCA/IGV0Lm5vZGUgOiBudWxsO1xuXHRcdFx0XHRcdFx0Ly8gIzc4OTogU3RvcmUgdGhlIG5vZGUgYWxzbyBmb3IgYSBzaG9ydCBwZXJpb2QsIHNvIHdlIGNhbiB1c2UgaXRcblx0XHRcdFx0XHRcdC8vIGluIGEgKnJlc3VsdGluZyogZm9jdXNpbiBldmVudFxuXHRcdFx0XHRcdFx0dHJlZS5fc2V0RXhwaXJpbmdWYWx1ZShcblx0XHRcdFx0XHRcdFx0XCJtb3VzZURvd25Ob2RlXCIsXG5cdFx0XHRcdFx0XHRcdHRyZWUuX2xhc3RNb3VzZWRvd25Ob2RlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Lm9uKFwiY2xpY2tcIiArIG5zICsgXCIgZGJsY2xpY2tcIiArIG5zLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuZGlzYWJsZWQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR2YXIgY3R4LFxuXHRcdFx0XHRcdFx0XHRldCA9IEZULmdldEV2ZW50VGFyZ2V0KGV2ZW50KSxcblx0XHRcdFx0XHRcdFx0bm9kZSA9IGV0Lm5vZGUsXG5cdFx0XHRcdFx0XHRcdHRyZWUgPSBzZWxmLnRyZWUsXG5cdFx0XHRcdFx0XHRcdHByZXZQaGFzZSA9IHRyZWUucGhhc2U7XG5cblx0XHRcdFx0XHRcdC8vIHNlbGYudHJlZS5kZWJ1ZyhcImV2ZW50KFwiICsgZXZlbnQudHlwZSArIFwiKTogbm9kZTogXCIsIG5vZGUpO1xuXHRcdFx0XHRcdFx0aWYgKCFub2RlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlOyAvLyBBbGxvdyBidWJibGluZyBvZiBvdGhlciBldmVudHNcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN0eCA9IHRyZWUuX21ha2VIb29rQ29udGV4dChub2RlLCBldmVudCk7XG5cdFx0XHRcdFx0XHQvLyBzZWxmLnRyZWUuZGVidWcoXCJldmVudChcIiArIGV2ZW50LnR5cGUgKyBcIik6IG5vZGU6IFwiLCBub2RlKTtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHRyZWUucGhhc2UgPSBcInVzZXJFdmVudFwiO1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiY2xpY2tcIjpcblx0XHRcdFx0XHRcdFx0XHRcdGN0eC50YXJnZXRUeXBlID0gZXQudHlwZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChub2RlLmlzUGFnaW5nTm9kZSgpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFwiY2xpY2tQYWdpbmdcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGN0eCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSA9PT0gdHJ1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRyZWUuX3RyaWdnZXJOb2RlRXZlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFwiY2xpY2tcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHRcdFx0XHRcdFx0KSA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdFx0PyBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ6IHRyZWUuX2NhbGxIb29rKFwibm9kZUNsaWNrXCIsIGN0eCk7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImRibGNsaWNrXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRjdHgudGFyZ2V0VHlwZSA9IGV0LnR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJlZS5fdHJpZ2dlck5vZGVFdmVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XCJkYmxjbGlja1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50XG5cdFx0XHRcdFx0XHRcdFx0XHQpID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ/IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDogdHJlZS5fY2FsbEhvb2soXCJub2RlRGJsY2xpY2tcIiwgY3R4KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0dHJlZS5waGFzZSA9IHByZXZQaGFzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvKiogUmV0dXJuIHRoZSBhY3RpdmUgbm9kZSBvciBudWxsLlxuXHRcdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGV9XG5cdFx0XHQgKi9cblx0XHRcdGdldEFjdGl2ZU5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmVlLmFjdGl2ZU5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFJldHVybiB0aGUgbWF0Y2hpbmcgbm9kZSBvciBudWxsLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGtleVxuXHRcdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGV9XG5cdFx0XHQgKi9cblx0XHRcdGdldE5vZGVCeUtleTogZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnRyZWUuZ2V0Tm9kZUJ5S2V5KGtleSk7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFJldHVybiB0aGUgaW52aXNpYmxlIHN5c3RlbSByb290IG5vZGUuXG5cdFx0XHQgKiBAcmV0dXJucyB7RmFuY3l0cmVlTm9kZX1cblx0XHRcdCAqL1xuXHRcdFx0Z2V0Um9vdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmVlLnJvb3ROb2RlO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBSZXR1cm4gdGhlIGN1cnJlbnQgdHJlZSBpbnN0YW5jZS5cblx0XHRcdCAqIEByZXR1cm5zIHtGYW5jeXRyZWV9XG5cdFx0XHQgKi9cblx0XHRcdGdldFRyZWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmVlO1xuXHRcdFx0fSxcblx0XHR9XG5cdCk7XG5cblx0Ly8gJC51aS5mYW5jeXRyZWUgd2FzIGNyZWF0ZWQgYnkgdGhlIHdpZGdldCBmYWN0b3J5LiBDcmVhdGUgYSBsb2NhbCBzaG9ydGN1dDpcblx0RlQgPSAkLnVpLmZhbmN5dHJlZTtcblxuXHQvKipcblx0ICogU3RhdGljIG1lbWJlcnMgaW4gdGhlIGAkLnVpLmZhbmN5dHJlZWAgbmFtZXNwYWNlLjxicj5cblx0ICogPGJyPlxuXHQgKiA8cHJlIGNsYXNzPVwic2hfamF2YXNjcmlwdCBzdW5saWdodC1oaWdobGlnaHQtamF2YXNjcmlwdFwiPi8vIEFjY2VzcyBzdGF0aWMgbWVtYmVyczpcblx0ICogdmFyIG5vZGUgPSAkLnVpLmZhbmN5dHJlZS5nZXROb2RlKGVsZW1lbnQpO1xuXHQgKiBhbGVydCgkLnVpLmZhbmN5dHJlZS52ZXJzaW9uKTtcblx0ICogPC9wcmU+XG5cdCAqXG5cdCAqIEBtaXhpbiBGYW5jeXRyZWVfU3RhdGljXG5cdCAqL1xuXHQkLmV4dGVuZChcblx0XHQkLnVpLmZhbmN5dHJlZSxcblx0XHQvKiogQGxlbmRzIEZhbmN5dHJlZV9TdGF0aWMjICovXG5cdFx0e1xuXHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdFx0XHR2ZXJzaW9uOiBcIjIuMzMuMFwiLCAvLyBTZXQgdG8gc2VtdmVyIGJ5ICdncnVudCByZWxlYXNlJ1xuXHRcdFx0LyoqIEB0eXBlIHtzdHJpbmd9ICovXG5cdFx0XHRidWlsZFR5cGU6IFwicHJvZHVjdGlvblwiLCAvLyBTZXQgdG8gJ3Byb2R1Y3Rpb24nIGJ5ICdncnVudCBidWlsZCdcblx0XHRcdC8qKiBAdHlwZSB7aW50fSAqL1xuXHRcdFx0ZGVidWdMZXZlbDogMywgLy8gU2V0IHRvIDMgYnkgJ2dydW50IGJ1aWxkJ1xuXHRcdFx0Ly8gVXNlZCBieSAkLnVpLmZhbmN5dHJlZS5kZWJ1ZygpIGFuZCBhcyBkZWZhdWx0IGZvciB0cmVlLm9wdGlvbnMuZGVidWdMZXZlbFxuXG5cdFx0XHRfbmV4dElkOiAxLFxuXHRcdFx0X25leHROb2RlS2V5OiAxLFxuXHRcdFx0X2V4dGVuc2lvbnM6IHt9LFxuXHRcdFx0Ly8gZm9jdXNUcmVlOiBudWxsLFxuXG5cdFx0XHQvKiogRXhwb3NlIGNsYXNzIG9iamVjdCBhcyAkLnVpLmZhbmN5dHJlZS5fRmFuY3l0cmVlQ2xhc3MgKi9cblx0XHRcdF9GYW5jeXRyZWVDbGFzczogRmFuY3l0cmVlLFxuXHRcdFx0LyoqIEV4cG9zZSBjbGFzcyBvYmplY3QgYXMgJC51aS5mYW5jeXRyZWUuX0ZhbmN5dHJlZU5vZGVDbGFzcyAqL1xuXHRcdFx0X0ZhbmN5dHJlZU5vZGVDbGFzczogRmFuY3l0cmVlTm9kZSxcblx0XHRcdC8qIEZlYXR1cmUgY2hlY2tzIHRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgKi9cblx0XHRcdGpxdWVyeVN1cHBvcnRzOiB7XG5cdFx0XHRcdC8vIGh0dHA6Ly9qcXVlcnl1aS5jb20vdXBncmFkZS1ndWlkZS8xLjkvI2RlcHJlY2F0ZWQtb2Zmc2V0LW9wdGlvbi1tZXJnZWQtaW50by1teS1hbmQtYXRcblx0XHRcdFx0cG9zaXRpb25NeU9mczogaXNWZXJzaW9uQXRMZWFzdCgkLnVpLnZlcnNpb24sIDEsIDkpLFxuXHRcdFx0fSxcblx0XHRcdC8qKiBUaHJvdyBhbiBlcnJvciBpZiBjb25kaXRpb24gZmFpbHMgKGRlYnVnIG1ldGhvZCkuXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcblx0XHRcdCAqL1xuXHRcdFx0YXNzZXJ0OiBmdW5jdGlvbihjb25kLCBtc2cpIHtcblx0XHRcdFx0cmV0dXJuIF9hc3NlcnQoY29uZCwgbXNnKTtcblx0XHRcdH0sXG5cdFx0XHQvKiogQ3JlYXRlIGEgbmV3IEZhbmN5dHJlZSBpbnN0YW5jZSBvbiBhIHRhcmdldCBlbGVtZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudCB8IGpRdWVyeU9iamVjdCB8IHN0cmluZ30gZWwgVGFyZ2V0IERPTSBlbGVtZW50IG9yIHNlbGVjdG9yXG5cdFx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZU9wdGlvbnN9IFtvcHRzXSBGYW5jeXRyZWUgb3B0aW9uc1xuXHRcdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZX0gbmV3IHRyZWUgaW5zdGFuY2Vcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiB2YXIgdHJlZSA9ICQudWkuZmFuY3l0cmVlLmNyZWF0ZVRyZWUoXCIjdHJlZVwiLCB7XG5cdFx0XHQgKiAgICAgc291cmNlOiB7dXJsOiBcIm15L3dlYnNlcnZpY2VcIn1cblx0XHRcdCAqIH0pOyAvLyBDcmVhdGUgdHJlZSBmb3IgdGhpcyBtYXRjaGluZyBlbGVtZW50XG5cdFx0XHQgKlxuXHRcdFx0ICogQHNpbmNlIDIuMjVcblx0XHRcdCAqL1xuXHRcdFx0Y3JlYXRlVHJlZTogZnVuY3Rpb24oZWwsIG9wdHMpIHtcblx0XHRcdFx0dmFyIHRyZWUgPSAkKGVsKVxuXHRcdFx0XHRcdC5mYW5jeXRyZWUob3B0cylcblx0XHRcdFx0XHQuZmFuY3l0cmVlKFwiZ2V0VHJlZVwiKTtcblx0XHRcdFx0cmV0dXJuIHRyZWU7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgKmZuKiBhdCBtb3N0IGV2ZXJ5ICp0aW1lb3V0KiBtcy5cblx0XHRcdCAqIEBwYXJhbSB7aW50ZWdlcn0gdGltZW91dFxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludm9rZUFzYXA9ZmFsc2VdXG5cdFx0XHQgKiBAcGFyYW0ge2FueX0gW2N0eF1cblx0XHRcdCAqL1xuXHRcdFx0ZGVib3VuY2U6IGZ1bmN0aW9uKHRpbWVvdXQsIGZuLCBpbnZva2VBc2FwLCBjdHgpIHtcblx0XHRcdFx0dmFyIHRpbWVyO1xuXHRcdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgaW52b2tlQXNhcCAhPT0gXCJib29sZWFuXCIpIHtcblx0XHRcdFx0XHRjdHggPSBpbnZva2VBc2FwO1xuXHRcdFx0XHRcdGludm9rZUFzYXAgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cdFx0XHRcdFx0Y3R4ID0gY3R4IHx8IHRoaXM7XG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRcdGludm9rZUFzYXAgJiYgIXRpbWVyICYmIGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0XHR0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdFx0XHRpbnZva2VBc2FwIHx8IGZuLmFwcGx5KGN0eCwgYXJncyk7XG5cdFx0XHRcdFx0XHR0aW1lciA9IG51bGw7XG5cdFx0XHRcdFx0fSwgdGltZW91dCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFdyaXRlIG1lc3NhZ2UgdG8gY29uc29sZSBpZiBkZWJ1Z0xldmVsID49IDRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcblx0XHRcdCAqL1xuXHRcdFx0ZGVidWc6IGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0XHRpZiAoJC51aS5mYW5jeXRyZWUuZGVidWdMZXZlbCA+PSA0KSB7XG5cdFx0XHRcdFx0Y29uc29sZUFwcGx5KFwibG9nXCIsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKiogV3JpdGUgZXJyb3IgbWVzc2FnZSB0byBjb25zb2xlIGlmIGRlYnVnTGV2ZWwgPj0gMS5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcblx0XHRcdCAqL1xuXHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0XHRpZiAoJC51aS5mYW5jeXRyZWUuZGVidWdMZXZlbCA+PSAxKSB7XG5cdFx0XHRcdFx0Y29uc29sZUFwcGx5KFwiZXJyb3JcIiwgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKiBDb252ZXJ0IGA8YCwgYD5gLCBgJmAsIGBcImAsIGAnYCwgYW5kIGAvYCB0byB0aGUgZXF1aXZhbGVudCBlbnRpdGllcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc1xuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0ZXNjYXBlSHRtbDogZnVuY3Rpb24ocykge1xuXHRcdFx0XHRyZXR1cm4gKFwiXCIgKyBzKS5yZXBsYWNlKFJFWF9IVE1MLCBmdW5jdGlvbihzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEVOVElUWV9NQVBbc107XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBNYWtlIGpRdWVyeS5wb3NpdGlvbigpIGFyZ3VtZW50cyBiYWNrd2FyZHMgY29tcGF0aWJsZSwgaS5lLiBpZlxuXHRcdFx0ICogalF1ZXJ5IFVJIHZlcnNpb24gPD0gMS44LCBjb252ZXJ0XG5cdFx0XHQgKiAgIHsgbXk6IFwibGVmdCszIGNlbnRlclwiLCBhdDogXCJsZWZ0IGJvdHRvbVwiLCBvZjogJHRhcmdldCB9XG5cdFx0XHQgKiB0b1xuXHRcdFx0ICogICB7IG15OiBcImxlZnQgY2VudGVyXCIsIGF0OiBcImxlZnQgYm90dG9tXCIsIG9mOiAkdGFyZ2V0LCBvZmZzZXQ6IFwiMyAgMFwiIH1cblx0XHRcdCAqXG5cdFx0XHQgKiBTZWUgaHR0cDovL2pxdWVyeXVpLmNvbS91cGdyYWRlLWd1aWRlLzEuOS8jZGVwcmVjYXRlZC1vZmZzZXQtb3B0aW9uLW1lcmdlZC1pbnRvLW15LWFuZC1hdFxuXHRcdFx0ICogYW5kIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbWFyMTAvNnh0dTlhNGUvXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IG9wdHNcblx0XHRcdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSAocG90ZW50aWFsbHkgbW9kaWZpZWQpIG9yaWdpbmFsIG9wdHMgaGFzaCBvYmplY3Rcblx0XHRcdCAqL1xuXHRcdFx0Zml4UG9zaXRpb25PcHRpb25zOiBmdW5jdGlvbihvcHRzKSB7XG5cdFx0XHRcdGlmIChvcHRzLm9mZnNldCB8fCAoXCJcIiArIG9wdHMubXkgKyBvcHRzLmF0KS5pbmRleE9mKFwiJVwiKSA+PSAwKSB7XG5cdFx0XHRcdFx0JC5lcnJvcihcblx0XHRcdFx0XHRcdFwiZXhwZWN0ZWQgbmV3IHBvc2l0aW9uIHN5bnRheCAoYnV0ICclJyBpcyBub3Qgc3VwcG9ydGVkKVwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoISQudWkuZmFuY3l0cmVlLmpxdWVyeVN1cHBvcnRzLnBvc2l0aW9uTXlPZnMpIHtcblx0XHRcdFx0XHR2YXIgLy8gcGFyc2UgJ2xlZnQrMyBjZW50ZXInIGludG8gWydsZWZ0KzMgY2VudGVyJywgJ2xlZnQnLCAnKzMnLCAnY2VudGVyJywgdW5kZWZpbmVkXVxuXHRcdFx0XHRcdFx0bXlQYXJ0cyA9IC8oXFx3KykoWystXT9cXGQrKT9cXHMrKFxcdyspKFsrLV0/XFxkKyk/Ly5leGVjKFxuXHRcdFx0XHRcdFx0XHRvcHRzLm15XG5cdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0YXRQYXJ0cyA9IC8oXFx3KykoWystXT9cXGQrKT9cXHMrKFxcdyspKFsrLV0/XFxkKyk/Ly5leGVjKFxuXHRcdFx0XHRcdFx0XHRvcHRzLmF0XG5cdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0Ly8gY29udmVydCB0byBudW1iZXJzXG5cdFx0XHRcdFx0XHRkeCA9XG5cdFx0XHRcdFx0XHRcdChteVBhcnRzWzJdID8gK215UGFydHNbMl0gOiAwKSArXG5cdFx0XHRcdFx0XHRcdChhdFBhcnRzWzJdID8gK2F0UGFydHNbMl0gOiAwKSxcblx0XHRcdFx0XHRcdGR5ID1cblx0XHRcdFx0XHRcdFx0KG15UGFydHNbNF0gPyArbXlQYXJ0c1s0XSA6IDApICtcblx0XHRcdFx0XHRcdFx0KGF0UGFydHNbNF0gPyArYXRQYXJ0c1s0XSA6IDApO1xuXG5cdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBvcHRzLCB7XG5cdFx0XHRcdFx0XHQvLyBtYWtlIGEgY29weSBhbmQgb3ZlcndyaXRlXG5cdFx0XHRcdFx0XHRteTogbXlQYXJ0c1sxXSArIFwiIFwiICsgbXlQYXJ0c1szXSxcblx0XHRcdFx0XHRcdGF0OiBhdFBhcnRzWzFdICsgXCIgXCIgKyBhdFBhcnRzWzNdLFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmIChkeCB8fCBkeSkge1xuXHRcdFx0XHRcdFx0b3B0cy5vZmZzZXQgPSBcIlwiICsgZHggKyBcIiBcIiArIGR5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb3B0cztcblx0XHRcdH0sXG5cdFx0XHQvKiogUmV0dXJuIGEge25vZGU6IEZhbmN5dHJlZU5vZGUsIHR5cGU6IFRZUEV9IG9iamVjdCBmb3IgYSBtb3VzZSBldmVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBNb3VzZSBldmVudCwgZS5nLiBjbGljaywgLi4uXG5cdFx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fSBSZXR1cm4gYSB7bm9kZTogRmFuY3l0cmVlTm9kZSwgdHlwZTogVFlQRX0gb2JqZWN0XG5cdFx0XHQgKiAgICAgVFlQRTogJ3RpdGxlJyB8ICdwcmVmaXgnIHwgJ2V4cGFuZGVyJyB8ICdjaGVja2JveCcgfCAnaWNvbicgfCB1bmRlZmluZWRcblx0XHRcdCAqL1xuXHRcdFx0Z2V0RXZlbnRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHZhciAkdGFyZ2V0LFxuXHRcdFx0XHRcdHRyZWUsXG5cdFx0XHRcdFx0dGNuID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ID8gZXZlbnQudGFyZ2V0LmNsYXNzTmFtZSA6IFwiXCIsXG5cdFx0XHRcdFx0cmVzID0geyBub2RlOiB0aGlzLmdldE5vZGUoZXZlbnQudGFyZ2V0KSwgdHlwZTogdW5kZWZpbmVkIH07XG5cdFx0XHRcdC8vIFdlIHVzZSBhIGZhc3QgdmVyc2lvbiBvZiAkKHJlcy5ub2RlKS5oYXNDbGFzcygpXG5cdFx0XHRcdC8vIFNlZSBodHRwOi8vanNwZXJmLmNvbS90ZXN0LWZvci1jbGFzc25hbWUvMlxuXHRcdFx0XHRpZiAoL1xcYmZhbmN5dHJlZS10aXRsZVxcYi8udGVzdCh0Y24pKSB7XG5cdFx0XHRcdFx0cmVzLnR5cGUgPSBcInRpdGxlXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoL1xcYmZhbmN5dHJlZS1leHBhbmRlclxcYi8udGVzdCh0Y24pKSB7XG5cdFx0XHRcdFx0cmVzLnR5cGUgPVxuXHRcdFx0XHRcdFx0cmVzLm5vZGUuaGFzQ2hpbGRyZW4oKSA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdFx0PyBcInByZWZpeFwiXG5cdFx0XHRcdFx0XHRcdDogXCJleHBhbmRlclwiO1xuXHRcdFx0XHRcdC8vIH1lbHNlIGlmKCAvXFxiZmFuY3l0cmVlLWNoZWNrYm94XFxiLy50ZXN0KHRjbikgfHwgL1xcYmZhbmN5dHJlZS1yYWRpb1xcYi8udGVzdCh0Y24pICl7XG5cdFx0XHRcdH0gZWxzZSBpZiAoL1xcYmZhbmN5dHJlZS1jaGVja2JveFxcYi8udGVzdCh0Y24pKSB7XG5cdFx0XHRcdFx0cmVzLnR5cGUgPSBcImNoZWNrYm94XCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoL1xcYmZhbmN5dHJlZSgtY3VzdG9tKT8taWNvblxcYi8udGVzdCh0Y24pKSB7XG5cdFx0XHRcdFx0cmVzLnR5cGUgPSBcImljb25cIjtcblx0XHRcdFx0fSBlbHNlIGlmICgvXFxiZmFuY3l0cmVlLW5vZGVcXGIvLnRlc3QodGNuKSkge1xuXHRcdFx0XHRcdC8vIFNvbWV3aGVyZSBuZWFyIHRoZSB0aXRsZVxuXHRcdFx0XHRcdHJlcy50eXBlID0gXCJ0aXRsZVwiO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50ICYmIGV2ZW50LnRhcmdldCkge1xuXHRcdFx0XHRcdCR0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XG5cdFx0XHRcdFx0aWYgKCR0YXJnZXQuaXMoXCJ1bFtyb2xlPWdyb3VwXVwiKSkge1xuXHRcdFx0XHRcdFx0Ly8gI25ubjogQ2xpY2tpbmcgcmlnaHQgdG8gYSBub2RlIG1heSBoaXQgdGhlIHN1cnJvdW5kaW5nIFVMXG5cdFx0XHRcdFx0XHR0cmVlID0gcmVzLm5vZGUgJiYgcmVzLm5vZGUudHJlZTtcblx0XHRcdFx0XHRcdCh0cmVlIHx8IEZUKS5kZWJ1ZyhcIklnbm9yaW5nIGNsaWNrIG9uIG91dGVyIFVMLlwiKTtcblx0XHRcdFx0XHRcdHJlcy5ub2RlID0gbnVsbDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdChcIi5mYW5jeXRyZWUtdGl0bGVcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyAjMjI4OiBjbGlja2luZyBhbiBlbWJlZGRlZCBlbGVtZW50IGluc2lkZSBhIHRpdGxlXG5cdFx0XHRcdFx0XHRyZXMudHlwZSA9IFwidGl0bGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdChcIi5mYW5jeXRyZWUtY2hlY2tib3hcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBFLmcuIDxzdmc+IGluc2lkZSBjaGVja2JveCBzcGFuXG5cdFx0XHRcdFx0XHRyZXMudHlwZSA9IFwiY2hlY2tib3hcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCR0YXJnZXQuY2xvc2VzdChcIi5mYW5jeXRyZWUtZXhwYW5kZXJcIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXMudHlwZSA9IFwiZXhwYW5kZXJcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdH0sXG5cdFx0XHQvKiogUmV0dXJuIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGFmZmVjdGVkIG5vZGUgcmVnaW9uIGZvciBhIG1vdXNlIGV2ZW50LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IE1vdXNlIGV2ZW50LCBlLmcuIGNsaWNrLCBtb3VzZW1vdmUsIC4uLlxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ30gJ3RpdGxlJyB8ICdwcmVmaXgnIHwgJ2V4cGFuZGVyJyB8ICdjaGVja2JveCcgfCAnaWNvbicgfCB1bmRlZmluZWRcblx0XHRcdCAqL1xuXHRcdFx0Z2V0RXZlbnRUYXJnZXRUeXBlOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRFdmVudFRhcmdldChldmVudCkudHlwZTtcblx0XHRcdH0sXG5cdFx0XHQvKiogUmV0dXJuIGEgRmFuY3l0cmVlTm9kZSBpbnN0YW5jZSBmcm9tIGVsZW1lbnQsIGV2ZW50LCBvciBqUXVlcnkgb2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudCB8IGpRdWVyeU9iamVjdCB8IEV2ZW50fSBlbFxuXHRcdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZU5vZGV9IG1hdGNoaW5nIG5vZGUgb3IgbnVsbFxuXHRcdFx0ICovXG5cdFx0XHRnZXROb2RlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0XHRpZiAoZWwgaW5zdGFuY2VvZiBGYW5jeXRyZWVOb2RlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsOyAvLyBlbCBhbHJlYWR5IHdhcyBhIEZhbmN5dHJlZU5vZGVcblx0XHRcdFx0fSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mICQpIHtcblx0XHRcdFx0XHRlbCA9IGVsWzBdOyAvLyBlbCB3YXMgYSBqUXVlcnkgb2JqZWN0OiB1c2UgdGhlIERPTSBlbGVtZW50XG5cdFx0XHRcdH0gZWxzZSBpZiAoZWwub3JpZ2luYWxFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0ZWwgPSBlbC50YXJnZXQ7IC8vIGVsIHdhcyBhbiBFdmVudFxuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlIChlbCkge1xuXHRcdFx0XHRcdGlmIChlbC5mdG5vZGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbC5mdG5vZGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvKiogUmV0dXJuIGEgRmFuY3l0cmVlIGluc3RhbmNlLCBmcm9tIGVsZW1lbnQsIGluZGV4LCBldmVudCwgb3IgalF1ZXJ5T2JqZWN0LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudCB8IGpRdWVyeU9iamVjdCB8IEV2ZW50IHwgaW50ZWdlciB8IHN0cmluZ30gW2VsXVxuXHRcdFx0ICogQHJldHVybnMge0ZhbmN5dHJlZX0gbWF0Y2hpbmcgdHJlZSBvciBudWxsXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogJC51aS5mYW5jeXRyZWUuZ2V0VHJlZSgpOyAgLy8gR2V0IGZpcnN0IEZhbmN5dHJlZSBpbnN0YW5jZSBvbiBwYWdlXG5cdFx0XHQgKiAkLnVpLmZhbmN5dHJlZS5nZXRUcmVlKDEpOyAgLy8gR2V0IHNlY29uZCBGYW5jeXRyZWUgaW5zdGFuY2Ugb24gcGFnZVxuXHRcdFx0ICogJC51aS5mYW5jeXRyZWUuZ2V0VHJlZShldmVudCk7ICAvLyBHZXQgdHJlZSBmb3IgdGhpcyBtb3VzZS0gb3Iga2V5Ym9hcmQgZXZlbnRcblx0XHRcdCAqICQudWkuZmFuY3l0cmVlLmdldFRyZWUoXCJmb29cIik7ICAvLyBHZXQgdHJlZSBmb3IgdGhpcyBgb3B0cy50cmVlSWRgXG5cdFx0XHQgKiAkLnVpLmZhbmN5dHJlZS5nZXRUcmVlKFwiI3RyZWVcIik7ICAvLyBHZXQgdHJlZSBmb3IgdGhpcyBtYXRjaGluZyBlbGVtZW50XG5cdFx0XHQgKlxuXHRcdFx0ICogQHNpbmNlIDIuMTNcblx0XHRcdCAqL1xuXHRcdFx0Z2V0VHJlZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0dmFyIHdpZGdldCxcblx0XHRcdFx0XHRvcmdFbCA9IGVsO1xuXG5cdFx0XHRcdGlmIChlbCBpbnN0YW5jZW9mIEZhbmN5dHJlZSkge1xuXHRcdFx0XHRcdHJldHVybiBlbDsgLy8gZWwgYWxyZWFkeSB3YXMgYSBGYW5jeXRyZWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGVsID0gMDsgLy8gZ2V0IGZpcnN0IHRyZWVcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0ZWwgPSAkKFwiLmZhbmN5dHJlZS1jb250YWluZXJcIikuZXEoZWwpOyAvLyBlbCB3YXMgYW4gaW50ZWdlcjogcmV0dXJuIG50aCBpbnN0YW5jZVxuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdC8vIGBlbGAgbWF5IGJlIGEgdHJlZUlkIG9yIGEgc2VsZWN0b3I6XG5cdFx0XHRcdFx0ZWwgPSAkKFwiI2Z0LWlkLVwiICsgb3JnRWwpLmVxKDApO1xuXHRcdFx0XHRcdGlmICghZWwubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRlbCA9ICQob3JnRWwpLmVxKDApOyAvLyBlbCB3YXMgYSBzZWxlY3RvcjogdXNlIGZpcnN0IG1hdGNoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgJCkge1xuXHRcdFx0XHRcdGVsID0gZWwuZXEoMCk7IC8vIGVsIHdhcyBhIGpRdWVyeSBvYmplY3Q6IHVzZSB0aGUgZmlyc3QgRE9NIGVsZW1lbnRcblx0XHRcdFx0fSBlbHNlIGlmIChlbC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRlbCA9ICQoZWwudGFyZ2V0KTsgLy8gZWwgd2FzIGFuIEV2ZW50XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWwgPSBlbC5jbG9zZXN0KFwiOnVpLWZhbmN5dHJlZVwiKTtcblx0XHRcdFx0d2lkZ2V0ID0gZWwuZGF0YShcInVpLWZhbmN5dHJlZVwiKSB8fCBlbC5kYXRhKFwiZmFuY3l0cmVlXCIpOyAvLyB0aGUgbGF0dGVyIGlzIHJlcXVpcmVkIGJ5IGpRdWVyeSA8PSAxLjhcblx0XHRcdFx0cmV0dXJuIHdpZGdldCA/IHdpZGdldC50cmVlIDogbnVsbDtcblx0XHRcdH0sXG5cdFx0XHQvKiogUmV0dXJuIGFuIG9wdGlvbiB2YWx1ZSB0aGF0IGhhcyBhIGRlZmF1bHQsIGJ1dCBtYXkgYmUgb3ZlcnJpZGRlbiBieSBhXG5cdFx0XHQgKiBjYWxsYmFjayBvciBhIG5vZGUgaW5zdGFuY2UgYXR0cmlidXRlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEV2YWx1YXRpb24gc2VxdWVuY2U6PGJyPlxuXHRcdFx0ICpcblx0XHRcdCAqIElmIHRyZWUub3B0aW9ucy48b3B0aW9uTmFtZT4gaXMgYSBjYWxsYmFjayB0aGF0IHJldHVybnMgc29tZXRoaW5nLCB1c2UgdGhhdC48YnI+XG5cdFx0XHQgKiBFbHNlIGlmIG5vZGUuPG9wdGlvbk5hbWU+IGlzIGRlZmluZWQsIHVzZSB0aGF0Ljxicj5cblx0XHRcdCAqIEVsc2UgaWYgdHJlZS5vcHRpb25zLjxvcHRpb25OYW1lPiBpcyBhIHZhbHVlLCB1c2UgdGhhdC48YnI+XG5cdFx0XHQgKiBFbHNlIHVzZSBgZGVmYXVsdFZhbHVlYC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uTmFtZSBuYW1lIG9mIHRoZSBvcHRpb24gcHJvcGVydHkgKG9uIG5vZGUgYW5kIHRyZWUpXG5cdFx0XHQgKiBAcGFyYW0ge0ZhbmN5dHJlZU5vZGV9IG5vZGUgcGFzc2VkIHRvIHRoZSBjYWxsYmFja1xuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IG5vZGVPYmplY3Qgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGxvY2FsIG9wdGlvbiBwcm9wZXJ0eSwgZS5nLiBgbm9kZWAgb3IgYG5vZGUuZGF0YWBcblx0XHRcdCAqIEBwYXJhbSB7b2JqZWN0fSB0cmVlT3B0aW9uIHdoZXJlIHRvIGxvb2sgZm9yIHRoZSB0cmVlIG9wdGlvbiwgZS5nLiBgdHJlZS5vcHRpb25zYCBvciBgdHJlZS5vcHRpb25zLmRuZDVgXG5cdFx0XHQgKiBAcGFyYW0ge2FueX0gW2RlZmF1bHRWYWx1ZV1cblx0XHRcdCAqIEByZXR1cm5zIHthbnl9XG5cdFx0XHQgKlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIC8vIENoZWNrIGZvciBub2RlLmZvbywgdHJlZSxvcHRpb25zLmZvbygpLCBhbmQgdHJlZS5vcHRpb25zLmZvbzpcblx0XHRcdCAqICQudWkuZmFuY3l0cmVlLmV2YWxPcHRpb24oXCJmb29cIiwgbm9kZSwgbm9kZSwgdHJlZS5vcHRpb25zKTtcblx0XHRcdCAqIC8vIENoZWNrIGZvciBub2RlLmRhdGEuYmFyLCB0cmVlLG9wdGlvbnMucXV4LmJhcigpLCBhbmQgdHJlZS5vcHRpb25zLnF1eC5iYXI6XG5cdFx0XHQgKiAkLnVpLmZhbmN5dHJlZS5ldmFsT3B0aW9uKFwiYmFyXCIsIG5vZGUsIG5vZGUuZGF0YSwgdHJlZS5vcHRpb25zLnF1eCk7XG5cdFx0XHQgKlxuXHRcdFx0ICogQHNpbmNlIDIuMjJcblx0XHRcdCAqL1xuXHRcdFx0ZXZhbE9wdGlvbjogZnVuY3Rpb24oXG5cdFx0XHRcdG9wdGlvbk5hbWUsXG5cdFx0XHRcdG5vZGUsXG5cdFx0XHRcdG5vZGVPYmplY3QsXG5cdFx0XHRcdHRyZWVPcHRpb25zLFxuXHRcdFx0XHRkZWZhdWx0VmFsdWVcblx0XHRcdCkge1xuXHRcdFx0XHR2YXIgY3R4LFxuXHRcdFx0XHRcdHJlcyxcblx0XHRcdFx0XHR0cmVlID0gbm9kZS50cmVlLFxuXHRcdFx0XHRcdHRyZWVPcHQgPSB0cmVlT3B0aW9uc1tvcHRpb25OYW1lXSxcblx0XHRcdFx0XHRub2RlT3B0ID0gbm9kZU9iamVjdFtvcHRpb25OYW1lXTtcblxuXHRcdFx0XHRpZiAoJC5pc0Z1bmN0aW9uKHRyZWVPcHQpKSB7XG5cdFx0XHRcdFx0Y3R4ID0ge1xuXHRcdFx0XHRcdFx0bm9kZTogbm9kZSxcblx0XHRcdFx0XHRcdHRyZWU6IHRyZWUsXG5cdFx0XHRcdFx0XHR3aWRnZXQ6IHRyZWUud2lkZ2V0LFxuXHRcdFx0XHRcdFx0b3B0aW9uczogdHJlZS53aWRnZXQub3B0aW9ucyxcblx0XHRcdFx0XHRcdHR5cGVJbmZvOiB0cmVlLnR5cGVzW25vZGUudHlwZV0gfHwge30sXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXMgPSB0cmVlT3B0LmNhbGwodHJlZSwgeyB0eXBlOiBvcHRpb25OYW1lIH0sIGN0eCk7XG5cdFx0XHRcdFx0aWYgKHJlcyA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBub2RlT3B0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXMgPSBub2RlT3B0ID09IG51bGwgPyB0cmVlT3B0IDogbm9kZU9wdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocmVzID09IG51bGwpIHtcblx0XHRcdFx0XHRyZXMgPSBkZWZhdWx0VmFsdWU7IC8vIG5vIG9wdGlvbiBzZXQgYXQgYWxsOiByZXR1cm4gZGVmYXVsdFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9LFxuXHRcdFx0LyoqIFNldCBleHBhbmRlciwgY2hlY2tib3gsIG9yIG5vZGUgaWNvbiwgc3VwcG9ydGluZyBzdHJpbmcgYW5kIG9iamVjdCBmb3JtYXQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50IHwgalF1ZXJ5T2JqZWN0fSBzcGFuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYmFzZUNsYXNzXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZyB8IG9iamVjdH0gaWNvblxuXHRcdFx0ICogQHNpbmNlIDIuMjdcblx0XHRcdCAqL1xuXHRcdFx0c2V0U3Bhbkljb246IGZ1bmN0aW9uKHNwYW4sIGJhc2VDbGFzcywgaWNvbikge1xuXHRcdFx0XHR2YXIgJHNwYW4gPSAkKHNwYW4pO1xuXG5cdFx0XHRcdGlmICh0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdCRzcGFuLmF0dHIoXCJjbGFzc1wiLCBiYXNlQ2xhc3MgKyBcIiBcIiArIGljb24pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHN1cHBvcnQgb2JqZWN0IHN5bnRheDogeyB0ZXh0OiBsaWdhdHVyZSwgYWRkQ2xhc3NlOiBjbGFzc25hbWUgfVxuXHRcdFx0XHRcdGlmIChpY29uLnRleHQpIHtcblx0XHRcdFx0XHRcdCRzcGFuLnRleHQoXCJcIiArIGljb24udGV4dCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpY29uLmh0bWwpIHtcblx0XHRcdFx0XHRcdHNwYW4uaW5uZXJIVE1MID0gaWNvbi5odG1sO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkc3Bhbi5hdHRyKFxuXHRcdFx0XHRcdFx0XCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0YmFzZUNsYXNzICsgXCIgXCIgKyAoaWNvbi5hZGRDbGFzcyB8fCBcIlwiKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKiogQ29udmVydCBhIGtleWRvd24gb3IgbW91c2UgZXZlbnQgdG8gYSBjYW5vbmljYWwgc3RyaW5nIGxpa2UgJ2N0cmwrYScsXG5cdFx0XHQgKiAnY3RybCtzaGlmdCtmMicsICdzaGlmdCtsZWZ0ZGJsY2xpY2snLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgaXMgZXNwZWNpYWxseSBoYW5keSBmb3Igc3dpdGNoLXN0YXRlbWVudHMgaW4gZXZlbnQgaGFuZGxlcnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtldmVudH1cblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKlxuXHRcdFx0ICogQGV4YW1wbGVcblxuXHRcdFx0c3dpdGNoKCAkLnVpLmZhbmN5dHJlZS5ldmVudFRvU3RyaW5nKGV2ZW50KSApIHtcblx0XHRcdFx0Y2FzZSBcIi1cIjpcblx0XHRcdFx0XHR0cmVlLm5vZGVTZXRFeHBhbmRlZChjdHgsIGZhbHNlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInNoaWZ0K3JldHVyblwiOlxuXHRcdFx0XHRcdHRyZWUubm9kZVNldEFjdGl2ZShjdHgsIHRydWUpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZG93blwiOlxuXHRcdFx0XHRcdHJlcyA9IG5vZGUubmF2aWdhdGUoZXZlbnQud2hpY2gsIGFjdGl2YXRlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRoYW5kbGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiggaGFuZGxlZCApe1xuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0fVxuXHRcdFx0Ki9cblx0XHRcdGV2ZW50VG9TdHJpbmc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdC8vIFBvb3ItbWFuJ3MgaG90a2V5cy4gU2VlIGhlcmUgZm9yIGEgY29tcGxldGUgaW1wbGVtZW50YXRpb246XG5cdFx0XHRcdC8vICAgaHR0cHM6Ly9naXRodWIuY29tL2plcmVzaWcvanF1ZXJ5LmhvdGtleXNcblx0XHRcdFx0dmFyIHdoaWNoID0gZXZlbnQud2hpY2gsXG5cdFx0XHRcdFx0ZXQgPSBldmVudC50eXBlLFxuXHRcdFx0XHRcdHMgPSBbXTtcblxuXHRcdFx0XHRpZiAoZXZlbnQuYWx0S2V5KSB7XG5cdFx0XHRcdFx0cy5wdXNoKFwiYWx0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChldmVudC5jdHJsS2V5KSB7XG5cdFx0XHRcdFx0cy5wdXNoKFwiY3RybFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXZlbnQubWV0YUtleSkge1xuXHRcdFx0XHRcdHMucHVzaChcIm1ldGFcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG5cdFx0XHRcdFx0cy5wdXNoKFwic2hpZnRcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZXQgPT09IFwiY2xpY2tcIiB8fCBldCA9PT0gXCJkYmxjbGlja1wiKSB7XG5cdFx0XHRcdFx0cy5wdXNoKE1PVVNFX0JVVFRPTlNbZXZlbnQuYnV0dG9uXSArIGV0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChldCA9PT0gXCJ3aGVlbFwiKSB7XG5cdFx0XHRcdFx0cy5wdXNoKGV0KTtcblx0XHRcdFx0fSBlbHNlIGlmICghSUdOT1JFX0tFWUNPREVTW3doaWNoXSkge1xuXHRcdFx0XHRcdHMucHVzaChcblx0XHRcdFx0XHRcdFNQRUNJQUxfS0VZQ09ERVNbd2hpY2hdIHx8XG5cdFx0XHRcdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUod2hpY2gpLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzLmpvaW4oXCIrXCIpO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBXcml0ZSBtZXNzYWdlIHRvIGNvbnNvbGUgaWYgZGVidWdMZXZlbCA+PSAzXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbXNnXG5cdFx0XHQgKi9cblx0XHRcdGluZm86IGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0XHRpZiAoJC51aS5mYW5jeXRyZWUuZGVidWdMZXZlbCA+PSAzKSB7XG5cdFx0XHRcdFx0Y29uc29sZUFwcGx5KFwiaW5mb1wiLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyogQGRlcHJlY2F0ZWQ6IHVzZSBldmVudFRvU3RyaW5nKGV2ZW50KSBpbnN0ZWFkLlxuXHRcdFx0ICovXG5cdFx0XHRrZXlFdmVudFRvU3RyaW5nOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHR0aGlzLndhcm4oXG5cdFx0XHRcdFx0XCJrZXlFdmVudFRvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZDogdXNlIGV2ZW50VG9TdHJpbmcoKVwiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV2ZW50VG9TdHJpbmcoZXZlbnQpO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBSZXR1cm4gYSB3cmFwcGVkIGhhbmRsZXIgbWV0aG9kLCB0aGF0IHByb3ZpZGVzIGB0aGlzLl9zdXBlcmAuXG5cdFx0XHQgKlxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdFx0Ly8gSW1wbGVtZW50IGBvcHRzLmNyZWF0ZU5vZGVgIGV2ZW50IHRvIGFkZCB0aGUgJ2RyYWdnYWJsZScgYXR0cmlidXRlXG5cdFx0XHRcdCQudWkuZmFuY3l0cmVlLm92ZXJyaWRlTWV0aG9kKGN0eC5vcHRpb25zLCBcImNyZWF0ZU5vZGVcIiwgZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcblx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3NpbmcgaWYgYW55XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0XHQvLyBBZGQgJ2RyYWdnYWJsZScgYXR0cmlidXRlXG5cdFx0XHRcdFx0ZGF0YS5ub2RlLnNwYW4uZHJhZ2dhYmxlID0gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IGluc3RhbmNlXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZVxuXHRcdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclxuXHRcdFx0ICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSBvcHRpb25hbCBjb250ZXh0XG5cdFx0XHQgKi9cblx0XHRcdG92ZXJyaWRlTWV0aG9kOiBmdW5jdGlvbihpbnN0YW5jZSwgbWV0aG9kTmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuXHRcdFx0XHR2YXIgcHJldlN1cGVyLFxuXHRcdFx0XHRcdF9zdXBlciA9IGluc3RhbmNlW21ldGhvZE5hbWVdIHx8ICQubm9vcDtcblxuXHRcdFx0XHRpbnN0YW5jZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBzZWxmID0gY29udGV4dCB8fCB0aGlzO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHByZXZTdXBlciA9IHNlbGYuX3N1cGVyO1xuXHRcdFx0XHRcdFx0c2VsZi5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaGFuZGxlci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRzZWxmLl9zdXBlciA9IHByZXZTdXBlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0LyoqXG5cdFx0XHQgKiBQYXJzZSB0cmVlIGRhdGEgZnJvbSBIVE1MIDx1bD4gbWFya3VwXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtqUXVlcnlPYmplY3R9ICR1bFxuXHRcdFx0ICogQHJldHVybnMge05vZGVEYXRhW119XG5cdFx0XHQgKi9cblx0XHRcdHBhcnNlSHRtbDogZnVuY3Rpb24oJHVsKSB7XG5cdFx0XHRcdHZhciBjbGFzc2VzLFxuXHRcdFx0XHRcdGNsYXNzTmFtZSxcblx0XHRcdFx0XHRleHRyYUNsYXNzZXMsXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRpUG9zLFxuXHRcdFx0XHRcdGwsXG5cdFx0XHRcdFx0dG1wLFxuXHRcdFx0XHRcdHRtcDIsXG5cdFx0XHRcdFx0JGNoaWxkcmVuID0gJHVsLmZpbmQoXCI+bGlcIiksXG5cdFx0XHRcdFx0Y2hpbGRyZW4gPSBbXTtcblxuXHRcdFx0XHQkY2hpbGRyZW4uZWFjaChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgYWxsRGF0YSxcblx0XHRcdFx0XHRcdGxvd2VyQ2FzZUF0dHIsXG5cdFx0XHRcdFx0XHQkbGkgPSAkKHRoaXMpLFxuXHRcdFx0XHRcdFx0JGxpU3BhbiA9ICRsaS5maW5kKFwiPnNwYW5cIiwgdGhpcykuZmlyc3QoKSxcblx0XHRcdFx0XHRcdCRsaUEgPSAkbGlTcGFuLmxlbmd0aCA/IG51bGwgOiAkbGkuZmluZChcIj5hXCIpLmZpcnN0KCksXG5cdFx0XHRcdFx0XHRkID0geyB0b29sdGlwOiBudWxsLCBkYXRhOiB7fSB9O1xuXG5cdFx0XHRcdFx0aWYgKCRsaVNwYW4ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkLnRpdGxlID0gJGxpU3Bhbi5odG1sKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgkbGlBICYmICRsaUEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBJZiBhIDxsaT48YT4gdGFnIGlzIHNwZWNpZmllZCwgdXNlIGl0IGxpdGVyYWxseSBhbmQgZXh0cmFjdCBocmVmL3RhcmdldC5cblx0XHRcdFx0XHRcdGQudGl0bGUgPSAkbGlBLmh0bWwoKTtcblx0XHRcdFx0XHRcdGQuZGF0YS5ocmVmID0gJGxpQS5hdHRyKFwiaHJlZlwiKTtcblx0XHRcdFx0XHRcdGQuZGF0YS50YXJnZXQgPSAkbGlBLmF0dHIoXCJ0YXJnZXRcIik7XG5cdFx0XHRcdFx0XHRkLnRvb2x0aXAgPSAkbGlBLmF0dHIoXCJ0aXRsZVwiKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gSWYgb25seSBhIDxsaT4gdGFnIGlzIHNwZWNpZmllZCwgdXNlIHRoZSB0cmltbWVkIHN0cmluZyB1cCB0b1xuXHRcdFx0XHRcdFx0Ly8gdGhlIG5leHQgY2hpbGQgPHVsPiB0YWcuXG5cdFx0XHRcdFx0XHRkLnRpdGxlID0gJGxpLmh0bWwoKTtcblx0XHRcdFx0XHRcdGlQb3MgPSBkLnRpdGxlLnNlYXJjaCgvPHVsL2kpO1xuXHRcdFx0XHRcdFx0aWYgKGlQb3MgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRkLnRpdGxlID0gZC50aXRsZS5zdWJzdHJpbmcoMCwgaVBvcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGQudGl0bGUgPSAkLnRyaW0oZC50aXRsZSk7XG5cblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgYWxsIGZpZWxkcyBleGlzdFxuXHRcdFx0XHRcdGZvciAoaSA9IDAsIGwgPSBDTEFTU19BVFRSUy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGRbQ0xBU1NfQVRUUlNbaV1dID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBJbml0aWFsaXplIHRvIGB0cnVlYCwgaWYgY2xhc3MgaXMgc2V0IGFuZCBjb2xsZWN0IGV4dHJhQ2xhc3Nlc1xuXHRcdFx0XHRcdGNsYXNzZXMgPSB0aGlzLmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG5cdFx0XHRcdFx0ZXh0cmFDbGFzc2VzID0gW107XG5cdFx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc2VzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKENMQVNTX0FUVFJfTUFQW2NsYXNzTmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0ZFtjbGFzc05hbWVdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGV4dHJhQ2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGQuZXh0cmFDbGFzc2VzID0gZXh0cmFDbGFzc2VzLmpvaW4oXCIgXCIpO1xuXG5cdFx0XHRcdFx0Ly8gUGFyc2Ugbm9kZSBvcHRpb25zIGZyb20gSUQsIHRpdGxlIGFuZCBjbGFzcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0dG1wID0gJGxpLmF0dHIoXCJ0aXRsZVwiKTtcblx0XHRcdFx0XHRpZiAodG1wKSB7XG5cdFx0XHRcdFx0XHRkLnRvb2x0aXAgPSB0bXA7IC8vIG92ZXJyaWRlcyA8YSB0aXRsZT0nLi4uJz5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG1wID0gJGxpLmF0dHIoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAodG1wKSB7XG5cdFx0XHRcdFx0XHRkLmtleSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVHJhbnNsYXRlIGhpZGVDaGVja2JveCAtPiBjaGVja2JveDpmYWxzZVxuXHRcdFx0XHRcdGlmICgkbGkuYXR0cihcImhpZGVDaGVja2JveFwiKSkge1xuXHRcdFx0XHRcdFx0ZC5jaGVja2JveCA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBBZGQgPGxpIGRhdGEtTkFNRT0nLi4uJz4gYXMgbm9kZS5kYXRhLk5BTUVcblx0XHRcdFx0XHRhbGxEYXRhID0gX2dldEVsZW1lbnREYXRhQXNEaWN0KCRsaSk7XG5cdFx0XHRcdFx0aWYgKGFsbERhdGEgJiYgISQuaXNFbXB0eU9iamVjdChhbGxEYXRhKSkge1xuXHRcdFx0XHRcdFx0Ly8gIzUwNzogY29udmVydCBkYXRhLWhpZGVjaGVja2JveCAobG93ZXIgY2FzZSkgdG8gaGlkZUNoZWNrYm94XG5cdFx0XHRcdFx0XHRmb3IgKGxvd2VyQ2FzZUF0dHIgaW4gTk9ERV9BVFRSX0xPV0VSQ0FTRV9NQVApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGFsbERhdGEuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlQXR0cikpIHtcblx0XHRcdFx0XHRcdFx0XHRhbGxEYXRhW1xuXHRcdFx0XHRcdFx0XHRcdFx0Tk9ERV9BVFRSX0xPV0VSQ0FTRV9NQVBbbG93ZXJDYXNlQXR0cl1cblx0XHRcdFx0XHRcdFx0XHRdID0gYWxsRGF0YVtsb3dlckNhc2VBdHRyXTtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgYWxsRGF0YVtsb3dlckNhc2VBdHRyXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gIzU2OiBBbGxvdyB0byBzZXQgc3BlY2lhbCBub2RlLmF0dHJpYnV0ZXMgZnJvbSBkYXRhLS4uLlxuXHRcdFx0XHRcdFx0Zm9yIChpID0gMCwgbCA9IE5PREVfQVRUUlMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHRtcCA9IE5PREVfQVRUUlNbaV07XG5cdFx0XHRcdFx0XHRcdHRtcDIgPSBhbGxEYXRhW3RtcF07XG5cdFx0XHRcdFx0XHRcdGlmICh0bXAyICE9IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgYWxsRGF0YVt0bXBdO1xuXHRcdFx0XHRcdFx0XHRcdGRbdG1wXSA9IHRtcDI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIEFsbCBvdGhlciBkYXRhLS4uLiBnb2VzIHRvIG5vZGUuZGF0YS4uLlxuXHRcdFx0XHRcdFx0JC5leHRlbmQoZC5kYXRhLCBhbGxEYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gUmVjdXJzaXZlIHJlYWRpbmcgb2YgY2hpbGQgbm9kZXMsIGlmIExJIHRhZyBjb250YWlucyBhbiBVTCB0YWdcblx0XHRcdFx0XHQkdWwgPSAkbGkuZmluZChcIj51bFwiKS5maXJzdCgpO1xuXHRcdFx0XHRcdGlmICgkdWwubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkLmNoaWxkcmVuID0gJC51aS5mYW5jeXRyZWUucGFyc2VIdG1sKCR1bCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGQuY2hpbGRyZW4gPSBkLmxhenkgPyB1bmRlZmluZWQgOiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGQpO1xuXHRcdFx0XHRcdC8vIEZULmRlYnVnKFwicGFyc2UgXCIsIGQsIGNoaWxkcmVuKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBjaGlsZHJlbjtcblx0XHRcdH0sXG5cdFx0XHQvKiogQWRkIEZhbmN5dHJlZSBleHRlbnNpb24gZGVmaW5pdGlvbiB0byB0aGUgbGlzdCBvZiBnbG9iYWxseSBhdmFpbGFibGUgZXh0ZW5zaW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge29iamVjdH0gZGVmaW5pdGlvblxuXHRcdFx0ICovXG5cdFx0XHRyZWdpc3RlckV4dGVuc2lvbjogZnVuY3Rpb24oZGVmaW5pdGlvbikge1xuXHRcdFx0XHRfYXNzZXJ0KFxuXHRcdFx0XHRcdGRlZmluaXRpb24ubmFtZSAhPSBudWxsLFxuXHRcdFx0XHRcdFwiZXh0ZW5zaW9ucyBtdXN0IGhhdmUgYSBgbmFtZWAgcHJvcGVydHkuXCJcblx0XHRcdFx0KTtcblx0XHRcdFx0X2Fzc2VydChcblx0XHRcdFx0XHRkZWZpbml0aW9uLnZlcnNpb24gIT0gbnVsbCxcblx0XHRcdFx0XHRcImV4dGVuc2lvbnMgbXVzdCBoYXZlIGEgYHZlcnNpb25gIHByb3BlcnR5LlwiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdCQudWkuZmFuY3l0cmVlLl9leHRlbnNpb25zW2RlZmluaXRpb24ubmFtZV0gPSBkZWZpbml0aW9uO1xuXHRcdFx0fSxcblx0XHRcdC8qKiBJbnZlcnNlIG9mIGVzY2FwZUh0bWwoKS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gc1xuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0dW5lc2NhcGVIdG1sOiBmdW5jdGlvbihzKSB7XG5cdFx0XHRcdHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdFx0ZS5pbm5lckhUTUwgPSBzO1xuXHRcdFx0XHRyZXR1cm4gZS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMFxuXHRcdFx0XHRcdD8gXCJcIlxuXHRcdFx0XHRcdDogZS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZTtcblx0XHRcdH0sXG5cdFx0XHQvKiogV3JpdGUgd2FybmluZyBtZXNzYWdlIHRvIGNvbnNvbGUgaWYgZGVidWdMZXZlbCA+PSAyLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuXHRcdFx0ICovXG5cdFx0XHR3YXJuOiBmdW5jdGlvbihtc2cpIHtcblx0XHRcdFx0aWYgKCQudWkuZmFuY3l0cmVlLmRlYnVnTGV2ZWwgPj0gMikge1xuXHRcdFx0XHRcdGNvbnNvbGVBcHBseShcIndhcm5cIiwgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9XG5cdCk7XG5cblx0Ly8gVmFsdWUgcmV0dXJuZWQgYnkgYHJlcXVpcmUoJ2pxdWVyeS5mYW5jeXRyZWUnKWBcblx0cmV0dXJuICQudWkuZmFuY3l0cmVlO1xufSk7IC8vIEVuZCBvZiBjbG9zdXJlXG4iLCIvKiEgalF1ZXJ5IFVJIC0gdjEuMTIuMSAtIDIwMTgtMDUtMjBcbiogaHR0cDovL2pxdWVyeXVpLmNvbVxuKiBJbmNsdWRlczogd2lkZ2V0LmpzLCBwb3NpdGlvbi5qcywga2V5Y29kZS5qcywgc2Nyb2xsLXBhcmVudC5qcywgdW5pcXVlLWlkLmpzXG4qIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzOyBMaWNlbnNlZCBNSVQgKi9cblxuOyhmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRcdC8vIE5vZGUvQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQgKSB7XG5cbiQudWkgPSAkLnVpIHx8IHt9O1xuXG52YXIgdmVyc2lvbiA9ICQudWkudmVyc2lvbiA9IFwiMS4xMi4xXCI7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgV2lkZ2V0IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBXaWRnZXRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlcyBhIGZhY3RvcnkgZm9yIGNyZWF0aW5nIHN0YXRlZnVsIHdpZGdldHMgd2l0aCBhIGNvbW1vbiBBUEkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LndpZGdldC9cbi8vPj5kZW1vczogaHR0cDovL2pxdWVyeXVpLmNvbS93aWRnZXQvXG5cblxuXG52YXIgd2lkZ2V0VXVpZCA9IDA7XG52YXIgd2lkZ2V0U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiQuY2xlYW5EYXRhID0gJC5jbGVhbkRhdGEgfHwgKCBmdW5jdGlvbiggb3JpZyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZXZlbnRzLCBlbGVtLCBpO1xuXHRcdGZvciAoIGkgPSAwOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0dHJ5IHtcblxuXHRcdFx0XHQvLyBPbmx5IHRyaWdnZXIgcmVtb3ZlIHdoZW4gbmVjZXNzYXJ5IHRvIHNhdmUgdGltZVxuXHRcdFx0XHRldmVudHMgPSAkLl9kYXRhKCBlbGVtLCBcImV2ZW50c1wiICk7XG5cdFx0XHRcdGlmICggZXZlbnRzICYmIGV2ZW50cy5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0JCggZWxlbSApLnRyaWdnZXJIYW5kbGVyKCBcInJlbW92ZVwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODIzNVxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdH1cblx0XHRvcmlnKCBlbGVtcyApO1xuXHR9O1xufSApKCAkLmNsZWFuRGF0YSApO1xuXG4kLndpZGdldCA9ICQud2lkZ2V0IHx8IGZ1bmN0aW9uKCBuYW1lLCBiYXNlLCBwcm90b3R5cGUgKSB7XG5cdHZhciBleGlzdGluZ0NvbnN0cnVjdG9yLCBjb25zdHJ1Y3RvciwgYmFzZVByb3RvdHlwZTtcblxuXHQvLyBQcm94aWVkUHJvdG90eXBlIGFsbG93cyB0aGUgcHJvdmlkZWQgcHJvdG90eXBlIHRvIHJlbWFpbiB1bm1vZGlmaWVkXG5cdC8vIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBmb3IgbXVsdGlwbGUgd2lkZ2V0cyAoIzg4NzYpXG5cdHZhciBwcm94aWVkUHJvdG90eXBlID0ge307XG5cblx0dmFyIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDAgXTtcblx0bmFtZSA9IG5hbWUuc3BsaXQoIFwiLlwiIClbIDEgXTtcblx0dmFyIGZ1bGxOYW1lID0gbmFtZXNwYWNlICsgXCItXCIgKyBuYW1lO1xuXG5cdGlmICggIXByb3RvdHlwZSApIHtcblx0XHRwcm90b3R5cGUgPSBiYXNlO1xuXHRcdGJhc2UgPSAkLldpZGdldDtcblx0fVxuXG5cdGlmICggJC5pc0FycmF5KCBwcm90b3R5cGUgKSApIHtcblx0XHRwcm90b3R5cGUgPSAkLmV4dGVuZC5hcHBseSggbnVsbCwgWyB7fSBdLmNvbmNhdCggcHJvdG90eXBlICkgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBzZWxlY3RvciBmb3IgcGx1Z2luXG5cdCQuZXhwclsgXCI6XCIgXVsgZnVsbE5hbWUudG9Mb3dlckNhc2UoKSBdID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICEhJC5kYXRhKCBlbGVtLCBmdWxsTmFtZSApO1xuXHR9O1xuXG5cdCRbIG5hbWVzcGFjZSBdID0gJFsgbmFtZXNwYWNlIF0gfHwge307XG5cdGV4aXN0aW5nQ29uc3RydWN0b3IgPSAkWyBuYW1lc3BhY2UgXVsgbmFtZSBdO1xuXHRjb25zdHJ1Y3RvciA9ICRbIG5hbWVzcGFjZSBdWyBuYW1lIF0gPSBmdW5jdGlvbiggb3B0aW9ucywgZWxlbWVudCApIHtcblxuXHRcdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCBcIm5ld1wiIGtleXdvcmRcblx0XHRpZiAoICF0aGlzLl9jcmVhdGVXaWRnZXQgKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGNvbnN0cnVjdG9yKCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IGluaXRpYWxpemluZyBmb3Igc2ltcGxlIGluaGVyaXRhbmNlXG5cdFx0Ly8gbXVzdCB1c2UgXCJuZXdcIiBrZXl3b3JkICh0aGUgY29kZSBhYm92ZSBhbHdheXMgcGFzc2VzIGFyZ3MpXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0dGhpcy5fY3JlYXRlV2lkZ2V0KCBvcHRpb25zLCBlbGVtZW50ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIEV4dGVuZCB3aXRoIHRoZSBleGlzdGluZyBjb25zdHJ1Y3RvciB0byBjYXJyeSBvdmVyIGFueSBzdGF0aWMgcHJvcGVydGllc1xuXHQkLmV4dGVuZCggY29uc3RydWN0b3IsIGV4aXN0aW5nQ29uc3RydWN0b3IsIHtcblx0XHR2ZXJzaW9uOiBwcm90b3R5cGUudmVyc2lvbixcblxuXHRcdC8vIENvcHkgdGhlIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGUgcHJvdG90eXBlIGluIGNhc2Ugd2UgbmVlZCB0b1xuXHRcdC8vIHJlZGVmaW5lIHRoZSB3aWRnZXQgbGF0ZXJcblx0XHRfcHJvdG86ICQuZXh0ZW5kKCB7fSwgcHJvdG90eXBlICksXG5cblx0XHQvLyBUcmFjayB3aWRnZXRzIHRoYXQgaW5oZXJpdCBmcm9tIHRoaXMgd2lkZ2V0IGluIGNhc2UgdGhpcyB3aWRnZXQgaXNcblx0XHQvLyByZWRlZmluZWQgYWZ0ZXIgYSB3aWRnZXQgaW5oZXJpdHMgZnJvbSBpdFxuXHRcdF9jaGlsZENvbnN0cnVjdG9yczogW11cblx0fSApO1xuXG5cdGJhc2VQcm90b3R5cGUgPSBuZXcgYmFzZSgpO1xuXG5cdC8vIFdlIG5lZWQgdG8gbWFrZSB0aGUgb3B0aW9ucyBoYXNoIGEgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIG5ldyBpbnN0YW5jZVxuXHQvLyBvdGhlcndpc2Ugd2UnbGwgbW9kaWZ5IHRoZSBvcHRpb25zIGhhc2ggb24gdGhlIHByb3RvdHlwZSB0aGF0IHdlJ3JlXG5cdC8vIGluaGVyaXRpbmcgZnJvbVxuXHRiYXNlUHJvdG90eXBlLm9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQoIHt9LCBiYXNlUHJvdG90eXBlLm9wdGlvbnMgKTtcblx0JC5lYWNoKCBwcm90b3R5cGUsIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRpZiAoICEkLmlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRwcm94aWVkUHJvdG90eXBlWyBwcm9wIF0gPSB2YWx1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cHJveGllZFByb3RvdHlwZVsgcHJvcCBdID0gKCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmN0aW9uIF9zdXBlcigpIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBfc3VwZXJBcHBseSggYXJncyApIHtcblx0XHRcdFx0cmV0dXJuIGJhc2UucHJvdG90eXBlWyBwcm9wIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX19zdXBlciA9IHRoaXMuX3N1cGVyO1xuXHRcdFx0XHR2YXIgX19zdXBlckFwcGx5ID0gdGhpcy5fc3VwZXJBcHBseTtcblx0XHRcdFx0dmFyIHJldHVyblZhbHVlO1xuXG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX3N1cGVyQXBwbHk7XG5cblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWx1ZS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfX3N1cGVyO1xuXHRcdFx0XHR0aGlzLl9zdXBlckFwcGx5ID0gX19zdXBlckFwcGx5O1xuXG5cdFx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHRcdH07XG5cdFx0fSApKCk7XG5cdH0gKTtcblx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gJC53aWRnZXQuZXh0ZW5kKCBiYXNlUHJvdG90eXBlLCB7XG5cblx0XHQvLyBUT0RPOiByZW1vdmUgc3VwcG9ydCBmb3Igd2lkZ2V0RXZlbnRQcmVmaXhcblx0XHQvLyBhbHdheXMgdXNlIHRoZSBuYW1lICsgYSBjb2xvbiBhcyB0aGUgcHJlZml4LCBlLmcuLCBkcmFnZ2FibGU6c3RhcnRcblx0XHQvLyBkb24ndCBwcmVmaXggZm9yIHdpZGdldHMgdGhhdCBhcmVuJ3QgRE9NLWJhc2VkXG5cdFx0d2lkZ2V0RXZlbnRQcmVmaXg6IGV4aXN0aW5nQ29uc3RydWN0b3IgPyAoIGJhc2VQcm90b3R5cGUud2lkZ2V0RXZlbnRQcmVmaXggfHwgbmFtZSApIDogbmFtZVxuXHR9LCBwcm94aWVkUHJvdG90eXBlLCB7XG5cdFx0Y29uc3RydWN0b3I6IGNvbnN0cnVjdG9yLFxuXHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdHdpZGdldE5hbWU6IG5hbWUsXG5cdFx0d2lkZ2V0RnVsbE5hbWU6IGZ1bGxOYW1lXG5cdH0gKTtcblxuXHQvLyBJZiB0aGlzIHdpZGdldCBpcyBiZWluZyByZWRlZmluZWQgdGhlbiB3ZSBuZWVkIHRvIGZpbmQgYWxsIHdpZGdldHMgdGhhdFxuXHQvLyBhcmUgaW5oZXJpdGluZyBmcm9tIGl0IGFuZCByZWRlZmluZSBhbGwgb2YgdGhlbSBzbyB0aGF0IHRoZXkgaW5oZXJpdCBmcm9tXG5cdC8vIHRoZSBuZXcgdmVyc2lvbiBvZiB0aGlzIHdpZGdldC4gV2UncmUgZXNzZW50aWFsbHkgdHJ5aW5nIHRvIHJlcGxhY2Ugb25lXG5cdC8vIGxldmVsIGluIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5cdGlmICggZXhpc3RpbmdDb25zdHJ1Y3RvciApIHtcblx0XHQkLmVhY2goIGV4aXN0aW5nQ29uc3RydWN0b3IuX2NoaWxkQ29uc3RydWN0b3JzLCBmdW5jdGlvbiggaSwgY2hpbGQgKSB7XG5cdFx0XHR2YXIgY2hpbGRQcm90b3R5cGUgPSBjaGlsZC5wcm90b3R5cGU7XG5cblx0XHRcdC8vIFJlZGVmaW5lIHRoZSBjaGlsZCB3aWRnZXQgdXNpbmcgdGhlIHNhbWUgcHJvdG90eXBlIHRoYXQgd2FzXG5cdFx0XHQvLyBvcmlnaW5hbGx5IHVzZWQsIGJ1dCBpbmhlcml0IGZyb20gdGhlIG5ldyB2ZXJzaW9uIG9mIHRoZSBiYXNlXG5cdFx0XHQkLndpZGdldCggY2hpbGRQcm90b3R5cGUubmFtZXNwYWNlICsgXCIuXCIgKyBjaGlsZFByb3RvdHlwZS53aWRnZXROYW1lLCBjb25zdHJ1Y3Rvcixcblx0XHRcdFx0Y2hpbGQuX3Byb3RvICk7XG5cdFx0fSApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBsaXN0IG9mIGV4aXN0aW5nIGNoaWxkIGNvbnN0cnVjdG9ycyBmcm9tIHRoZSBvbGQgY29uc3RydWN0b3Jcblx0XHQvLyBzbyB0aGUgb2xkIGNoaWxkIGNvbnN0cnVjdG9ycyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgZXhpc3RpbmdDb25zdHJ1Y3Rvci5fY2hpbGRDb25zdHJ1Y3RvcnM7XG5cdH0gZWxzZSB7XG5cdFx0YmFzZS5fY2hpbGRDb25zdHJ1Y3RvcnMucHVzaCggY29uc3RydWN0b3IgKTtcblx0fVxuXG5cdCQud2lkZ2V0LmJyaWRnZSggbmFtZSwgY29uc3RydWN0b3IgKTtcblxuXHRyZXR1cm4gY29uc3RydWN0b3I7XG59O1xuXG4kLndpZGdldC5leHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHR2YXIgaW5wdXQgPSB3aWRnZXRTbGljZS5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0dmFyIGlucHV0SW5kZXggPSAwO1xuXHR2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cdHZhciBrZXk7XG5cdHZhciB2YWx1ZTtcblxuXHRmb3IgKCA7IGlucHV0SW5kZXggPCBpbnB1dExlbmd0aDsgaW5wdXRJbmRleCsrICkge1xuXHRcdGZvciAoIGtleSBpbiBpbnB1dFsgaW5wdXRJbmRleCBdICkge1xuXHRcdFx0dmFsdWUgPSBpbnB1dFsgaW5wdXRJbmRleCBdWyBrZXkgXTtcblx0XHRcdGlmICggaW5wdXRbIGlucHV0SW5kZXggXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBDbG9uZSBvYmplY3RzXG5cdFx0XHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCB2YWx1ZSApICkge1xuXHRcdFx0XHRcdHRhcmdldFsga2V5IF0gPSAkLmlzUGxhaW5PYmplY3QoIHRhcmdldFsga2V5IF0gKSA/XG5cdFx0XHRcdFx0XHQkLndpZGdldC5leHRlbmQoIHt9LCB0YXJnZXRbIGtleSBdLCB2YWx1ZSApIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgZXh0ZW5kIHN0cmluZ3MsIGFycmF5cywgZXRjLiB3aXRoIG9iamVjdHNcblx0XHRcdFx0XHRcdCQud2lkZ2V0LmV4dGVuZCgge30sIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gQ29weSBldmVyeXRoaW5nIGVsc2UgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLndpZGdldC5icmlkZ2UgPSBmdW5jdGlvbiggbmFtZSwgb2JqZWN0ICkge1xuXHR2YXIgZnVsbE5hbWUgPSBvYmplY3QucHJvdG90eXBlLndpZGdldEZ1bGxOYW1lIHx8IG5hbWU7XG5cdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdHZhciBpc01ldGhvZENhbGwgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIjtcblx0XHR2YXIgYXJncyA9IHdpZGdldFNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdHZhciByZXR1cm5WYWx1ZSA9IHRoaXM7XG5cblx0XHRpZiAoIGlzTWV0aG9kQ2FsbCApIHtcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBlbXB0eSBjb2xsZWN0aW9uLCB3ZSBuZWVkIHRvIGhhdmUgdGhlIGluc3RhbmNlIG1ldGhvZFxuXHRcdFx0Ly8gcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHRoZSBqUXVlcnkgaW5zdGFuY2Vcblx0XHRcdGlmICggIXRoaXMubGVuZ3RoICYmIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmRhdGEoIHRoaXMsIGZ1bGxOYW1lICk7XG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbnMgPT09IFwiaW5zdGFuY2VcIiApIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gaW5zdGFuY2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gJC5lcnJvciggXCJjYW5ub3QgY2FsbCBtZXRob2RzIG9uIFwiICsgbmFtZSArXG5cdFx0XHRcdFx0XHRcdFwiIHByaW9yIHRvIGluaXRpYWxpemF0aW9uOyBcIiArXG5cdFx0XHRcdFx0XHRcdFwiYXR0ZW1wdGVkIHRvIGNhbGwgbWV0aG9kICdcIiArIG9wdGlvbnMgKyBcIidcIiApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggISQuaXNGdW5jdGlvbiggaW5zdGFuY2VbIG9wdGlvbnMgXSApIHx8IG9wdGlvbnMuY2hhckF0KCAwICkgPT09IFwiX1wiICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQuZXJyb3IoIFwibm8gc3VjaCBtZXRob2QgJ1wiICsgb3B0aW9ucyArIFwiJyBmb3IgXCIgKyBuYW1lICtcblx0XHRcdFx0XHRcdFx0XCIgd2lkZ2V0IGluc3RhbmNlXCIgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRtZXRob2RWYWx1ZSA9IGluc3RhbmNlWyBvcHRpb25zIF0uYXBwbHkoIGluc3RhbmNlLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1ldGhvZFZhbHVlICE9PSBpbnN0YW5jZSAmJiBtZXRob2RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBtZXRob2RWYWx1ZSAmJiBtZXRob2RWYWx1ZS5qcXVlcnkgP1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZS5wdXNoU3RhY2soIG1ldGhvZFZhbHVlLmdldCgpICkgOlxuXHRcdFx0XHRcdFx0XHRtZXRob2RWYWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBBbGxvdyBtdWx0aXBsZSBoYXNoZXMgdG8gYmUgcGFzc2VkIG9uIGluaXRcblx0XHRcdGlmICggYXJncy5sZW5ndGggKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSAkLndpZGdldC5leHRlbmQuYXBwbHkoIG51bGwsIFsgb3B0aW9ucyBdLmNvbmNhdCggYXJncyApICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbnN0YW5jZSA9ICQuZGF0YSggdGhpcywgZnVsbE5hbWUgKTtcblx0XHRcdFx0aWYgKCBpbnN0YW5jZSApIHtcblx0XHRcdFx0XHRpbnN0YW5jZS5vcHRpb24oIG9wdGlvbnMgfHwge30gKTtcblx0XHRcdFx0XHRpZiAoIGluc3RhbmNlLl9pbml0ICkge1xuXHRcdFx0XHRcdFx0aW5zdGFuY2UuX2luaXQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5kYXRhKCB0aGlzLCBmdWxsTmFtZSwgbmV3IG9iamVjdCggb3B0aW9ucywgdGhpcyApICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG4kLldpZGdldCA9ICQuV2lkZ2V0IHx8IGZ1bmN0aW9uKCAvKiBvcHRpb25zLCBlbGVtZW50ICovICkge307XG4kLldpZGdldC5fY2hpbGRDb25zdHJ1Y3RvcnMgPSBbXTtcblxuJC5XaWRnZXQucHJvdG90eXBlID0ge1xuXHR3aWRnZXROYW1lOiBcIndpZGdldFwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJcIixcblx0ZGVmYXVsdEVsZW1lbnQ6IFwiPGRpdj5cIixcblxuXHRvcHRpb25zOiB7XG5cdFx0Y2xhc3Nlczoge30sXG5cdFx0ZGlzYWJsZWQ6IGZhbHNlLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0Y3JlYXRlOiBudWxsXG5cdH0sXG5cblx0X2NyZWF0ZVdpZGdldDogZnVuY3Rpb24oIG9wdGlvbnMsIGVsZW1lbnQgKSB7XG5cdFx0ZWxlbWVudCA9ICQoIGVsZW1lbnQgfHwgdGhpcy5kZWZhdWx0RWxlbWVudCB8fCB0aGlzIClbIDAgXTtcblx0XHR0aGlzLmVsZW1lbnQgPSAkKCBlbGVtZW50ICk7XG5cdFx0dGhpcy51dWlkID0gd2lkZ2V0VXVpZCsrO1xuXHRcdHRoaXMuZXZlbnROYW1lc3BhY2UgPSBcIi5cIiArIHRoaXMud2lkZ2V0TmFtZSArIHRoaXMudXVpZDtcblxuXHRcdHRoaXMuYmluZGluZ3MgPSAkKCk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCk7XG5cdFx0dGhpcy5mb2N1c2FibGUgPSAkKCk7XG5cdFx0dGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCA9IHt9O1xuXG5cdFx0aWYgKCBlbGVtZW50ICE9PSB0aGlzICkge1xuXHRcdFx0JC5kYXRhKCBlbGVtZW50LCB0aGlzLndpZGdldEZ1bGxOYW1lLCB0aGlzICk7XG5cdFx0XHR0aGlzLl9vbiggdHJ1ZSwgdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRcdGlmICggZXZlbnQudGFyZ2V0ID09PSBlbGVtZW50ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLmRvY3VtZW50ID0gJCggZWxlbWVudC5zdHlsZSA/XG5cblx0XHRcdFx0Ly8gRWxlbWVudCB3aXRoaW4gdGhlIGRvY3VtZW50XG5cdFx0XHRcdGVsZW1lbnQub3duZXJEb2N1bWVudCA6XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyB3aW5kb3cgb3IgZG9jdW1lbnRcblx0XHRcdFx0ZWxlbWVudC5kb2N1bWVudCB8fCBlbGVtZW50ICk7XG5cdFx0XHR0aGlzLndpbmRvdyA9ICQoIHRoaXMuZG9jdW1lbnRbIDAgXS5kZWZhdWx0VmlldyB8fCB0aGlzLmRvY3VtZW50WyAwIF0ucGFyZW50V2luZG93ICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5vcHRpb25zID0gJC53aWRnZXQuZXh0ZW5kKCB7fSxcblx0XHRcdHRoaXMub3B0aW9ucyxcblx0XHRcdHRoaXMuX2dldENyZWF0ZU9wdGlvbnMoKSxcblx0XHRcdG9wdGlvbnMgKTtcblxuXHRcdHRoaXMuX2NyZWF0ZSgpO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHR0aGlzLl9zZXRPcHRpb25EaXNhYmxlZCggdGhpcy5vcHRpb25zLmRpc2FibGVkICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJpZ2dlciggXCJjcmVhdGVcIiwgbnVsbCwgdGhpcy5fZ2V0Q3JlYXRlRXZlbnREYXRhKCkgKTtcblx0XHR0aGlzLl9pbml0KCk7XG5cdH0sXG5cblx0X2dldENyZWF0ZU9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSxcblxuXHRfZ2V0Q3JlYXRlRXZlbnREYXRhOiAkLm5vb3AsXG5cblx0X2NyZWF0ZTogJC5ub29wLFxuXG5cdF9pbml0OiAkLm5vb3AsXG5cblx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdCQuZWFjaCggdGhpcy5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGF0Ll9yZW1vdmVDbGFzcyggdmFsdWUsIGtleSApO1xuXHRcdH0gKTtcblxuXHRcdC8vIFdlIGNhbiBwcm9iYWJseSByZW1vdmUgdGhlIHVuYmluZCBjYWxscyBpbiAyLjBcblx0XHQvLyBhbGwgZXZlbnQgYmluZGluZ3Mgc2hvdWxkIGdvIHRocm91Z2ggdGhpcy5fb24oKVxuXHRcdHRoaXMuZWxlbWVudFxuXHRcdFx0Lm9mZiggdGhpcy5ldmVudE5hbWVzcGFjZSApXG5cdFx0XHQucmVtb3ZlRGF0YSggdGhpcy53aWRnZXRGdWxsTmFtZSApO1xuXHRcdHRoaXMud2lkZ2V0KClcblx0XHRcdC5vZmYoIHRoaXMuZXZlbnROYW1lc3BhY2UgKVxuXHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1kaXNhYmxlZFwiICk7XG5cblx0XHQvLyBDbGVhbiB1cCBldmVudHMgYW5kIHN0YXRlc1xuXHRcdHRoaXMuYmluZGluZ3Mub2ZmKCB0aGlzLmV2ZW50TmFtZXNwYWNlICk7XG5cdH0sXG5cblx0X2Rlc3Ryb3k6ICQubm9vcCxcblxuXHR3aWRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XG5cdH0sXG5cblx0b3B0aW9uOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgb3B0aW9ucyA9IGtleTtcblx0XHR2YXIgcGFydHM7XG5cdFx0dmFyIGN1ck9wdGlvbjtcblx0XHR2YXIgaTtcblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBoYXNoXG5cdFx0XHRyZXR1cm4gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyBIYW5kbGUgbmVzdGVkIGtleXMsIGUuZy4sIFwiZm9vLmJhclwiID0+IHsgZm9vOiB7IGJhcjogX19fIH0gfVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0cGFydHMgPSBrZXkuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHRrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0aWYgKCBwYXJ0cy5sZW5ndGggKSB7XG5cdFx0XHRcdGN1ck9wdGlvbiA9IG9wdGlvbnNbIGtleSBdID0gJC53aWRnZXQuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zWyBrZXkgXSApO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKyApIHtcblx0XHRcdFx0XHRjdXJPcHRpb25bIHBhcnRzWyBpIF0gXSA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdIHx8IHt9O1xuXHRcdFx0XHRcdGN1ck9wdGlvbiA9IGN1ck9wdGlvblsgcGFydHNbIGkgXSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleSA9IHBhcnRzLnBvcCgpO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGN1ck9wdGlvblsga2V5IF0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdXJPcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN1ck9wdGlvblsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zWyBrZXkgXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHRoaXMub3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXRPcHRpb25zKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2V0T3B0aW9uczogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uKCBrZXksIG9wdGlvbnNbIGtleSBdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbjogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0aWYgKCBrZXkgPT09IFwiY2xhc3Nlc1wiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uQ2xhc3NlcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLm9wdGlvbnNbIGtleSBdID0gdmFsdWU7XG5cblx0XHRpZiAoIGtleSA9PT0gXCJkaXNhYmxlZFwiICkge1xuXHRcdFx0dGhpcy5fc2V0T3B0aW9uRGlzYWJsZWQoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NldE9wdGlvbkNsYXNzZXM6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NLZXksIGVsZW1lbnRzLCBjdXJyZW50RWxlbWVudHM7XG5cblx0XHRmb3IgKCBjbGFzc0tleSBpbiB2YWx1ZSApIHtcblx0XHRcdGN1cnJlbnRFbGVtZW50cyA9IHRoaXMuY2xhc3Nlc0VsZW1lbnRMb29rdXBbIGNsYXNzS2V5IF07XG5cdFx0XHRpZiAoIHZhbHVlWyBjbGFzc0tleSBdID09PSB0aGlzLm9wdGlvbnMuY2xhc3Nlc1sgY2xhc3NLZXkgXSB8fFxuXHRcdFx0XHRcdCFjdXJyZW50RWxlbWVudHMgfHxcblx0XHRcdFx0XHQhY3VycmVudEVsZW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlIGFyZSBkb2luZyB0aGlzIHRvIGNyZWF0ZSBhIG5ldyBqUXVlcnkgb2JqZWN0IGJlY2F1c2UgdGhlIF9yZW1vdmVDbGFzcygpIGNhbGxcblx0XHRcdC8vIG9uIHRoZSBuZXh0IGxpbmUgaXMgZ29pbmcgdG8gZGVzdHJveSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGVsZW1lbnRzIGJlaW5nXG5cdFx0XHQvLyB0cmFja2VkLiBXZSBuZWVkIHRvIHNhdmUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbiBzbyB0aGF0IHdlIGNhbiBhZGQgdGhlIG5ldyBjbGFzc2VzXG5cdFx0XHQvLyBiZWxvdy5cblx0XHRcdGVsZW1lbnRzID0gJCggY3VycmVudEVsZW1lbnRzLmdldCgpICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggY3VycmVudEVsZW1lbnRzLCBjbGFzc0tleSApO1xuXG5cdFx0XHQvLyBXZSBkb24ndCB1c2UgX2FkZENsYXNzKCkgaGVyZSwgYmVjYXVzZSB0aGF0IHVzZXMgdGhpcy5vcHRpb25zLmNsYXNzZXNcblx0XHRcdC8vIGZvciBnZW5lcmF0aW5nIHRoZSBzdHJpbmcgb2YgY2xhc3Nlcy4gV2Ugd2FudCB0byB1c2UgdGhlIHZhbHVlIHBhc3NlZCBpbiBmcm9tXG5cdFx0XHQvLyBfc2V0T3B0aW9uKCksIHRoaXMgaXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2xhc3NlcyBvcHRpb24gd2hpY2ggd2FzIHBhc3NlZCB0b1xuXHRcdFx0Ly8gX3NldE9wdGlvbigpLiBXZSBwYXNzIHRoaXMgdmFsdWUgZGlyZWN0bHkgdG8gX2NsYXNzZXMoKS5cblx0XHRcdGVsZW1lbnRzLmFkZENsYXNzKCB0aGlzLl9jbGFzc2VzKCB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnRzLFxuXHRcdFx0XHRrZXlzOiBjbGFzc0tleSxcblx0XHRcdFx0Y2xhc3NlczogdmFsdWUsXG5cdFx0XHRcdGFkZDogdHJ1ZVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZXRPcHRpb25EaXNhYmxlZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMuX3RvZ2dsZUNsYXNzKCB0aGlzLndpZGdldCgpLCB0aGlzLndpZGdldEZ1bGxOYW1lICsgXCItZGlzYWJsZWRcIiwgbnVsbCwgISF2YWx1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlIHdpZGdldCBpcyBiZWNvbWluZyBkaXNhYmxlZCwgdGhlbiBub3RoaW5nIGlzIGludGVyYWN0aXZlXG5cdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhvdmVyYWJsZSwgbnVsbCwgXCJ1aS1zdGF0ZS1ob3ZlclwiICk7XG5cdFx0XHR0aGlzLl9yZW1vdmVDbGFzcyggdGhpcy5mb2N1c2FibGUsIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZXRPcHRpb25zKCB7IGRpc2FibGVkOiBmYWxzZSB9ICk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NldE9wdGlvbnMoIHsgZGlzYWJsZWQ6IHRydWUgfSApO1xuXHR9LFxuXG5cdF9jbGFzc2VzOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHR2YXIgZnVsbCA9IFtdO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCgge1xuXHRcdFx0ZWxlbWVudDogdGhpcy5lbGVtZW50LFxuXHRcdFx0Y2xhc3NlczogdGhpcy5vcHRpb25zLmNsYXNzZXMgfHwge31cblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzQ2xhc3NTdHJpbmcoIGNsYXNzZXMsIGNoZWNrT3B0aW9uICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGk7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSB0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSB8fCAkKCk7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5hZGQgKSB7XG5cdFx0XHRcdFx0Y3VycmVudCA9ICQoICQudW5pcXVlKCBjdXJyZW50LmdldCgpLmNvbmNhdCggb3B0aW9ucy5lbGVtZW50LmdldCgpICkgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN1cnJlbnQgPSAkKCBjdXJyZW50Lm5vdCggb3B0aW9ucy5lbGVtZW50ICkuZ2V0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGF0LmNsYXNzZXNFbGVtZW50TG9va3VwWyBjbGFzc2VzWyBpIF0gXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdGZ1bGwucHVzaCggY2xhc3Nlc1sgaSBdICk7XG5cdFx0XHRcdGlmICggY2hlY2tPcHRpb24gJiYgb3B0aW9ucy5jbGFzc2VzWyBjbGFzc2VzWyBpIF0gXSApIHtcblx0XHRcdFx0XHRmdWxsLnB1c2goIG9wdGlvbnMuY2xhc3Nlc1sgY2xhc3Nlc1sgaSBdIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX29uKCBvcHRpb25zLmVsZW1lbnQsIHtcblx0XHRcdFwicmVtb3ZlXCI6IFwiX3VudHJhY2tDbGFzc2VzRWxlbWVudFwiXG5cdFx0fSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLmtleXMgKSB7XG5cdFx0XHRwcm9jZXNzQ2xhc3NTdHJpbmcoIG9wdGlvbnMua2V5cy5tYXRjaCggL1xcUysvZyApIHx8IFtdLCB0cnVlICk7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5leHRyYSApIHtcblx0XHRcdHByb2Nlc3NDbGFzc1N0cmluZyggb3B0aW9ucy5leHRyYS5tYXRjaCggL1xcUysvZyApIHx8IFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bGwuam9pbiggXCIgXCIgKTtcblx0fSxcblxuXHRfdW50cmFja0NsYXNzZXNFbGVtZW50OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdCQuZWFjaCggdGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cCwgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoICQuaW5BcnJheSggZXZlbnQudGFyZ2V0LCB2YWx1ZSApICE9PSAtMSApIHtcblx0XHRcdFx0dGhhdC5jbGFzc2VzRWxlbWVudExvb2t1cFsga2V5IF0gPSAkKCB2YWx1ZS5ub3QoIGV2ZW50LnRhcmdldCApLmdldCgpICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9yZW1vdmVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhICkge1xuXHRcdHJldHVybiB0aGlzLl90b2dnbGVDbGFzcyggZWxlbWVudCwga2V5cywgZXh0cmEsIGZhbHNlICk7XG5cdH0sXG5cblx0X2FkZENsYXNzOiBmdW5jdGlvbiggZWxlbWVudCwga2V5cywgZXh0cmEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZUNsYXNzKCBlbGVtZW50LCBrZXlzLCBleHRyYSwgdHJ1ZSApO1xuXHR9LFxuXG5cdF90b2dnbGVDbGFzczogZnVuY3Rpb24oIGVsZW1lbnQsIGtleXMsIGV4dHJhLCBhZGQgKSB7XG5cdFx0YWRkID0gKCB0eXBlb2YgYWRkID09PSBcImJvb2xlYW5cIiApID8gYWRkIDogZXh0cmE7XG5cdFx0dmFyIHNoaWZ0ID0gKCB0eXBlb2YgZWxlbWVudCA9PT0gXCJzdHJpbmdcIiB8fCBlbGVtZW50ID09PSBudWxsICksXG5cdFx0XHRvcHRpb25zID0ge1xuXHRcdFx0XHRleHRyYTogc2hpZnQgPyBrZXlzIDogZXh0cmEsXG5cdFx0XHRcdGtleXM6IHNoaWZ0ID8gZWxlbWVudCA6IGtleXMsXG5cdFx0XHRcdGVsZW1lbnQ6IHNoaWZ0ID8gdGhpcy5lbGVtZW50IDogZWxlbWVudCxcblx0XHRcdFx0YWRkOiBhZGRcblx0XHRcdH07XG5cdFx0b3B0aW9ucy5lbGVtZW50LnRvZ2dsZUNsYXNzKCB0aGlzLl9jbGFzc2VzKCBvcHRpb25zICksIGFkZCApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9vbjogZnVuY3Rpb24oIHN1cHByZXNzRGlzYWJsZWRDaGVjaywgZWxlbWVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGRlbGVnYXRlRWxlbWVudDtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Ly8gTm8gc3VwcHJlc3NEaXNhYmxlZENoZWNrIGZsYWcsIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0aWYgKCB0eXBlb2Ygc3VwcHJlc3NEaXNhYmxlZENoZWNrICE9PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdGhhbmRsZXJzID0gZWxlbWVudDtcblx0XHRcdGVsZW1lbnQgPSBzdXBwcmVzc0Rpc2FibGVkQ2hlY2s7XG5cdFx0XHRzdXBwcmVzc0Rpc2FibGVkQ2hlY2sgPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBObyBlbGVtZW50IGFyZ3VtZW50LCBzaHVmZmxlIGFuZCB1c2UgdGhpcy5lbGVtZW50XG5cdFx0aWYgKCAhaGFuZGxlcnMgKSB7XG5cdFx0XHRoYW5kbGVycyA9IGVsZW1lbnQ7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0ZGVsZWdhdGVFbGVtZW50ID0gdGhpcy53aWRnZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudCA9IGRlbGVnYXRlRWxlbWVudCA9ICQoIGVsZW1lbnQgKTtcblx0XHRcdHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmFkZCggZWxlbWVudCApO1xuXHRcdH1cblxuXHRcdCQuZWFjaCggaGFuZGxlcnMsIGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlciApIHtcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblxuXHRcdFx0XHQvLyBBbGxvdyB3aWRnZXRzIHRvIGN1c3RvbWl6ZSB0aGUgZGlzYWJsZWQgaGFuZGxpbmdcblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBhcyBhbiBhcnJheSBpbnN0ZWFkIG9mIGJvb2xlYW5cblx0XHRcdFx0Ly8gLSBkaXNhYmxlZCBjbGFzcyBhcyBtZXRob2QgZm9yIGRpc2FibGluZyBpbmRpdmlkdWFsIHBhcnRzXG5cdFx0XHRcdGlmICggIXN1cHByZXNzRGlzYWJsZWRDaGVjayAmJlxuXHRcdFx0XHRcdFx0KCBpbnN0YW5jZS5vcHRpb25zLmRpc2FibGVkID09PSB0cnVlIHx8XG5cdFx0XHRcdFx0XHQkKCB0aGlzICkuaGFzQ2xhc3MoIFwidWktc3RhdGUtZGlzYWJsZWRcIiApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHRcdC5hcHBseSggaW5zdGFuY2UsIGFyZ3VtZW50cyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb3B5IHRoZSBndWlkIHNvIGRpcmVjdCB1bmJpbmRpbmcgd29ya3Ncblx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdGhhbmRsZXJQcm94eS5ndWlkID0gaGFuZGxlci5ndWlkID1cblx0XHRcdFx0XHRoYW5kbGVyLmd1aWQgfHwgaGFuZGxlclByb3h5Lmd1aWQgfHwgJC5ndWlkKys7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtYXRjaCA9IGV2ZW50Lm1hdGNoKCAvXihbXFx3Oi1dKilcXHMqKC4qKSQvICk7XG5cdFx0XHR2YXIgZXZlbnROYW1lID0gbWF0Y2hbIDEgXSArIGluc3RhbmNlLmV2ZW50TmFtZXNwYWNlO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0ZGVsZWdhdGVFbGVtZW50Lm9uKCBldmVudE5hbWUsIHNlbGVjdG9yLCBoYW5kbGVyUHJveHkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQub24oIGV2ZW50TmFtZSwgaGFuZGxlclByb3h5ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdF9vZmY6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudE5hbWUgKSB7XG5cdFx0ZXZlbnROYW1lID0gKCBldmVudE5hbWUgfHwgXCJcIiApLnNwbGl0KCBcIiBcIiApLmpvaW4oIHRoaXMuZXZlbnROYW1lc3BhY2UgKyBcIiBcIiApICtcblx0XHRcdHRoaXMuZXZlbnROYW1lc3BhY2U7XG5cdFx0ZWxlbWVudC5vZmYoIGV2ZW50TmFtZSApLm9mZiggZXZlbnROYW1lICk7XG5cblx0XHQvLyBDbGVhciB0aGUgc3RhY2sgdG8gYXZvaWQgbWVtb3J5IGxlYWtzICgjMTAwNTYpXG5cdFx0dGhpcy5iaW5kaW5ncyA9ICQoIHRoaXMuYmluZGluZ3Mubm90KCBlbGVtZW50ICkuZ2V0KCkgKTtcblx0XHR0aGlzLmZvY3VzYWJsZSA9ICQoIHRoaXMuZm9jdXNhYmxlLm5vdCggZWxlbWVudCApLmdldCgpICk7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSAkKCB0aGlzLmhvdmVyYWJsZS5ub3QoIGVsZW1lbnQgKS5nZXQoKSApO1xuXHR9LFxuXG5cdF9kZWxheTogZnVuY3Rpb24oIGhhbmRsZXIsIGRlbGF5ICkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZXJQcm94eSgpIHtcblx0XHRcdHJldHVybiAoIHR5cGVvZiBoYW5kbGVyID09PSBcInN0cmluZ1wiID8gaW5zdGFuY2VbIGhhbmRsZXIgXSA6IGhhbmRsZXIgKVxuXHRcdFx0XHQuYXBwbHkoIGluc3RhbmNlLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdFx0dmFyIGluc3RhbmNlID0gdGhpcztcblx0XHRyZXR1cm4gc2V0VGltZW91dCggaGFuZGxlclByb3h5LCBkZWxheSB8fCAwICk7XG5cdH0sXG5cblx0X2hvdmVyYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dGhpcy5ob3ZlcmFibGUgPSB0aGlzLmhvdmVyYWJsZS5hZGQoIGVsZW1lbnQgKTtcblx0XHR0aGlzLl9vbiggZWxlbWVudCwge1xuXHRcdFx0bW91c2VlbnRlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR0aGlzLl9hZGRDbGFzcyggJCggZXZlbnQuY3VycmVudFRhcmdldCApLCBudWxsLCBcInVpLXN0YXRlLWhvdmVyXCIgKTtcblx0XHRcdH0sXG5cdFx0XHRtb3VzZWxlYXZlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtaG92ZXJcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfZm9jdXNhYmxlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR0aGlzLmZvY3VzYWJsZSA9IHRoaXMuZm9jdXNhYmxlLmFkZCggZWxlbWVudCApO1xuXHRcdHRoaXMuX29uKCBlbGVtZW50LCB7XG5cdFx0XHRmb2N1c2luOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX2FkZENsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fSxcblx0XHRcdGZvY3Vzb3V0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHRoaXMuX3JlbW92ZUNsYXNzKCAkKCBldmVudC5jdXJyZW50VGFyZ2V0ICksIG51bGwsIFwidWktc3RhdGUtZm9jdXNcIiApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRfdHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGV2ZW50LCBkYXRhICkge1xuXHRcdHZhciBwcm9wLCBvcmlnO1xuXHRcdHZhciBjYWxsYmFjayA9IHRoaXMub3B0aW9uc1sgdHlwZSBdO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0ZXZlbnQgPSAkLkV2ZW50KCBldmVudCApO1xuXHRcdGV2ZW50LnR5cGUgPSAoIHR5cGUgPT09IHRoaXMud2lkZ2V0RXZlbnRQcmVmaXggP1xuXHRcdFx0dHlwZSA6XG5cdFx0XHR0aGlzLndpZGdldEV2ZW50UHJlZml4ICsgdHlwZSApLnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvLyBUaGUgb3JpZ2luYWwgZXZlbnQgbWF5IGNvbWUgZnJvbSBhbnkgZWxlbWVudFxuXHRcdC8vIHNvIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHRhcmdldCBvbiB0aGUgbmV3IGV2ZW50XG5cdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcy5lbGVtZW50WyAwIF07XG5cblx0XHQvLyBDb3B5IG9yaWdpbmFsIGV2ZW50IHByb3BlcnRpZXMgb3ZlciB0byB0aGUgbmV3IGV2ZW50XG5cdFx0b3JpZyA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQ7XG5cdFx0aWYgKCBvcmlnICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRpZiAoICEoIHByb3AgaW4gZXZlbnQgKSApIHtcblx0XHRcdFx0XHRldmVudFsgcHJvcCBdID0gb3JpZ1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIGV2ZW50LCBkYXRhICk7XG5cdFx0cmV0dXJuICEoICQuaXNGdW5jdGlvbiggY2FsbGJhY2sgKSAmJlxuXHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0uY29uY2F0KCBkYXRhICkgKSA9PT0gZmFsc2UgfHxcblx0XHRcdGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICk7XG5cdH1cbn07XG5cbiQuZWFjaCggeyBzaG93OiBcImZhZGVJblwiLCBoaWRlOiBcImZhZGVPdXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBkZWZhdWx0RWZmZWN0ICkge1xuXHQkLldpZGdldC5wcm90b3R5cGVbIFwiX1wiICsgbWV0aG9kIF0gPSBmdW5jdGlvbiggZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB7IGVmZmVjdDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBoYXNPcHRpb25zO1xuXHRcdHZhciBlZmZlY3ROYW1lID0gIW9wdGlvbnMgP1xuXHRcdFx0bWV0aG9kIDpcblx0XHRcdG9wdGlvbnMgPT09IHRydWUgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgP1xuXHRcdFx0XHRkZWZhdWx0RWZmZWN0IDpcblx0XHRcdFx0b3B0aW9ucy5lZmZlY3QgfHwgZGVmYXVsdEVmZmVjdDtcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRvcHRpb25zID0geyBkdXJhdGlvbjogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdGhhc09wdGlvbnMgPSAhJC5pc0VtcHR5T2JqZWN0KCBvcHRpb25zICk7XG5cdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNhbGxiYWNrO1xuXG5cdFx0aWYgKCBvcHRpb25zLmRlbGF5ICkge1xuXHRcdFx0ZWxlbWVudC5kZWxheSggb3B0aW9ucy5kZWxheSApO1xuXHRcdH1cblxuXHRcdGlmICggaGFzT3B0aW9ucyAmJiAkLmVmZmVjdHMgJiYgJC5lZmZlY3RzLmVmZmVjdFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgbWV0aG9kIF0oIG9wdGlvbnMgKTtcblx0XHR9IGVsc2UgaWYgKCBlZmZlY3ROYW1lICE9PSBtZXRob2QgJiYgZWxlbWVudFsgZWZmZWN0TmFtZSBdICkge1xuXHRcdFx0ZWxlbWVudFsgZWZmZWN0TmFtZSBdKCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmVhc2luZywgY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC5xdWV1ZSggZnVuY3Rpb24oIG5leHQgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKVsgbWV0aG9kIF0oKTtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBlbGVtZW50WyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXh0KCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG52YXIgd2lkZ2V0ID0gJC53aWRnZXQ7XG5cblxuLyohXG4gKiBqUXVlcnkgVUkgUG9zaXRpb24gMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9wb3NpdGlvbi9cbiAqL1xuXG4vLz4+bGFiZWw6IFBvc2l0aW9uXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogUG9zaXRpb25zIGVsZW1lbnRzIHJlbGF0aXZlIHRvIG90aGVyIGVsZW1lbnRzLlxuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuLy8+PmRlbW9zOiBodHRwOi8vanF1ZXJ5dWkuY29tL3Bvc2l0aW9uL1xuXG5cbiggZnVuY3Rpb24oKSB7XG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGgsXG5cdG1heCA9IE1hdGgubWF4LFxuXHRhYnMgPSBNYXRoLmFicyxcblx0cmhvcml6b250YWwgPSAvbGVmdHxjZW50ZXJ8cmlnaHQvLFxuXHRydmVydGljYWwgPSAvdG9wfGNlbnRlcnxib3R0b20vLFxuXHRyb2Zmc2V0ID0gL1tcXCtcXC1dXFxkKyhcXC5bXFxkXSspPyU/Lyxcblx0cnBvc2l0aW9uID0gL15cXHcrLyxcblx0cnBlcmNlbnQgPSAvJSQvLFxuXHRfcG9zaXRpb24gPSAkLmZuLnBvc2l0aW9uO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKCBvZmZzZXRzLCB3aWR0aCwgaGVpZ2h0ICkge1xuXHRyZXR1cm4gW1xuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDAgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAwIF0gKSA/IHdpZHRoIC8gMTAwIDogMSApLFxuXHRcdHBhcnNlRmxvYXQoIG9mZnNldHNbIDEgXSApICogKCBycGVyY2VudC50ZXN0KCBvZmZzZXRzWyAxIF0gKSA/IGhlaWdodCAvIDEwMCA6IDEgKVxuXHRdO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzcyggZWxlbWVudCwgcHJvcGVydHkgKSB7XG5cdHJldHVybiBwYXJzZUludCggJC5jc3MoIGVsZW1lbnQsIHByb3BlcnR5ICksIDEwICkgfHwgMDtcbn1cblxuZnVuY3Rpb24gZ2V0RGltZW5zaW9ucyggZWxlbSApIHtcblx0dmFyIHJhdyA9IGVsZW1bIDAgXTtcblx0aWYgKCByYXcubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiAwLCBsZWZ0OiAwIH1cblx0XHR9O1xuXHR9XG5cdGlmICggJC5pc1dpbmRvdyggcmF3ICkgKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHdpZHRoOiBlbGVtLndpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IGVsZW0uaGVpZ2h0KCksXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiBlbGVtLnNjcm9sbFRvcCgpLCBsZWZ0OiBlbGVtLnNjcm9sbExlZnQoKSB9XG5cdFx0fTtcblx0fVxuXHRpZiAoIHJhdy5wcmV2ZW50RGVmYXVsdCApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0d2lkdGg6IDAsXG5cdFx0XHRoZWlnaHQ6IDAsXG5cdFx0XHRvZmZzZXQ6IHsgdG9wOiByYXcucGFnZVksIGxlZnQ6IHJhdy5wYWdlWCB9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4ge1xuXHRcdHdpZHRoOiBlbGVtLm91dGVyV2lkdGgoKSxcblx0XHRoZWlnaHQ6IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRvZmZzZXQ6IGVsZW0ub2Zmc2V0KClcblx0fTtcbn1cblxuJC5wb3NpdGlvbiA9ICQucG9zaXRpb24gfHwge1xuXHRzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBjYWNoZWRTY3JvbGxiYXJXaWR0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIGNhY2hlZFNjcm9sbGJhcldpZHRoO1xuXHRcdH1cblx0XHR2YXIgdzEsIHcyLFxuXHRcdFx0ZGl2ID0gJCggXCI8ZGl2IFwiICtcblx0XHRcdFx0XCJzdHlsZT0nZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDo1MHB4O2hlaWdodDo1MHB4O292ZXJmbG93OmhpZGRlbjsnPlwiICtcblx0XHRcdFx0XCI8ZGl2IHN0eWxlPSdoZWlnaHQ6MTAwcHg7d2lkdGg6YXV0bzsnPjwvZGl2PjwvZGl2PlwiICksXG5cdFx0XHRpbm5lckRpdiA9IGRpdi5jaGlsZHJlbigpWyAwIF07XG5cblx0XHQkKCBcImJvZHlcIiApLmFwcGVuZCggZGl2ICk7XG5cdFx0dzEgPSBpbm5lckRpdi5vZmZzZXRXaWR0aDtcblx0XHRkaXYuY3NzKCBcIm92ZXJmbG93XCIsIFwic2Nyb2xsXCIgKTtcblxuXHRcdHcyID0gaW5uZXJEaXYub2Zmc2V0V2lkdGg7XG5cblx0XHRpZiAoIHcxID09PSB3MiApIHtcblx0XHRcdHcyID0gZGl2WyAwIF0uY2xpZW50V2lkdGg7XG5cdFx0fVxuXG5cdFx0ZGl2LnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuICggY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSB3MSAtIHcyICk7XG5cdH0sXG5cdGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCB3aXRoaW4gKSB7XG5cdFx0dmFyIG92ZXJmbG93WCA9IHdpdGhpbi5pc1dpbmRvdyB8fCB3aXRoaW4uaXNEb2N1bWVudCA/IFwiXCIgOlxuXHRcdFx0XHR3aXRoaW4uZWxlbWVudC5jc3MoIFwib3ZlcmZsb3cteFwiICksXG5cdFx0XHRvdmVyZmxvd1kgPSB3aXRoaW4uaXNXaW5kb3cgfHwgd2l0aGluLmlzRG9jdW1lbnQgPyBcIlwiIDpcblx0XHRcdFx0d2l0aGluLmVsZW1lbnQuY3NzKCBcIm92ZXJmbG93LXlcIiApLFxuXHRcdFx0aGFzT3ZlcmZsb3dYID0gb3ZlcmZsb3dYID09PSBcInNjcm9sbFwiIHx8XG5cdFx0XHRcdCggb3ZlcmZsb3dYID09PSBcImF1dG9cIiAmJiB3aXRoaW4ud2lkdGggPCB3aXRoaW4uZWxlbWVudFsgMCBdLnNjcm9sbFdpZHRoICksXG5cdFx0XHRoYXNPdmVyZmxvd1kgPSBvdmVyZmxvd1kgPT09IFwic2Nyb2xsXCIgfHxcblx0XHRcdFx0KCBvdmVyZmxvd1kgPT09IFwiYXV0b1wiICYmIHdpdGhpbi5oZWlnaHQgPCB3aXRoaW4uZWxlbWVudFsgMCBdLnNjcm9sbEhlaWdodCApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR3aWR0aDogaGFzT3ZlcmZsb3dZID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMCxcblx0XHRcdGhlaWdodDogaGFzT3ZlcmZsb3dYID8gJC5wb3NpdGlvbi5zY3JvbGxiYXJXaWR0aCgpIDogMFxuXHRcdH07XG5cdH0sXG5cdGdldFdpdGhpbkluZm86IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciB3aXRoaW5FbGVtZW50ID0gJCggZWxlbWVudCB8fCB3aW5kb3cgKSxcblx0XHRcdGlzV2luZG93ID0gJC5pc1dpbmRvdyggd2l0aGluRWxlbWVudFsgMCBdICksXG5cdFx0XHRpc0RvY3VtZW50ID0gISF3aXRoaW5FbGVtZW50WyAwIF0gJiYgd2l0aGluRWxlbWVudFsgMCBdLm5vZGVUeXBlID09PSA5LFxuXHRcdFx0aGFzT2Zmc2V0ID0gIWlzV2luZG93ICYmICFpc0RvY3VtZW50O1xuXHRcdHJldHVybiB7XG5cdFx0XHRlbGVtZW50OiB3aXRoaW5FbGVtZW50LFxuXHRcdFx0aXNXaW5kb3c6IGlzV2luZG93LFxuXHRcdFx0aXNEb2N1bWVudDogaXNEb2N1bWVudCxcblx0XHRcdG9mZnNldDogaGFzT2Zmc2V0ID8gJCggZWxlbWVudCApLm9mZnNldCgpIDogeyBsZWZ0OiAwLCB0b3A6IDAgfSxcblx0XHRcdHNjcm9sbExlZnQ6IHdpdGhpbkVsZW1lbnQuc2Nyb2xsTGVmdCgpLFxuXHRcdFx0c2Nyb2xsVG9wOiB3aXRoaW5FbGVtZW50LnNjcm9sbFRvcCgpLFxuXHRcdFx0d2lkdGg6IHdpdGhpbkVsZW1lbnQub3V0ZXJXaWR0aCgpLFxuXHRcdFx0aGVpZ2h0OiB3aXRoaW5FbGVtZW50Lm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9XG59O1xuXG4kLmZuLnBvc2l0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdGlmICggIW9wdGlvbnMgfHwgIW9wdGlvbnMub2YgKSB7XG5cdFx0cmV0dXJuIF9wb3NpdGlvbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdH1cblxuXHQvLyBNYWtlIGEgY29weSwgd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgYXJndW1lbnRzXG5cdG9wdGlvbnMgPSAkLmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgYXRPZmZzZXQsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIHRhcmdldE9mZnNldCwgYmFzZVBvc2l0aW9uLCBkaW1lbnNpb25zLFxuXHRcdHRhcmdldCA9ICQoIG9wdGlvbnMub2YgKSxcblx0XHR3aXRoaW4gPSAkLnBvc2l0aW9uLmdldFdpdGhpbkluZm8oIG9wdGlvbnMud2l0aGluICksXG5cdFx0c2Nyb2xsSW5mbyA9ICQucG9zaXRpb24uZ2V0U2Nyb2xsSW5mbyggd2l0aGluICksXG5cdFx0Y29sbGlzaW9uID0gKCBvcHRpb25zLmNvbGxpc2lvbiB8fCBcImZsaXBcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdG9mZnNldHMgPSB7fTtcblxuXHRkaW1lbnNpb25zID0gZ2V0RGltZW5zaW9ucyggdGFyZ2V0ICk7XG5cdGlmICggdGFyZ2V0WyAwIF0ucHJldmVudERlZmF1bHQgKSB7XG5cblx0XHQvLyBGb3JjZSBsZWZ0IHRvcCB0byBhbGxvdyBmbGlwcGluZ1xuXHRcdG9wdGlvbnMuYXQgPSBcImxlZnQgdG9wXCI7XG5cdH1cblx0dGFyZ2V0V2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuXHR0YXJnZXRIZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcblx0dGFyZ2V0T2Zmc2V0ID0gZGltZW5zaW9ucy5vZmZzZXQ7XG5cblx0Ly8gQ2xvbmUgdG8gcmV1c2Ugb3JpZ2luYWwgdGFyZ2V0T2Zmc2V0IGxhdGVyXG5cdGJhc2VQb3NpdGlvbiA9ICQuZXh0ZW5kKCB7fSwgdGFyZ2V0T2Zmc2V0ICk7XG5cblx0Ly8gRm9yY2UgbXkgYW5kIGF0IHRvIGhhdmUgdmFsaWQgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgcG9zaXRpb25zXG5cdC8vIGlmIGEgdmFsdWUgaXMgbWlzc2luZyBvciBpbnZhbGlkLCBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBjZW50ZXJcblx0JC5lYWNoKCBbIFwibXlcIiwgXCJhdFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb3MgPSAoIG9wdGlvbnNbIHRoaXMgXSB8fCBcIlwiICkuc3BsaXQoIFwiIFwiICksXG5cdFx0XHRob3Jpem9udGFsT2Zmc2V0LFxuXHRcdFx0dmVydGljYWxPZmZzZXQ7XG5cblx0XHRpZiAoIHBvcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRwb3MgPSByaG9yaXpvbnRhbC50ZXN0KCBwb3NbIDAgXSApID9cblx0XHRcdFx0cG9zLmNvbmNhdCggWyBcImNlbnRlclwiIF0gKSA6XG5cdFx0XHRcdHJ2ZXJ0aWNhbC50ZXN0KCBwb3NbIDAgXSApID9cblx0XHRcdFx0XHRbIFwiY2VudGVyXCIgXS5jb25jYXQoIHBvcyApIDpcblx0XHRcdFx0XHRbIFwiY2VudGVyXCIsIFwiY2VudGVyXCIgXTtcblx0XHR9XG5cdFx0cG9zWyAwIF0gPSByaG9yaXpvbnRhbC50ZXN0KCBwb3NbIDAgXSApID8gcG9zWyAwIF0gOiBcImNlbnRlclwiO1xuXHRcdHBvc1sgMSBdID0gcnZlcnRpY2FsLnRlc3QoIHBvc1sgMSBdICkgPyBwb3NbIDEgXSA6IFwiY2VudGVyXCI7XG5cblx0XHQvLyBDYWxjdWxhdGUgb2Zmc2V0c1xuXHRcdGhvcml6b250YWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMoIHBvc1sgMCBdICk7XG5cdFx0dmVydGljYWxPZmZzZXQgPSByb2Zmc2V0LmV4ZWMoIHBvc1sgMSBdICk7XG5cdFx0b2Zmc2V0c1sgdGhpcyBdID0gW1xuXHRcdFx0aG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXRbIDAgXSA6IDAsXG5cdFx0XHR2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0WyAwIF0gOiAwXG5cdFx0XTtcblxuXHRcdC8vIFJlZHVjZSB0byBqdXN0IHRoZSBwb3NpdGlvbnMgd2l0aG91dCB0aGUgb2Zmc2V0c1xuXHRcdG9wdGlvbnNbIHRoaXMgXSA9IFtcblx0XHRcdHJwb3NpdGlvbi5leGVjKCBwb3NbIDAgXSApWyAwIF0sXG5cdFx0XHRycG9zaXRpb24uZXhlYyggcG9zWyAxIF0gKVsgMCBdXG5cdFx0XTtcblx0fSApO1xuXG5cdC8vIE5vcm1hbGl6ZSBjb2xsaXNpb24gb3B0aW9uXG5cdGlmICggY29sbGlzaW9uLmxlbmd0aCA9PT0gMSApIHtcblx0XHRjb2xsaXNpb25bIDEgXSA9IGNvbGxpc2lvblsgMCBdO1xuXHR9XG5cblx0aWYgKCBvcHRpb25zLmF0WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRiYXNlUG9zaXRpb24ubGVmdCArPSB0YXJnZXRXaWR0aDtcblx0fSBlbHNlIGlmICggb3B0aW9ucy5hdFsgMCBdID09PSBcImNlbnRlclwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IHRhcmdldFdpZHRoIC8gMjtcblx0fVxuXG5cdGlmICggb3B0aW9ucy5hdFsgMSBdID09PSBcImJvdHRvbVwiICkge1xuXHRcdGJhc2VQb3NpdGlvbi50b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuXHR9IGVsc2UgaWYgKCBvcHRpb25zLmF0WyAxIF0gPT09IFwiY2VudGVyXCIgKSB7XG5cdFx0YmFzZVBvc2l0aW9uLnRvcCArPSB0YXJnZXRIZWlnaHQgLyAyO1xuXHR9XG5cblx0YXRPZmZzZXQgPSBnZXRPZmZzZXRzKCBvZmZzZXRzLmF0LCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0ICk7XG5cdGJhc2VQb3NpdGlvbi5sZWZ0ICs9IGF0T2Zmc2V0WyAwIF07XG5cdGJhc2VQb3NpdGlvbi50b3AgKz0gYXRPZmZzZXRbIDEgXTtcblxuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29sbGlzaW9uUG9zaXRpb24sIHVzaW5nLFxuXHRcdFx0ZWxlbSA9ICQoIHRoaXMgKSxcblx0XHRcdGVsZW1XaWR0aCA9IGVsZW0ub3V0ZXJXaWR0aCgpLFxuXHRcdFx0ZWxlbUhlaWdodCA9IGVsZW0ub3V0ZXJIZWlnaHQoKSxcblx0XHRcdG1hcmdpbkxlZnQgPSBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5MZWZ0XCIgKSxcblx0XHRcdG1hcmdpblRvcCA9IHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpblRvcFwiICksXG5cdFx0XHRjb2xsaXNpb25XaWR0aCA9IGVsZW1XaWR0aCArIG1hcmdpbkxlZnQgKyBwYXJzZUNzcyggdGhpcywgXCJtYXJnaW5SaWdodFwiICkgK1xuXHRcdFx0XHRzY3JvbGxJbmZvLndpZHRoLFxuXHRcdFx0Y29sbGlzaW9uSGVpZ2h0ID0gZWxlbUhlaWdodCArIG1hcmdpblRvcCArIHBhcnNlQ3NzKCB0aGlzLCBcIm1hcmdpbkJvdHRvbVwiICkgK1xuXHRcdFx0XHRzY3JvbGxJbmZvLmhlaWdodCxcblx0XHRcdHBvc2l0aW9uID0gJC5leHRlbmQoIHt9LCBiYXNlUG9zaXRpb24gKSxcblx0XHRcdG15T2Zmc2V0ID0gZ2V0T2Zmc2V0cyggb2Zmc2V0cy5teSwgZWxlbS5vdXRlcldpZHRoKCksIGVsZW0ub3V0ZXJIZWlnaHQoKSApO1xuXG5cdFx0aWYgKCBvcHRpb25zLm15WyAwIF0gPT09IFwicmlnaHRcIiApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoO1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMubXlbIDAgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gZWxlbVdpZHRoIC8gMjtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMubXlbIDEgXSA9PT0gXCJib3R0b21cIiApIHtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0O1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMubXlbIDEgXSA9PT0gXCJjZW50ZXJcIiApIHtcblx0XHRcdHBvc2l0aW9uLnRvcCAtPSBlbGVtSGVpZ2h0IC8gMjtcblx0XHR9XG5cblx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0WyAwIF07XG5cdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0WyAxIF07XG5cblx0XHRjb2xsaXNpb25Qb3NpdGlvbiA9IHtcblx0XHRcdG1hcmdpbkxlZnQ6IG1hcmdpbkxlZnQsXG5cdFx0XHRtYXJnaW5Ub3A6IG1hcmdpblRvcFxuXHRcdH07XG5cblx0XHQkLmVhY2goIFsgXCJsZWZ0XCIsIFwidG9wXCIgXSwgZnVuY3Rpb24oIGksIGRpciApIHtcblx0XHRcdGlmICggJC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXSApIHtcblx0XHRcdFx0JC51aS5wb3NpdGlvblsgY29sbGlzaW9uWyBpIF0gXVsgZGlyIF0oIHBvc2l0aW9uLCB7XG5cdFx0XHRcdFx0dGFyZ2V0V2lkdGg6IHRhcmdldFdpZHRoLFxuXHRcdFx0XHRcdHRhcmdldEhlaWdodDogdGFyZ2V0SGVpZ2h0LFxuXHRcdFx0XHRcdGVsZW1XaWR0aDogZWxlbVdpZHRoLFxuXHRcdFx0XHRcdGVsZW1IZWlnaHQ6IGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0Y29sbGlzaW9uUG9zaXRpb246IGNvbGxpc2lvblBvc2l0aW9uLFxuXHRcdFx0XHRcdGNvbGxpc2lvbldpZHRoOiBjb2xsaXNpb25XaWR0aCxcblx0XHRcdFx0XHRjb2xsaXNpb25IZWlnaHQ6IGNvbGxpc2lvbkhlaWdodCxcblx0XHRcdFx0XHRvZmZzZXQ6IFsgYXRPZmZzZXRbIDAgXSArIG15T2Zmc2V0WyAwIF0sIGF0T2Zmc2V0IFsgMSBdICsgbXlPZmZzZXRbIDEgXSBdLFxuXHRcdFx0XHRcdG15OiBvcHRpb25zLm15LFxuXHRcdFx0XHRcdGF0OiBvcHRpb25zLmF0LFxuXHRcdFx0XHRcdHdpdGhpbjogd2l0aGluLFxuXHRcdFx0XHRcdGVsZW06IGVsZW1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGlmICggb3B0aW9ucy51c2luZyApIHtcblxuXHRcdFx0Ly8gQWRkcyBmZWVkYmFjayBhcyBzZWNvbmQgYXJndW1lbnQgdG8gdXNpbmcgY2FsbGJhY2ssIGlmIHByZXNlbnRcblx0XHRcdHVzaW5nID0gZnVuY3Rpb24oIHByb3BzICkge1xuXHRcdFx0XHR2YXIgbGVmdCA9IHRhcmdldE9mZnNldC5sZWZ0IC0gcG9zaXRpb24ubGVmdCxcblx0XHRcdFx0XHRyaWdodCA9IGxlZnQgKyB0YXJnZXRXaWR0aCAtIGVsZW1XaWR0aCxcblx0XHRcdFx0XHR0b3AgPSB0YXJnZXRPZmZzZXQudG9wIC0gcG9zaXRpb24udG9wLFxuXHRcdFx0XHRcdGJvdHRvbSA9IHRvcCArIHRhcmdldEhlaWdodCAtIGVsZW1IZWlnaHQsXG5cdFx0XHRcdFx0ZmVlZGJhY2sgPSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiB0YXJnZXRPZmZzZXQubGVmdCxcblx0XHRcdFx0XHRcdFx0dG9wOiB0YXJnZXRPZmZzZXQudG9wLFxuXHRcdFx0XHRcdFx0XHR3aWR0aDogdGFyZ2V0V2lkdGgsXG5cdFx0XHRcdFx0XHRcdGhlaWdodDogdGFyZ2V0SGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudDoge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtLFxuXHRcdFx0XHRcdFx0XHRsZWZ0OiBwb3NpdGlvbi5sZWZ0LFxuXHRcdFx0XHRcdFx0XHR0b3A6IHBvc2l0aW9uLnRvcCxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGVsZW1XaWR0aCxcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBlbGVtSGVpZ2h0XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0aG9yaXpvbnRhbDogcmlnaHQgPCAwID8gXCJsZWZ0XCIgOiBsZWZ0ID4gMCA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCIsXG5cdFx0XHRcdFx0XHR2ZXJ0aWNhbDogYm90dG9tIDwgMCA/IFwidG9wXCIgOiB0b3AgPiAwID8gXCJib3R0b21cIiA6IFwibWlkZGxlXCJcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIHRhcmdldFdpZHRoIDwgZWxlbVdpZHRoICYmIGFicyggbGVmdCArIHJpZ2h0ICkgPCB0YXJnZXRXaWR0aCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay5ob3Jpem9udGFsID0gXCJjZW50ZXJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRhcmdldEhlaWdodCA8IGVsZW1IZWlnaHQgJiYgYWJzKCB0b3AgKyBib3R0b20gKSA8IHRhcmdldEhlaWdodCApIHtcblx0XHRcdFx0XHRmZWVkYmFjay52ZXJ0aWNhbCA9IFwibWlkZGxlXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXgoIGFicyggbGVmdCApLCBhYnMoIHJpZ2h0ICkgKSA+IG1heCggYWJzKCB0b3AgKSwgYWJzKCBib3R0b20gKSApICkge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwiaG9yaXpvbnRhbFwiO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZlZWRiYWNrLmltcG9ydGFudCA9IFwidmVydGljYWxcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIHRoaXMsIHByb3BzLCBmZWVkYmFjayApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRlbGVtLm9mZnNldCggJC5leHRlbmQoIHBvc2l0aW9uLCB7IHVzaW5nOiB1c2luZyB9ICkgKTtcblx0fSApO1xufTtcblxuJC51aS5wb3NpdGlvbiA9IHtcblx0Zml0OiB7XG5cdFx0bGVmdDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0b3V0ZXJXaWR0aCA9IHdpdGhpbi53aWR0aCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gd2l0aGluT2Zmc2V0IC0gY29sbGlzaW9uUG9zTGVmdCxcblx0XHRcdFx0b3ZlclJpZ2h0ID0gY29sbGlzaW9uUG9zTGVmdCArIGRhdGEuY29sbGlzaW9uV2lkdGggLSBvdXRlcldpZHRoIC0gd2l0aGluT2Zmc2V0LFxuXHRcdFx0XHRuZXdPdmVyUmlnaHQ7XG5cblx0XHRcdC8vIEVsZW1lbnQgaXMgd2lkZXIgdGhhbiB3aXRoaW5cblx0XHRcdGlmICggZGF0YS5jb2xsaXNpb25XaWR0aCA+IG91dGVyV2lkdGggKSB7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgbGVmdCBzaWRlIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gMCAmJiBvdmVyUmlnaHQgPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyUmlnaHQgPSBwb3NpdGlvbi5sZWZ0ICsgb3ZlckxlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtXG5cdFx0XHRcdFx0XHR3aXRoaW5PZmZzZXQ7XG5cdFx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdCAtIG5ld092ZXJSaWdodDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIHJpZ2h0IHNpZGUgb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgJiYgb3ZlckxlZnQgPD0gMCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXG5cdFx0XHRcdC8vIEVsZW1lbnQgaXMgaW5pdGlhbGx5IG92ZXIgYm90aCBsZWZ0IGFuZCByaWdodCBzaWRlcyBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG92ZXJMZWZ0ID4gb3ZlclJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IHdpdGhpbk9mZnNldCArIG91dGVyV2lkdGggLSBkYXRhLmNvbGxpc2lvbldpZHRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ID0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb28gZmFyIGxlZnQgLT4gYWxpZ24gd2l0aCBsZWZ0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJMZWZ0ID4gMCApIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCArPSBvdmVyTGVmdDtcblxuXHRcdFx0Ly8gVG9vIGZhciByaWdodCAtPiBhbGlnbiB3aXRoIHJpZ2h0IGVkZ2Vcblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLmxlZnQgLT0gb3ZlclJpZ2h0O1xuXG5cdFx0XHQvLyBBZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24ubGVmdCA9IG1heCggcG9zaXRpb24ubGVmdCAtIGNvbGxpc2lvblBvc0xlZnQsIHBvc2l0aW9uLmxlZnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsVG9wIDogd2l0aGluLm9mZnNldC50b3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gZGF0YS53aXRoaW4uaGVpZ2h0LFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IHdpdGhpbk9mZnNldCAtIGNvbGxpc2lvblBvc1RvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSB3aXRoaW5PZmZzZXQsXG5cdFx0XHRcdG5ld092ZXJCb3R0b207XG5cblx0XHRcdC8vIEVsZW1lbnQgaXMgdGFsbGVyIHRoYW4gd2l0aGluXG5cdFx0XHRpZiAoIGRhdGEuY29sbGlzaW9uSGVpZ2h0ID4gb3V0ZXJIZWlnaHQgKSB7XG5cblx0XHRcdFx0Ly8gRWxlbWVudCBpcyBpbml0aWFsbHkgb3ZlciB0aGUgdG9wIG9mIHdpdGhpblxuXHRcdFx0XHRpZiAoIG92ZXJUb3AgPiAwICYmIG92ZXJCb3R0b20gPD0gMCApIHtcblx0XHRcdFx0XHRuZXdPdmVyQm90dG9tID0gcG9zaXRpb24udG9wICsgb3ZlclRvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLVxuXHRcdFx0XHRcdFx0d2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wIC0gbmV3T3ZlckJvdHRvbTtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdHRvbSBvZiB3aXRoaW5cblx0XHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgJiYgb3ZlclRvcCA8PSAwICkge1xuXHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblxuXHRcdFx0XHQvLyBFbGVtZW50IGlzIGluaXRpYWxseSBvdmVyIGJvdGggdG9wIGFuZCBib3R0b20gb2Ygd2l0aGluXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBvdmVyVG9wID4gb3ZlckJvdHRvbSApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldCArIG91dGVySGVpZ2h0IC0gZGF0YS5jb2xsaXNpb25IZWlnaHQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uLnRvcCA9IHdpdGhpbk9mZnNldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9vIGZhciB1cCAtPiBhbGlnbiB3aXRoIHRvcFxuXHRcdFx0fSBlbHNlIGlmICggb3ZlclRvcCA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCArPSBvdmVyVG9wO1xuXG5cdFx0XHQvLyBUb28gZmFyIGRvd24gLT4gYWxpZ24gd2l0aCBib3R0b20gZWRnZVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdHBvc2l0aW9uLnRvcCAtPSBvdmVyQm90dG9tO1xuXG5cdFx0XHQvLyBBZGp1c3QgYmFzZWQgb24gcG9zaXRpb24gYW5kIG1hcmdpblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9zaXRpb24udG9wID0gbWF4KCBwb3NpdGlvbi50b3AgLSBjb2xsaXNpb25Qb3NUb3AsIHBvc2l0aW9uLnRvcCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0ZmxpcDoge1xuXHRcdGxlZnQ6IGZ1bmN0aW9uKCBwb3NpdGlvbiwgZGF0YSApIHtcblx0XHRcdHZhciB3aXRoaW4gPSBkYXRhLndpdGhpbixcblx0XHRcdFx0d2l0aGluT2Zmc2V0ID0gd2l0aGluLm9mZnNldC5sZWZ0ICsgd2l0aGluLnNjcm9sbExlZnQsXG5cdFx0XHRcdG91dGVyV2lkdGggPSB3aXRoaW4ud2lkdGgsXG5cdFx0XHRcdG9mZnNldExlZnQgPSB3aXRoaW4uaXNXaW5kb3cgPyB3aXRoaW4uc2Nyb2xsTGVmdCA6IHdpdGhpbi5vZmZzZXQubGVmdCxcblx0XHRcdFx0Y29sbGlzaW9uUG9zTGVmdCA9IHBvc2l0aW9uLmxlZnQgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpbkxlZnQsXG5cdFx0XHRcdG92ZXJMZWZ0ID0gY29sbGlzaW9uUG9zTGVmdCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG92ZXJSaWdodCA9IGNvbGxpc2lvblBvc0xlZnQgKyBkYXRhLmNvbGxpc2lvbldpZHRoIC0gb3V0ZXJXaWR0aCAtIG9mZnNldExlZnQsXG5cdFx0XHRcdG15T2Zmc2V0ID0gZGF0YS5teVsgMCBdID09PSBcImxlZnRcIiA/XG5cdFx0XHRcdFx0LWRhdGEuZWxlbVdpZHRoIDpcblx0XHRcdFx0XHRkYXRhLm15WyAwIF0gPT09IFwicmlnaHRcIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1XaWR0aCA6XG5cdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRhdE9mZnNldCA9IGRhdGEuYXRbIDAgXSA9PT0gXCJsZWZ0XCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0V2lkdGggOlxuXHRcdFx0XHRcdGRhdGEuYXRbIDAgXSA9PT0gXCJyaWdodFwiID9cblx0XHRcdFx0XHRcdC1kYXRhLnRhcmdldFdpZHRoIDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDAgXSxcblx0XHRcdFx0bmV3T3ZlclJpZ2h0LFxuXHRcdFx0XHRuZXdPdmVyTGVmdDtcblxuXHRcdFx0aWYgKCBvdmVyTGVmdCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJSaWdodCA9IHBvc2l0aW9uLmxlZnQgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25XaWR0aCAtXG5cdFx0XHRcdFx0b3V0ZXJXaWR0aCAtIHdpdGhpbk9mZnNldDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyUmlnaHQgPCAwIHx8IG5ld092ZXJSaWdodCA8IGFicyggb3ZlckxlZnQgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIG92ZXJSaWdodCA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJMZWZ0ID0gcG9zaXRpb24ubGVmdCAtIGRhdGEuY29sbGlzaW9uUG9zaXRpb24ubWFyZ2luTGVmdCArIG15T2Zmc2V0ICtcblx0XHRcdFx0XHRhdE9mZnNldCArIG9mZnNldCAtIG9mZnNldExlZnQ7XG5cdFx0XHRcdGlmICggbmV3T3ZlckxlZnQgPiAwIHx8IGFicyggbmV3T3ZlckxlZnQgKSA8IG92ZXJSaWdodCApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi5sZWZ0ICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHRvcDogZnVuY3Rpb24oIHBvc2l0aW9uLCBkYXRhICkge1xuXHRcdFx0dmFyIHdpdGhpbiA9IGRhdGEud2l0aGluLFxuXHRcdFx0XHR3aXRoaW5PZmZzZXQgPSB3aXRoaW4ub2Zmc2V0LnRvcCArIHdpdGhpbi5zY3JvbGxUb3AsXG5cdFx0XHRcdG91dGVySGVpZ2h0ID0gd2l0aGluLmhlaWdodCxcblx0XHRcdFx0b2Zmc2V0VG9wID0gd2l0aGluLmlzV2luZG93ID8gd2l0aGluLnNjcm9sbFRvcCA6IHdpdGhpbi5vZmZzZXQudG9wLFxuXHRcdFx0XHRjb2xsaXNpb25Qb3NUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCxcblx0XHRcdFx0b3ZlclRvcCA9IGNvbGxpc2lvblBvc1RvcCAtIG9mZnNldFRvcCxcblx0XHRcdFx0b3ZlckJvdHRvbSA9IGNvbGxpc2lvblBvc1RvcCArIGRhdGEuY29sbGlzaW9uSGVpZ2h0IC0gb3V0ZXJIZWlnaHQgLSBvZmZzZXRUb3AsXG5cdFx0XHRcdHRvcCA9IGRhdGEubXlbIDEgXSA9PT0gXCJ0b3BcIixcblx0XHRcdFx0bXlPZmZzZXQgPSB0b3AgP1xuXHRcdFx0XHRcdC1kYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdGRhdGEubXlbIDEgXSA9PT0gXCJib3R0b21cIiA/XG5cdFx0XHRcdFx0XHRkYXRhLmVsZW1IZWlnaHQgOlxuXHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0YXRPZmZzZXQgPSBkYXRhLmF0WyAxIF0gPT09IFwidG9wXCIgP1xuXHRcdFx0XHRcdGRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRkYXRhLmF0WyAxIF0gPT09IFwiYm90dG9tXCIgP1xuXHRcdFx0XHRcdFx0LWRhdGEudGFyZ2V0SGVpZ2h0IDpcblx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdG9mZnNldCA9IC0yICogZGF0YS5vZmZzZXRbIDEgXSxcblx0XHRcdFx0bmV3T3ZlclRvcCxcblx0XHRcdFx0bmV3T3ZlckJvdHRvbTtcblx0XHRcdGlmICggb3ZlclRvcCA8IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJCb3R0b20gPSBwb3NpdGlvbi50b3AgKyBteU9mZnNldCArIGF0T2Zmc2V0ICsgb2Zmc2V0ICsgZGF0YS5jb2xsaXNpb25IZWlnaHQgLVxuXHRcdFx0XHRcdG91dGVySGVpZ2h0IC0gd2l0aGluT2Zmc2V0O1xuXHRcdFx0XHRpZiAoIG5ld092ZXJCb3R0b20gPCAwIHx8IG5ld092ZXJCb3R0b20gPCBhYnMoIG92ZXJUb3AgKSApIHtcblx0XHRcdFx0XHRwb3NpdGlvbi50b3AgKz0gbXlPZmZzZXQgKyBhdE9mZnNldCArIG9mZnNldDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggb3ZlckJvdHRvbSA+IDAgKSB7XG5cdFx0XHRcdG5ld092ZXJUb3AgPSBwb3NpdGlvbi50b3AgLSBkYXRhLmNvbGxpc2lvblBvc2l0aW9uLm1hcmdpblRvcCArIG15T2Zmc2V0ICsgYXRPZmZzZXQgK1xuXHRcdFx0XHRcdG9mZnNldCAtIG9mZnNldFRvcDtcblx0XHRcdFx0aWYgKCBuZXdPdmVyVG9wID4gMCB8fCBhYnMoIG5ld092ZXJUb3AgKSA8IG92ZXJCb3R0b20gKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24udG9wICs9IG15T2Zmc2V0ICsgYXRPZmZzZXQgKyBvZmZzZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGZsaXBmaXQ6IHtcblx0XHRsZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdCQudWkucG9zaXRpb24uZmxpcC5sZWZ0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdCQudWkucG9zaXRpb24uZml0LmxlZnQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH0sXG5cdFx0dG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdCQudWkucG9zaXRpb24uZmxpcC50b3AuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0JC51aS5wb3NpdGlvbi5maXQudG9wLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbn0gKSgpO1xuXG52YXIgcG9zaXRpb24gPSAkLnVpLnBvc2l0aW9uO1xuXG5cbi8qIVxuICogalF1ZXJ5IFVJIEtleWNvZGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IEtleWNvZGVcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBQcm92aWRlIGtleWNvZGVzIGFzIGtleW5hbWVzXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20valF1ZXJ5LnVpLmtleUNvZGUvXG5cblxudmFyIGtleWNvZGUgPSAkLnVpLmtleUNvZGUgPSB7XG5cdEJBQ0tTUEFDRTogOCxcblx0Q09NTUE6IDE4OCxcblx0REVMRVRFOiA0Nixcblx0RE9XTjogNDAsXG5cdEVORDogMzUsXG5cdEVOVEVSOiAxMyxcblx0RVNDQVBFOiAyNyxcblx0SE9NRTogMzYsXG5cdExFRlQ6IDM3LFxuXHRQQUdFX0RPV046IDM0LFxuXHRQQUdFX1VQOiAzMyxcblx0UEVSSU9EOiAxOTAsXG5cdFJJR0hUOiAzOSxcblx0U1BBQ0U6IDMyLFxuXHRUQUI6IDksXG5cdFVQOiAzOFxufTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBTY3JvbGwgUGFyZW50IDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBzY3JvbGxQYXJlbnRcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBHZXQgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgZWxlbWVudCB0aGF0IGlzIHNjcm9sbGFibGUuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vc2Nyb2xsUGFyZW50L1xuXG5cblxudmFyIHNjcm9sbFBhcmVudCA9ICQuZm4uc2Nyb2xsUGFyZW50ID0gZnVuY3Rpb24oIGluY2x1ZGVIaWRkZW4gKSB7XG5cdHZhciBwb3NpdGlvbiA9IHRoaXMuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRleGNsdWRlU3RhdGljUGFyZW50ID0gcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblx0XHRvdmVyZmxvd1JlZ2V4ID0gaW5jbHVkZUhpZGRlbiA/IC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8gOiAvKGF1dG98c2Nyb2xsKS8sXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGV4Y2x1ZGVTdGF0aWNQYXJlbnQgJiYgcGFyZW50LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3QoIHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiApICsgcGFyZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSArXG5cdFx0XHRcdHBhcmVudC5jc3MoIFwib3ZlcmZsb3cteFwiICkgKTtcblx0XHR9ICkuZXEoIDAgKTtcblxuXHRyZXR1cm4gcG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/XG5cdFx0JCggdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSA6XG5cdFx0c2Nyb2xsUGFyZW50O1xufTtcblxuXG4vKiFcbiAqIGpRdWVyeSBVSSBVbmlxdWUgSUQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IHVuaXF1ZUlkXG4vLz4+Z3JvdXA6IENvcmVcbi8vPj5kZXNjcmlwdGlvbjogRnVuY3Rpb25zIHRvIGdlbmVyYXRlIGFuZCByZW1vdmUgdW5pcXVlSWQnc1xuLy8+PmRvY3M6IGh0dHA6Ly9hcGkuanF1ZXJ5dWkuY29tL3VuaXF1ZUlkL1xuXG5cblxudmFyIHVuaXF1ZUlkID0gJC5mbi5leHRlbmQoIHtcblx0dW5pcXVlSWQ6ICggZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHV1aWQgPSAwO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5pZCA9IFwidWktaWQtXCIgKyAoICsrdXVpZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0fSApKCksXG5cblx0cmVtb3ZlVW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAvXnVpLWlkLVxcZCskLy50ZXN0KCB0aGlzLmlkICkgKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5yZW1vdmVBdHRyKCBcImlkXCIgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG59KSk7XG4iLCJ2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi91aS5mYW5jeXRyZWUubWluLmNzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJiMjBkODQwOTY4NDBlZjJlMjA0MDQwMWM3ZTc3OTNhZi5naWZcIjsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI2MWU4ODFjYjRjZDFhNDdjMGI4YzExMmQ5ODA2ZDk5ZS5naWZcIjsiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCJpbXBvcnQgdHJlZVJlbmRlcmVyICBmcm9tICcuL2ZhbmN5dHJlZS1yZW5kZXJlcidcbmltcG9ydCBwbGFjZXMgZnJvbScuL2FqYXhNYXAtcGxhY2VzJ1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuXG5jb25zdCBtYXBMb2NhdGlvblR5cGVzID0ge1xuICAgIHRyZWVTZWxlY3RvcjogJyNhamF4TWFwTG9jYXRpb25UeXBlc1RyZWUnLFxuICAgIHVpOiBmdW5jdGlvbihtYXBFbnRyeSkge1xuICAgICAgICBjb25zdCBjdXJyTG9jYXRpb25UeXBlcyA9IG1hcEVudHJ5LmxvY2F0aW9uVHlwZXMsXG4gICAgICAgICAgICBtYXBJZCA9IG1hcEVudHJ5LmlkO1xuXG4gICAgICAgIC8vcmVtb3ZlIGVtcHR5IG9wdGlvbiAoc2luY2UgZmx1aWQgZG9lc24ndCBidWlsZCBhIHNlbGVjdCB3aXRob3V0IG9wdGlvbilcbiAgICAgICAgZm9yICh2YXIgdHlwZSBpbiBjdXJyTG9jYXRpb25UeXBlcykge1xuXG4gICAgICAgICAgICAkKCc8b3B0aW9uLz4nKS52YWwoY3VyckxvY2F0aW9uVHlwZXNbdHlwZV0ua2V5KVxuICAgICAgICAgICAgLnRleHQoY3VyckxvY2F0aW9uVHlwZXNbdHlwZV0udGl0bGUpXG4gICAgICAgICAgICAuYXBwZW5kVG8oJChtYXBMb2NhdGlvblR5cGVzLnRyZWVTZWxlY3RvciArIG1hcElkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgb24gY2hhbmdlIGZ1bmN0aW9uIGZvciBsb2NhdGlvbiB0eXBlcyB0cmVlU2VsZWN0b3JcbiAgICAgICAgJChtYXBMb2NhdGlvblR5cGVzLnRyZWVTZWxlY3RvciArIG1hcElkKS5jaGFuZ2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwbGFjZXMudXBkYXRlUGxhY2VzKG1hcElkKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbihtYXBFbnRyeSwgbG9jYXRpb25UeXBlcykge1xuXG4gICAgICAgIGlmIChsb2NhdGlvblR5cGVzKSB7XG4gICAgICAgICAgICBtYXBFbnRyeS5sb2NhdGlvblR5cGVzID0gbG9jYXRpb25UeXBlcztcblxuICAgICAgICAgICAgbWFwTG9jYXRpb25UeXBlcy51aShtYXBFbnRyeSk7XG4gICAgICAgICAgICB0cmVlUmVuZGVyZXIubG9jYXRpb25UeXBlcyhtYXBFbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1hcExvY2F0aW9uVHlwZXM7XG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuXG5pbXBvcnQgYWpheE1hcCBmcm9tICcuL2FqYXhNYXAnXG5cbmltcG9ydCBtYXBIZWxwZXJzIGZyb20gJy4vbWFwLWhlbHBlcnMnXG5cbmNvbnN0IF9tYXAgPSB7XG5cbiAgICBnZXRNYXBEYXRhOiAobWFwRW50cnkpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICdpZCc6IGFqYXhNYXAuY29uZmlnRGF0YS5tYXBTZXR0aW5ncy5wYWdlSWQsXG4gICAgICAgICAgICAnYXBpJzogXCJtYXBcIixcbiAgICAgICAgICAgICdhY3Rpb24nOiAnYnVpbGRNYXAnLFxuICAgICAgICAgICAgJ21hcElkJzogbWFwRW50cnkuaWRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgdXJsOiBhamF4TWFwLmFqYXhTZXJ2ZXJQYXRoLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVqZWN0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICBidWlsZChtYXBFbnRyeSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgc2V0dGluZ3MgPSBtYXBFbnRyeS5zZXR0aW5ncztcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfbWFwLmdldE1hcERhdGEobWFwRW50cnkpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0ICRlbCA9ICQoJyNhamF4TWFwQ29udGFpbmVyX01hcCcgKyBtYXBFbnRyeS5pZCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBnb29nbGVNYXAgPSBtYXBIZWxwZXJzLmNyZWF0ZUdvb2dsTWFwKHJlc3BvbnNlLCAkZWwpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5mb1dpbmRvdyA9IG1hcEhlbHBlcnMuZ2V0SW5mb1dpbmRvdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlckNsdXN0ZXJlciA9IG1hcEhlbHBlcnMuZ2V0TWFya2VyQ2x1c3RlcmVyKGdvb2dsZU1hcCwgbWFwRW50cnkubWFya2VyQ2x1c3RlcmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpb25zID0gcmVzcG9uc2UucmVnaW9ucyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0aWNMYXllcnMgPSByZXNwb25zZS5zdGF0aWNMYXllcnMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gc2V0dGluZ3MuZ29vZ2xlQXBpS2V5O1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihtYXBFbnRyeSwge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGVNYXAsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0xheWVycyxcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyQ2x1c3RlcmVyLFxuICAgICAgICAgICAgICAgICAgICBpbmZvV2luZG93LFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpXG5cbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgcGFuVG86IChtYXBJZCkgPT4ge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgLy8pIGNvbnNvbGUubG9nKG1hcENlbnRlciwgJyoqKioqKioqKioqKioqKioqJykvL2h0dHA6Ly9qc2ZpZGRsZS5uZXQvZnF0N0wvMS9cbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge2J1aWxkOiBfbWFwLmJ1aWxkfTtcbiIsImZ1bmN0aW9uIG9wZW5EZXRhaWxWaWV3KGNhbGxlciwgcGxhY2VJZCkge1xuXG4gICAgc3dpdGNoIChjYWxsZXIpIHtcbiAgICAgICAgY2FzZSBcImluZm9XaW5kb3dcIjpcbiAgICAgICAgICAgIHBsYWNlSWQgPSAkKCcjZGV0YWlsVmlldycpLmRhdGEoJ3BsYWNlSWQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGlzdFZpZXdcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlSWQpIHsvLz9AZGlya1xuICAgICAgICB2YXIgcGF0aCA9ICQobG9jYXRpb24pLmF0dHIoJ2hyZWYnKTtcblxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKCc/JykgPiAtMSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnJnR5cGU9MTQ0MTkxNjk3Nic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aCArICc/dHlwZT0xNDQxOTE2OTc2JztcbiAgICAgICAgfVxuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgICAgICBjb250ZXh0OiAkKCcjZGV0YWlsVmlldyAuaW5uZXInKSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICB0eF9hamF4bWFwX21hcDoge1xuICAgICAgICAgICAgICAgICAgICAnY29udHJvbGxlcic6IFwiUGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgJ2FjdGlvbic6ICdhamF4U2hvdycsXG4gICAgICAgICAgICAgICAgICAgICdwbGFjZUlkJzogcGxhY2VJZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLmRvbmUoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5odG1sKGRhdGEpO1xuICAgICAgICAgICAgJCgnI2RldGFpbFZpZXcnKS5mYWRlSW4oJzQwMCcpO1xuICAgICAgICAgICAgJCgnI292ZXJsYXlEZXRhaWxIZWxwZXInKS5oZWlnaHQoJChkb2N1bWVudCkuaGVpZ2h0KCkpLmZhZGVJbignNDAwJyk7XG4gICAgICAgICAgICAkKCcjb3ZlcmxheS1jbG9zZScpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQoJyNkZXRhaWxWaWV3JykuZmFkZU91dCgnNTAwJyk7XG4gICAgICAgICAgICAgICAgJCgnI292ZXJsYXlEZXRhaWxIZWxwZXInKS5mYWRlT3V0KCc1MDAnKTtcbiAgICAgICAgICAgICAgICAkKCcjZGV0YWlsVmlldyAuaW5uZXInKS5jb250ZW50cygpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgb3BlbkRldGFpbFZpZXc7XG4iLCJpbXBvcnQge3VwZGF0ZVRyZWV9ICBmcm9tICcuL2ZhbmN5dHJlZS1yZW5kZXJlcidcbmltcG9ydCBsYXllcnMgZnJvbSAnLi9tYXAtbGF5ZXJzJ1xuaW1wb3J0IG1hcmtlcnMgZnJvbSAnLi9tYXAtbWFya2VyJ1xuaW1wb3J0IHtnZXRTZWxlY3RlZEtleXN9IGZyb20gJy4vbWFwLWhlbHBlcnMnXG5pbXBvcnQge2ZhbmN5dHJlZVNlbGVjdG9yfSBmcm9tICcuL2ZhbmN5dHJlZS1yZW5kZXJlcidcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG4vKipcbiAqIFVwZGF0ZXMgYWxsIGZpbHRlciAodHJlZXMpXG4gKiBEZXRlcm1pbmVzIGZvciBhbGwgbm9kZXMgaW4gYWxsIGZpbHRlciB0cmVlcyB3aGV0aGVyXG4gKiB0aGV5IHNob3VsZCBiZSBzaG93bi5cbiAqIEEgbm9kZSBpbiBhIGZpbHRlciB0cmVlIHNob3VsZCBiZSB2aXNpYmxlIGlmIGF0IGxlYXN0XG4gKiBvbmUgbm9kZSBpbiB0aGUgcmVzdWx0IHRyZWUgKHBsYWNlc1RyZWUpIGhhcyB0aGVcbiAqIGFjY29yZGluZyBvcHRpb24gKGZvciBpbnN0YW5jZSBpZiBpdCBiZWxvbmdzIHRvIGEgcmVnaW9uKVxuICpcbiAqIEBwYXJhbSBwbGFjZXNUcmVlIFRoZSBwbGFjZXMgdHJlZVxuICogQHJldHVybiB2b2lkXG4gKlxuICogZm9ybWFscyA6dXBkYXRlRmlsdGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgkcm9vdE5vZGUsIG1hcEVudHJ5KSB7XG4gICAgY29uc3QgZmlsdGVycyA9IG1hcEVudHJ5LnNldHRpbmdzLnBsYWNlc1RyZWUudXBkYXRlRmlsdGVycztcblxuICAgICQuZWFjaChmaWx0ZXJzLCBmdW5jdGlvbihmaWx0ZXJOYW1lLCBmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgdHJlZVNlbGVjdG9yID0gJyMnICsgZmlsdGVyLnRyZWVOYW1lICsgbWFwRW50cnkuaWQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyZWUgPSAkKHRyZWVTZWxlY3RvcikuZmFuY3l0cmVlKCdnZXRUcmVlJyk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9ICRyb290Tm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgY29uc3QgcGxhY2VLZXlzID0gZ2V0S2V5c0J5QXR0cmlidXRlKGNoaWxkcmVuLCBmaWx0ZXJOYW1lKTtcblxuICAgICAgICAgICAgZmlsdGVyVHJlZSh0cmVlLCBwbGFjZUtleXMpO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyTmFtZSA9PT0gJ3JlZ2lvbnMnICYmIGZpbHRlci51cGRhdGVMYXllcnMpIHtcblxuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSBnZXRTZWxlY3RlZEtleXModHJlZVNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICBsYXllcnMudXBkYXRlKG1hcEVudHJ5LCBzZWxlY3RlZEtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vdG9kbyBmaWx0ZXIgbm90IGluaXRhbGlzZWQgZWcgbG9jYXRpb24gdHlwZDo4OD8/QGRpcmstLWV2ZXJ5dGltZSBsb2NhdGlvblR5cGVzXG4gICAgICAgICAgICBjb25zb2xlLmxvZygndHJlZVNlbGVjdG9yLS0tLT4nLCB0cmVlU2VsZWN0b3IpXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIGFsbCBjaGlsZHJlbiBmb3IgYW4gYXR0cmlidXRlIGluIHRoZWlyIGRhdGEgcHJvcGVydHlcbiAqIGFuZCByZXR1cm5zIGEgdW5pcXVlIGFycmF5IG9mIGtleXMgZm9yIHRoaXMgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIGNoaWxkcmVuXG4gKiBAcGFyYW0gbmFtZVxuICogQHJldHVybiBBcnJheVxuICovXG5mdW5jdGlvbiBnZXRLZXlzQnlBdHRyaWJ1dGUoY2hpbGRyZW4sIG5hbWUpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgICQuZWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oaW5kZXgsIGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5kYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gY2hpbGQuZGF0YVtuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5oYXNPd25Qcm9wZXJ0eSgna2V5JykgJiYgIWtleXNbYXR0cmlidXRlLmtleV0pIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goYXR0cmlidXRlLmtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgayA9IGF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVbaV0uaGFzT3duUHJvcGVydHkoJ2tleScpICYmIGtleXMuaW5kZXhPZihhdHRyaWJ1dGVbaV0ua2V5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goYXR0cmlidXRlW2ldLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBrZXlzO1xufVxuXG4vKipcbiAqIEZpbHRlcnMgYSB0cmVlIGJ5IGEgdW5pcXVlIGFycmF5IG9mIGtleXNcbiAqIEEgbm9kZSB3aWxsIGJlIHZpc2libGUgaWYgaXRzIGtleSBpcyBpbiB0aGUgdGhpcyBhcnJheVxuICpcbiAqIEBwYXJhbSB0cmVlIEZhbmN5IHRyZWVcbiAqIEBwYXJhbSBrZXlzIFVuaXF1ZSBhcnJheSBvZiBrZXlzXG4gKi9cbmZ1bmN0aW9uIGZpbHRlclRyZWUodHJlZSwga2V5cykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7YXV0b0V4cGFuZDogdHJ1ZX07XG5cbiAgICB0cmVlLmZpbHRlck5vZGVzKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIChrZXlzLmluZGV4T2YocGFyc2VJbnQobm9kZS5rZXkpKSAhPSAtMSk7XG4gICAgfSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogU2hvd3MgcGxhY2VzIHdoaWNoIG1hdGNoIGFsbCBjb25zdHJhaW50c1xuICogZGVmaW5lZCBieSByZWdpb24sIHBsYWNlIGdyb3VwLCBsb2NhdGlvbiB0eXBlIG9yIGNhdGVnb3J5IHNlbGVjdG9yXG4gKlxuICogQHBhcmFtIG1hcEVudHJ5XG4gKi9cbmZ1bmN0aW9uIHNob3dNYXRjaGluZ1BsYWNlcyhtYXBFbnRyeSkge1xuXG4gICAgdmFyIG1hcCA9IG1hcEVudHJ5Lmdvb2dsZU1hcCxcbiAgICAgICAgbWFwSWQgPSBtYXBFbnRyeS5pZCxcbiAgICAgICAgbWFwUGxhY2VzID0gbWFwRW50cnkucGxhY2VzLFxuXG4gICAgICAgIHNlbGVjdGVkUGxhY2VzID0gW10sXG4gICAgICAgIGNsdXN0ZXJlciA9IG1hcEVudHJ5Lm1hcmtlckNsdXN0ZXJlcixcbiAgICAgICAgbWFwTWFya2VycyA9IG1hcEVudHJ5Lm1hcmtlcnMgfHwgW10sXG5cbiAgICAgICAgc2VsZWN0ZWRMb2NhdGlvblR5cGVLZXlzID0gZ2V0U2VsZWN0ZWRLZXlzKGZhbmN5dHJlZVNlbGVjdG9yLmxvY2F0aW9uVHlwZSArIG1hcElkKSxcbiAgICAgICAgc2VsZWN0ZWRDYXRlZ29yeUtleXMgPSBnZXRTZWxlY3RlZEtleXMoZmFuY3l0cmVlU2VsZWN0b3IuY2F0ZWdvcnkgKyBtYXBJZCksXG4gICAgICAgIHNlbGVjdGVkUmVnaW9uS2V5cyA9IGdldFNlbGVjdGVkS2V5cyhmYW5jeXRyZWVTZWxlY3Rvci5yZWdpb25zICsgbWFwSWQpLFxuICAgICAgICBzZWxlY3RlZFBsYWNlR3JvdXBLZXlzID0gZ2V0U2VsZWN0ZWRLZXlzKGZhbmN5dHJlZVNlbGVjdG9yLnBsYWNlR3JvdXAgKyBtYXBJZCksXG5cbiAgICAgICAgc2VsZWN0ZWRMb2NhdGlvblR5cGUgPSAwO1xuXG4gICAgLy8gZ2V0IHNlbGVjdGVkIGxvY2F0aW9uIHR5cGUuIFRoaXMgc2hvdWxkIGJlIG9uZSBvciBub25lXG4gICAgaWYgKHNlbGVjdGVkTG9jYXRpb25UeXBlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgc2VsZWN0ZWRMb2NhdGlvblR5cGUgPSBzZWxlY3RlZExvY2F0aW9uVHlwZUtleXNbMF07XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ21hcmtlckNsdXN0ZXJlcicsIGNsdXN0ZXJlciwgbWFwRW50cnkpXG4gICAgY2x1c3RlcmVyLnJlbW92ZU1hcmtlcnMobWFwTWFya2Vycyk7XG5cbiAgICAvLyBhZGQgbWFya2VycyBmb3IgYWxsIHBsYWNlc1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbWFwUGxhY2VzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICB2YXIgcGxhY2UgPSBtYXBQbGFjZXNbaV0sXG4gICAgICAgICAgICBtYXJrZXIgPSBtYXBNYXJrZXJzW2ldO1xuXG4gICAgICAgIGlmICghbWFwTWFya2Vyc1tpXSkge1xuICAgICAgICAgICAgLy8gbWFya2VyIGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgaXRcbiAgICAgICAgICAgIG1hcE1hcmtlcnNbaV0gPSBtYXJrZXJzLmNyZWF0ZShtYXBFbnRyeSwgcGxhY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhhc0FuQWN0aXZlQ2F0ZWdvcnkgPSAwLFxuICAgICAgICAgICAgICAgIGhhc0FuQWN0aXZlUmVnaW9uID0gMCxcbiAgICAgICAgICAgICAgICBoYXNBbkFjdGl2ZVBsYWNlR3JvdXAgPSAwO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRDYXRlZ29yeUtleXMgJiYgbWFya2VyLnBsYWNlLmNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgICAgICAkLmVhY2gobWFya2VyLnBsYWNlLmNhdGVnb3JpZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBoYXNBbkFjdGl2ZUNhdGVnb3J5ID0gKCQuaW5BcnJheShwYXJzZUludCh0aGlzLmtleSksIHNlbGVjdGVkQ2F0ZWdvcnlLZXlzKSA+IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghaGFzQW5BY3RpdmVDYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFJlZ2lvbktleXMubGVuZ3RoICYmIG1hcmtlci5wbGFjZS5yZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKG1hcmtlci5wbGFjZS5yZWdpb25zLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQW5BY3RpdmVSZWdpb24gPSAoJC5pbkFycmF5KHBhcnNlSW50KHRoaXMua2V5KSwgc2VsZWN0ZWRSZWdpb25LZXlzKSA+IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghaGFzQW5BY3RpdmVSZWdpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRQbGFjZUdyb3VwS2V5cy5sZW5ndGggJiYgbWFya2VyLnBsYWNlLnBsYWNlR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKG1hcmtlci5wbGFjZS5wbGFjZUdyb3VwcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0FuQWN0aXZlUGxhY2VHcm91cCA9ICgkLmluQXJyYXkocGFyc2VJbnQodGhpcy5rZXkpLCBzZWxlY3RlZFBsYWNlR3JvdXBLZXlzKSA+IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICghaGFzQW5BY3RpdmVQbGFjZUdyb3VwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8tLS0tXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHBsYWNlLmxvY2F0aW9uVHlwZS5rZXkgPT0gc2VsZWN0ZWRMb2NhdGlvblR5cGUgfHwgIXNlbGVjdGVkTG9jYXRpb25UeXBlS2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgJiYgKGhhc0FuQWN0aXZlQ2F0ZWdvcnkgfHwgIXNlbGVjdGVkQ2F0ZWdvcnlLZXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAmJiAoaGFzQW5BY3RpdmVSZWdpb24gfHwgIXNlbGVjdGVkUmVnaW9uS2V5cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgJiYgKGhhc0FuQWN0aXZlUGxhY2VHcm91cCB8fCAhc2VsZWN0ZWRQbGFjZUdyb3VwS2V5cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcChtYXApO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUGxhY2VzW3NlbGVjdGVkUGxhY2VzLmxlbmd0aF0gPSBwbGFjZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vICAgY2x1c3RlcmVyLmFkZE1hcmtlcnMobWFwTWFya2Vycyk7XG5cbiAgICAvLyB1cGRhdGUgb25seSBpZiBtYXBFbnRyeSBpcyBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgaWYgKHR5cGVvZiBtYXBFbnRyeS5tYXJrZXJzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmxvZygnISEnLCBzZWxlY3RlZFBsYWNlcylcbiAgICAgICAgdXBkYXRlVHJlZS5wbGFjZXMobWFwRW50cnksIHNlbGVjdGVkUGxhY2VzKTtcbiAgICB9XG4gICAgbWFwRW50cnkubWFya2VycyA9IG1hcE1hcmtlcnM7XG59XG5cbi8qKlxuICogU2hvd3MgcGxhY2VzIGZyb20gYSBsaXN0IG9mIHNlbGVjdGVkIHBsYWNlc1xuICpcbiAqIEBwYXJhbSBtYXBFbnRyeVxuICogQHBhcmFtIHNlbGVjdGVkUGxhY2VLZXlzXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gc2hvd1NlbGVjdGVkUGxhY2VzKG1hcEVudHJ5LCBzZWxlY3RlZFBsYWNlS2V5cykge1xuICAgIHZhciBtYXAgPSBtYXBFbnRyeS5nb29nbGVNYXAsXG4gICAgICAgIG1hcFBsYWNlcyA9IG1hcEVudHJ5LnBsYWNlcyxcbiAgICAgICAgY2x1c3RlcmVyID0gbWFwRW50cnkubWFya2VyQ2x1c3RlcmVyLFxuICAgICAgICBtYXBNYXJrZXJzID0gbWFwRW50cnkubWFya2VycyB8fCBbXTtcblxuICAgIG1hcFBsYWNlcy5mb3JFYWNoKChwbGFjZSwgaSkgPT4ge1xuICAgICAgICBtYXBNYXJrZXJzW2ldID0gbWFwTWFya2Vyc1tpXSA/XG4gICAgICAgICAgICBtYXBNYXJrZXJzW2ldIDogbWFya2Vycy5jcmVhdGUobWFwRW50cnksIHBsYWNlKTtcblxuICAgICAgICBtYXBNYXJrZXJzW2ldLnNldE1hcChudWxsKTtcbiAgICAgICAgY2x1c3RlcmVyLnJlbW92ZU1hcmtlcihtYXBNYXJrZXJzW2ldKTtcbiAgICB9KTtcblxuICAgIGNsdXN0ZXJlci5hZGRNYXJrZXJzKG1hcE1hcmtlcnMpO1xuXG4gICAgbWFwTWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2VsZWN0ZWRQbGFjZSA9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRQbGFjZUtleXMuc29tZShrZXkgPT4gbWFya2VyLnBsYWNlLmtleSA9PT0ga2V5KTtcblxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWRQbGFjZSkge1xuICAgICAgICAgICAgICAgIG1hcmtlci5zZXRNYXAobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59XG5jb25zdCBmaWx0ZXJQbGFjZXMgPSB7XG4gICAgdXBkYXRlLFxuICAgIHNob3dNYXRjaGluZ1BsYWNlcyxcbiAgICBzaG93U2VsZWN0ZWRQbGFjZXNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZpbHRlclBsYWNlcztcbiIsImltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5cbmltcG9ydCAnanF1ZXJ5LmZhbmN5dHJlZS9kaXN0L21vZHVsZXMvanF1ZXJ5LmZhbmN5dHJlZS5lZGl0JztcbmltcG9ydCAnanF1ZXJ5LmZhbmN5dHJlZS9kaXN0L21vZHVsZXMvanF1ZXJ5LmZhbmN5dHJlZS5nbHlwaCc7XG5pbXBvcnQgJ2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUuZmlsdGVyJztcblxuXG5pbXBvcnQgYWpheE1hcCBmcm9tICcuL2FqYXhNYXAnXG5pbXBvcnQgcGxhY2VzRmlsdGVyIGZyb20gJy4vYWpheE1hcC1wbGFjZXMtZmlsdGVyJ1xuaW1wb3J0IHRyZWVSZW5kZXJlciAgZnJvbSAnLi9mYW5jeXRyZWUtcmVuZGVyZXInXG5pbXBvcnQgbWFya2VySW5mb1dpbmRvdyBmcm9tICcuL21hcC1tYXJrZXItaW5mby13aW5kb3cnXG5pbXBvcnQge2dldFNlbGVjdGVkS2V5c30gZnJvbSAnLi9tYXAtaGVscGVycydcbmltcG9ydCB7ZmFuY3l0cmVlU2VsZWN0b3J9IGZyb20gJy4vZmFuY3l0cmVlLXJlbmRlcmVyJ1xuXG5jb25zdCBfID0ge1xuICAgIHVwZGF0ZVBsYWNlczogKG1hcEVudHJ5LCBjbGVhclNlbGVjdGVkKSA9PiB7XG4gICAgICAgIHZhciB0cmVlU2VsZWN0b3IgPSBmYW5jeXRyZWVTZWxlY3Rvci5wbGFjZXMgKyBtYXBFbnRyeS5pZDtcblxuICAgICAgICBpZiAoY2xlYXJTZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHRyZWUgPSAkKHRyZWVTZWxlY3RvcikuZmFuY3l0cmVlKCdnZXRUcmVlJyk7XG5cbiAgICAgICAgICAgIHRyZWUuY2xlYXJGaWx0ZXIoKTtcbiAgICAgICAgICAgIHRyZWUudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0ZWRQbGFjZUtleXMgPSBnZXRTZWxlY3RlZEtleXModHJlZVNlbGVjdG9yKTtcblxuXG4gICAgICAgIGlmIChzZWxlY3RlZFBsYWNlS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBsYWNlc0ZpbHRlci5zaG93U2VsZWN0ZWRQbGFjZXMobWFwRW50cnksIHNlbGVjdGVkUGxhY2VLZXlzKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBwbGFjZXNGaWx0ZXIuc2hvd01hdGNoaW5nUGxhY2VzKG1hcEVudHJ5KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2hvd1NvbG9QbGFjZTogKG1hcEVudHJ5KT0+e1xuICAgICAgICByZXR1cm4gKGV2ZW50LCBkYXRhKSA9PiB7XG4gICAgICAgICAgICB2YXIgbWFwTWFya2VycyA9IG1hcEVudHJ5Lm1hcmtlcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdyA9IG1hcEVudHJ5LmluZm9XaW5kb3c7XG5cblxuICAgICAgICAgICAgaWYgKCFkYXRhLm5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBkYXRhLm5vZGUuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cblxuXG5cbiAgICAgICAgICAgICAgICBpZiAobWFwRW50cnkuc2V0dGluZ3MucGxhY2VzVHJlZS50b2dnbGVJbmZvV2luZG93T25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBtYXBNYXJrZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gbWFwTWFya2Vyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtlci5wbGFjZS5rZXkgPT09IGRhdGEubm9kZS5rZXkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluZm9XaW5kb3cuZ2V0SW5mb1dpbmRvd0NvbnRlbnQobWFya2VyLnBsYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChjb250ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcEVudHJ5Lm1hcCwgbWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGRhdGEubm9kZS5zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICAgICAgaW5mb1dpbmRvdy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhLm5vZGUuc2V0QWN0aXZlKGZhbHNlKTtcblxuICAgICAgICAgICAgXy51cGRhdGVQbGFjZXMobWFwRW50cnkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXRFdmVudHM6IChwbGFjZXNUcmVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc2V0RmlsdGVyQnV0dG9uU2VsZWN0b3IgPSBcImJ1dHRvbiNidG5SZXNldFBsYWNlc0ZpbHRlclwiO1xuXG4gICAgICAgICQocmVzZXRGaWx0ZXJCdXR0b25TZWxlY3RvcikuY2xpY2soZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgJChcImlucHV0W25hbWU9ZmlsdGVyUGxhY2VzXVwiKS52YWwoJycpO1xuICAgICAgICAgICAgJChcInNwYW4jbWF0Y2hlc1wiKS50ZXh0KFwiXCIpO1xuICAgICAgICAgICAgcGxhY2VzVHJlZS5jbGVhckZpbHRlcigpO1xuICAgICAgICB9KS5hdHRyKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG5cbiAgICAgICAgJChcImlucHV0W25hbWU9ZmlsdGVyUGxhY2VzXVwiKS5rZXl1cChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbixcbiAgICAgICAgICAgICAgICBvcHRzID0ge30sXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSAkKHRoaXMpLnZhbCgpO1xuXG4gICAgICAgICAgICBpZiAoZSAmJiBlLndoaWNoID09PSAkLnVpLmtleUNvZGUuRVNDQVBFIHx8ICQudHJpbShtYXRjaCkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAkKHJlc2V0RmlsdGVyQnV0dG9uU2VsZWN0b3IpLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFzcyBhIHN0cmluZyB0byBwZXJmb3JtIGNhc2UgaW5zZW5zaXRpdmUgbWF0Y2hpbmdcbiAgICAgICAgICAgIG4gPSBwbGFjZXNUcmVlLmZpbHRlck5vZGVzKG1hdGNoLCBvcHRzKTtcbiAgICAgICAgICAgICQocmVzZXRGaWx0ZXJCdXR0b25TZWxlY3RvcikuYXR0cihcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICQoXCJzcGFuI21hdGNoZXNcIikudGV4dChuKTtcbiAgICAgICAgfSkuZm9jdXMoKTtcbiAgICB9LFxuICAgIGluaXQ6IChtYXBFbnRyeSkgPT4ge1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdXJsOiBhamF4TWFwLmFqYXhTZXJ2ZXJQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogYWpheE1hcC5jb25maWdEYXRhLm1hcFNldHRpbmdzLnBhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgJ2FwaSc6ICdtYXAnLFxuICAgICAgICAgICAgICAgICAgICAnYWN0aW9uJzogJ2xpc3RQbGFjZXMnLFxuICAgICAgICAgICAgICAgICAgICAnbWFwSWQnOiBtYXBFbnRyeS5pZFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBwbGFjZXNcbiAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkucGxhY2VzID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZXNUcmVlID0gdHJlZVJlbmRlcmVyLnBsYWNlcyhtYXBFbnRyeSwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgXy5zZXRFdmVudHMocGxhY2VzVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLnVwZGF0ZVBsYWNlcyhtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cbn1cblxuY29uc3QgcGxhY2VzID0ge1xuICAgIGluaXQ6IF8uaW5pdCxcbiAgICBzaG93U29sb1BsYWNlOiBfLnNob3dTb2xvUGxhY2Vcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHBsYWNlcztcbiIsImltcG9ydCB0cmVlUmVuZGVyZXIgIGZyb20gJy4vZmFuY3l0cmVlLXJlbmRlcmVyLmpzJ1xuaW1wb3J0IGxheWVycyBmcm9tICcuL21hcC1sYXllcnMnXG5cbmZ1bmN0aW9uIGluaXQobWFwRW50cnkpIHtcbmNvbnN0IHJlZ2lvbnM9IG1hcEVudHJ5LnJlZ2lvbnM7XG5cbiAgICBpZiAocmVnaW9ucykge1xuICAgICAgICByZWdpb25zLmZvckVhY2goZnVuY3Rpb24ocmVnaW9uKSB7XG5cbiAgICAgICAgICAgIGxheWVycy5hZGQocmVnaW9uLCBtYXBFbnRyeSk7XG5cbiAgICAgICAgICAgIGlmIChyZWdpb24uY2hpbGRyZW4ubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICByZWdpb24uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZFJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICBsYXllcnMuYWRkKGNoaWxkUmVnaW9uLCBtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyZWVSZW5kZXJlci5yZWdpb25zKG1hcEVudHJ5KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBpbml0XG59O1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuXG5jb25zdCBfID0ge1xuICAgIGNhY2hlOiB7XG4gICAgICAgICRmaWx0ZXJQbGFjZXM6bnVsbFxuICAgIH0sXG4gICAgaW5pdDogKCkgPT4ge1xuICAgICAgICBfLmNhY2hlLiRmaWx0ZXJQbGFjZXMgPSAkKCdpbnB1dFtuYW1lPWZpbHRlclBsYWNlc10nKTtcblxuICAgICAgICAkKCdib2R5JykuYXBwZW5kKCc8ZGl2IGlkPVwib3ZlcmxheURldGFpbEhlbHBlclwiPicpO1xuXG4gICAgICAgIF8ucmVzZXQoKTtcbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgIF8uY2FjaGUuJGZpbHRlclBsYWNlcy52YWwoJycpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IF8uaW5pdCxcbiAgICByZXNldDogXy5yZXNldFxufVxuIiwiXG5jb25zdCBhamF4UHJveHlQb3J0ID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vcGFja2FnZS5qc29uJykucHJvamVjdC5hamF4UHJveHlQb3J0O1xuXG5pbXBvcnQgbWFwICBmcm9tICcuL2FqYXhNYXAtbWFwJ1xuXG5pbXBvcnQgbWFwTGF5ZXJzICBmcm9tICcuL21hcC1sYXllcnMnXG5pbXBvcnQgcmVnaW9ucyBmcm9tICcuL2FqYXhNYXAtcmVnaW9ucydcbmltcG9ydCBwbGFjZXMgZnJvbSAnLi9hamF4TWFwLXBsYWNlcydcbmltcG9ydCBsb2NhdGlvblR5cGVzIGZyb20gJy4vYWpheE1hcC1sb2NhdGlvblR5cGVzJ1xuaW1wb3J0IGZhbmN5VHJlZVJlbmRlcmVyIGZyb20gJy4vZmFuY3l0cmVlLXJlbmRlcmVyJ1xuXG5pbXBvcnQge2luc2VyU2NyaXB0VGFnfSBmcm9tICcuL3V0aWxpdHlzJ1xuXG5pbXBvcnQgdWkgZnJvbSAnLi4vbGliL2FqYXhNYXAtdWknO1xuXG5jbGFzcyBBamF4TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihtYXBFbnRyeSkge1xuICAgICAgICB0aGlzLm1hcEVudHJ5ID0gbWFwRW50cnk7XG5cbiAgICAgICAgbWFwRW50cnkuaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICBtYXBFbnRyeS5sYXllcnMgPSBbXTsvLzg4IG1heWJlIHdobGUgaW5pdD9cbiAgICAgICAgdGhpcy4kbWFwRWwgPSBudWxsO1xuICAgIH1cblxuICAgIHBhblRvKGxhdCwgbG9uZykge1xuXG4gICAgfVxufVxuXG5sZXQgYWpheE1hcDtcbmNvbnN0IF8gPSB7XG4gICAgcGFuVG86IChtYXBJZCkgPT4ge1xuICAgICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgICAgLy8pIGNvbnNvbGUubG9nKG1hcENlbnRlciwgJyoqKioqKioqKioqKioqKioqJykvL2h0dHA6Ly9qc2ZpZGRsZS5uZXQvZnF0N0wvMS9cbiAgICB9LFxuXG4gICAgaW5pdEFsbE1hcHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgY29uc3QgbWFwU3RvcmUgPSBhamF4TWFwLmNvbmZpZ0RhdGEubWFwU3RvcmU7XG5cbiAgICAgICAgICAgIGFqYXhNYXAubWFwcyA9IG1hcFN0b3JlLm1hcCgobWFwRW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhamF4TWFwSW5zdGFuY2UgPSBuZXcgQWpheE1hcChtYXBFbnRyeSk7XG5cbiAgICAgICAgICAgICAgICBtYXAuYnVpbGQobWFwRW50cnkpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25UeXBlcy5pbml0KG1hcEVudHJ5LCByZXNwb25zZS5sb2NhdGlvblR5cGVzKTtcblxuICAgICAgICAgICAgICAgICAgICBtYXBMYXllcnMuYnVpbGRTdGF0aWMobWFwRW50cnkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMuaW5pdChtYXBFbnRyeSlcblxuICAgICAgICAgICAgICAgICAgICBwbGFjZXMuaW5pdChtYXBFbnRyeSlcblxuICAgICAgICAgICAgICAgICAgICBmYW5jeVRyZWVSZW5kZXJlci5jYXRlZ29yeShtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIGZhbmN5VHJlZVJlbmRlcmVyLnBsYWNlR3JvdXAobWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9zYW1lIGFzIG1hcHN0b3JlISFubyBtcGFzdG9yZSBpcyBbbWFwRW50cmFdIG5vdCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGFqYXhNYXAubG9va1VwW21hcEVudHJ5LmlkXSA9IGFqYXhNYXBJbnN0YW5jZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBhamF4TWFwSW5zdGFuY2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9XG59O1xuXG5hamF4TWFwID0gey8vICAgIFRPRE86XG4gICAgLy9zZXQgcHVibGljIG1ldGhvZHMgYW5kIHZhcnMuXG4gICAgLy9lZzpjb25maWcgZGF0YSA6c2V0dGluZ3MucGxhY2VUcmVlLnJlbmRlckl0ZW1GdW5jdGlvblxuICAgIGJhc2VQYXRoOiAnJyxcbiAgICBsb29rVXA6IHt9LC8vb2JqZWN0IG9mIGluc3RhbmNlc1xuICAgIG1hcHM6IFtdLC8vYXJyYXkgb2YgYWpheC1tYXAgb2JqZWN0XG4gICAgYWpheFNlcnZlclBhdGg6ICdodHRwOi8vbG9jYWxob3N0OicgKyBhamF4UHJveHlQb3J0LC8vdGhpcyBwYXRoIHdpbGwgYmUgcmVwbGFjZWQgYmVpIGJ1aWxkIHNjcmlwdDogc2VlIHJlYWRtZS50eHRcbiAgICBjb25maWdEYXRhOiBudWxsLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oY29uZmlnRGF0YSkge1xuICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT0nICsgY29uZmlnRGF0YS5tYXBTZXR0aW5ncy5rZXlzLmdvb2dsZU1hcFxuICAgICAgICBhamF4TWFwLmNvbmZpZ0RhdGEgPSBjb25maWdEYXRhO1xuXG5cbiAgICAgICAgaW5zZXJTY3JpcHRUYWcodXJsKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGFqYXhNYXAuY29uZmlnRGF0YSA9IGNvbmZpZ0RhdGE7XG5cbiAgICAgICAgICAgIF8uaW5pdEFsbE1hcHMoKVxuXG4gICAgICAgICAgICB1aS5pbml0KCk7XG5cbiAgICAgICAgICAgIC8vUHJvbWlzZS5hbGwoYWpheE1hcC5tYXBzKVxuICAgICAgICB9LCBjb25zb2xlLmVycm9yKVxuICAgIH1cbn07XG5cbmV4cG9ydFxuZGVmYXVsdFxuYWpheE1hcDtcbiIsImltcG9ydCBhamF4TWFwIGZyb20gJy4vYWpheE1hcCdcbmltcG9ydCBwbGFjZXMgZnJvbSAnLi9hamF4TWFwLXBsYWNlcydcbmltcG9ydCBsb2NhdGlvblR5cGVzIGZyb20gJy4vYWpheE1hcC1sb2NhdGlvblR5cGVzJ1xuaW1wb3J0IGZpbHRlciAgZnJvbSAnLi9hamF4TWFwLXBsYWNlcy1maWx0ZXInXG5pbXBvcnQge3NvcnR9ICBmcm9tICcuL3V0aWxpdHlzJ1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuXG5pbXBvcnQgJ2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUuZWRpdCc7XG5pbXBvcnQgJ2pxdWVyeS5mYW5jeXRyZWUvZGlzdC9tb2R1bGVzL2pxdWVyeS5mYW5jeXRyZWUuZ2x5cGgnO1xuaW1wb3J0ICdqcXVlcnkuZmFuY3l0cmVlL2Rpc3QvbW9kdWxlcy9qcXVlcnkuZmFuY3l0cmVlLmZpbHRlcic7XG5cbi8qKlxuICogUmVuZGVycyBhIGZhbmN5VHJlZVxuICogZmV0Y2hlcyBqc29uIGRhdGEgYnkgYWpheCBjYWxsXG4gKlxuICogQHBhcmFtIHNlbGVjdCBTZWxlY3RvciBmb3Igbm9kZVxuICogQHBhcmFtIGFjdGlvbiBBamF4IGVJRCBhY3Rpb24gbmFtZVxuICogQHBhcmFtIG1hcElkXG4gKiBAcGFyYW0gc2V0dGluZ3MgT3B0aW9uYWwgc2V0dGluZ3NcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVHJlZUFqYXgoc2VsZWN0LCBhY3Rpb24sIG1hcElkLCBzZXR0aW5ncykge1xuXG4gICAgdmFyIGxvY2FsU2V0dGluZ3MgPSB7XG4gICAgICAgIGNoZWNrYm94OiB0cnVlLFxuICAgICAgICBjb29raWVJZDogXCJmYW5jeVRyZWVcIiArIGFjdGlvbiArIG1hcElkLFxuICAgICAgICBzZWxlY3RNb2RlOiAzLFxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IGFqYXhNYXAubG9va1VwW21hcElkXS5tYXBFbnRyeVxuXG4gICAgICAgICAgICBwbGFjZXMudXBkYXRlKG1hcEVudHJ5LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogICBzb3VyY2U6IHtcbiAgICAgICAgIHVybDogXCJpbmRleC5waHBcIixcbiAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICBkYXRhOiB7XG4gICAgICAgICAnaWQnOiBtYXBTZXR0aW5ncy5wYWdlSWQsXG4gICAgICAgICAnYXBpJzogXCJtYXBcIixcbiAgICAgICAgICdhY3Rpb24nOiBhY3Rpb24sXG4gICAgICAgICAnbWFwSWQnOiBtYXBJZFxuICAgICAgICAgfVxuICAgICAgICAgfSovXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGxvY2FsU2V0dGluZ3NbcHJvcGVydHldID0gc2V0dGluZ3NbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5kaXIobG9jYWxTZXR0aW5ncylcblxuICAgICQoc2VsZWN0KS5mYW5jeXRyZWUobG9jYWxTZXR0aW5ncykuZGF0YSgnbWFwSWQnLCBtYXBJZCk7XG59XG5cbmNvbnN0IF8gPSB7XG5cbiAgICBnZXRQbGFjZVRyZWVTZXR0aW5nczogKG1hcEVudHJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IHBsYWNlc1RyZWVDb25maWcgPSBtYXBFbnRyeS5zZXR0aW5ncy5wbGFjZXNUcmVlID8gbWFwRW50cnkuc2V0dGluZ3MucGxhY2VzVHJlZVxuICAgICAgICAgICAgOiBhamF4TWFwLmNvbmZpZ0RhdGEubWFwU2V0dGluZ3Muc2V0dGluZ3MucGxhY2VzVHJlZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29va2llSWQ6ICdmYW5jeVRyZWVQbGFjZXMnICsgbWFwRW50cnkuaWQsXG4gICAgICAgICAgICBzZWxlY3RNb2RlOiBwbGFjZXNUcmVlQ29uZmlnLnNlbGVjdE1vZGUsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICBtYXBOdW1iZXI6IG1hcEVudHJ5LmlkLC8vODg/P1xuICAgICAgICAgICAgICAgIG1hcElkOiBtYXBFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICBtYXA6IG1hcEVudHJ5Lmdvb2dsZU1hcCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpY29uOiBwbGFjZXNUcmVlQ29uZmlnLmljb24sXG4gICAgICAgICAgICBleHRlbnNpb25zOiBwbGFjZXNUcmVlQ29uZmlnLmV4dGVuc2lvbnMsXG4gICAgICAgICAgICBxdWlja3NlYXJjaDogcGxhY2VzVHJlZUNvbmZpZy5xdWlja3NlYXJjaCxcbiAgICAgICAgICAgIGZpbHRlcjogcGxhY2VzVHJlZUNvbmZpZy5maWx0ZXIsXG4gICAgICAgICAgICBhY3RpdmF0ZTogcGxhY2VzLnNob3dTb2xvUGxhY2UobWFwRW50cnkpLFxuICAgICAgICAgICAgYXV0b1Njcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbmRlclRpdGxlOiAoZXZlbnQsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGxhY2VzVHJlZUNvbmZpZy5yZW5kZXJJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwbGFjZXNUcmVlQ29uZmlnLnJlbmRlckl0ZW0oZXZlbnQsIGRhdGEpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAvL3JldHVybiBtYXJrdXA7Ly8oJzxzcGFuPm1hdXM8L3NwYW4+JylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVUcmVlID0ge1xuICAgIHBsYWNlczogKG1hcEVudHJ5LCBjaGlsZHJlbikgPT4ge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPVxuICAgICAgICAgICAgZmFuY3l0cmVlU2VsZWN0b3IucGxhY2VzICsgbWFwRW50cnkuaWQ7XG5cbiAgICAgICAgdmFyICRyb290Tm9kZSA9XG4gICAgICAgICAgICAkKHNlbGVjdG9yKS5mYW5jeXRyZWUoJ2dldFJvb3ROb2RlJyk7XG5cbiAgICAgICAgJHJvb3ROb2RlLnJlbW92ZUNoaWxkcmVuKCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ2NoaWxkcmVuJywgY2hpbGRyZW4sICcrKysrKycpXG5cbiAgICAgICAgJHJvb3ROb2RlLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblxuICAgICAgICAkcm9vdE5vZGUuc29ydENoaWxkcmVuKHNvcnQuYXBsaGFiZXRpYy5hc2MsIGZhbHNlKTtcblxuICAgICAgICBmaWx0ZXIudXBkYXRlKCRyb290Tm9kZSwgbWFwRW50cnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGZhbmN5dHJlZVNlbGVjdG9yID0ge1xuICAgIGxvY2F0aW9uVHlwZTogJyNhamF4TWFwTG9jYXRpb25UeXBlc1RyZWUnLFxuICAgIGNhdGVnb3J5OiAnI2FqYXhNYXBDYXRlZ29yeVRyZWUnLFxuICAgIHJlZ2lvbnM6ICcjYWpheE1hcFJlZ2lvbnNUcmVlJyxcbiAgICBwbGFjZUdyb3VwOiAnI2FqYXhNYXBQbGFjZUdyb3VwVHJlZScsXG4gICAgcGxhY2VzOiAnI2FqYXhNYXBQbGFjZXNUcmVlJ1xufVxuXG5jb25zdCByZW5kZXJUcmVlID0ge1xuICAgIHBsYWNlczogKG1hcEVudHJ5LCBjaGlsZHJlbikgPT4ge1xuICAgICAgICBjb25zdCAkcGxhY2VUcmVlID0gJChmYW5jeXRyZWVTZWxlY3Rvci5wbGFjZXMgKyBtYXBFbnRyeS5pZCk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBfLmdldFBsYWNlVHJlZVNldHRpbmdzKG1hcEVudHJ5KTtcblxuICAgICAgICAkcGxhY2VUcmVlLmZhbmN5dHJlZShzZXR0aW5ncyk7XG4gICAgICAgICRwbGFjZVRyZWUucmVuZGVyTm9kZSA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICBhbGVydCgnZGZmZGZmc2FmJylcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkYXRhLm5vZGUsXG4gICAgICAgICAgICAgICAgJHRkTGlzdCA9ICQobm9kZS50cikuZmluZChcIj50ZFwiKTtcbiAgICAgICAgICAgICR0ZExpc3QuZXEoMSkudGV4dChub2RlLmtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVUcmVlLnBsYWNlcyhtYXBFbnRyeSwgY2hpbGRyZW4pO1xuXG4gICAgICAgIHZhciBwbGFjZXNUcmVlID0gJHBsYWNlVHJlZS5mYW5jeXRyZWUoJ2dldFRyZWUnKTtcbiAgICAgICAgcmV0dXJuIHBsYWNlc1RyZWVcbiAgICB9LFxuXG4gICAgY2F0ZWdvcnk6IChtYXBFbnRyeSkgPT4ge1xuICAgICAgICByZW5kZXJUcmVlQWpheChcbiAgICAgICAgICAgICcjYWpheE1hcENhdGVnb3J5VHJlZScgKyBtYXBFbnRyeS5pZCxcbiAgICAgICAgICAgIFwibGlzdENhdGVnb3JpZXNcIixcbiAgICAgICAgICAgIG1hcEVudHJ5LmlkLFxuICAgICAgICAgICAgbWFwRW50cnkuc2V0dGluZ3MuY2F0ZWdvcnlUcmVlXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBwbGFjZUdyb3VwOiBmdW5jdGlvbihtYXBFbnRyeSkge1xuICAgICAgICByZW5kZXJUcmVlQWpheChcbiAgICAgICAgICAgICcjYWpheE1hcFBsYWNlR3JvdXBUcmVlJyArIG1hcEVudHJ5LmlkLFxuICAgICAgICAgICAgXCJsaXN0UGxhY2VHcm91cHNcIixcbiAgICAgICAgICAgIG1hcEVudHJ5LmlkLFxuICAgICAgICAgICAgbWFwRW50cnkuc2V0dGluZ3MucGxhY2VHcm91cFRyZWVcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHJlZ2lvbnM6IChtYXBFbnRyeSkgPT4ge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IG1hcEVudHJ5LnNldHRpbmdzLnJlZ2lvblRyZWU7XG5cbiAgICAgICAgJCgnI2FqYXhNYXBSZWdpb25zVHJlZScgKyBtYXBFbnRyeS5pZCkuZmFuY3l0cmVlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoZWNrYm94OiBvcHRpb25zLmNoZWNrYm94LFxuICAgICAgICAgICAgICAgIGNvb2tpZUlkOiAnZmFuY3lUcmVlUmVnaW9ucycgKyBtYXBFbnRyeS5pZCxcbiAgICAgICAgICAgICAgICBtaW5FeHBhbmRMZXZlbDogb3B0aW9ucy5taW5FeHBhbmRMZXZlbCxcbiAgICAgICAgICAgICAgICBzZWxlY3RNb2RlOiBvcHRpb25zLnNlbGVjdE1vZGUsXG4gICAgICAgICAgICAgICAgc291cmNlOiBtYXBFbnRyeS5yZWdpb25zLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogb3B0aW9ucy5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogb3B0aW9ucy5leHRlbnNpb25zLFxuICAgICAgICAgICAgICAgIGdseXBoOiBvcHRpb25zLmdseXBoLFxuICAgICAgICAgICAgICAgIGljb246IG9wdGlvbnMuaWNvbnMsXG4gICAgICAgICAgICAgICAgc2VsZWN0OiBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwTnVtYmVyID0gZ2V0TWFwTnVtYmVyKGRhdGEudHJlZS5vcHRpb25zLmNvb2tpZUlkLnNwbGl0KCdmYW5jeVRyZWVSZWdpb25zJylbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGRhdGEudHJlZS5nZXRTZWxlY3RlZE5vZGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEtleXMgPSAkLm1hcChzZWxlY3RlZE5vZGVzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhamF4TWFwLnVwZGF0ZUxheWVycyhtYXBOdW1iZXIsIHNlbGVjdGVkS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVBsYWNlcyhtYXBOdW1iZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGxvY2F0aW9uVHlwZXM6IGZ1bmN0aW9uKG1hcEVudHJ5KSB7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSBtYXBFbnRyeS5zZXR0aW5ncy5sb2NhdGlvblR5cGVUcmVlO1xuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgY2hlY2tib3g6IG9wdGlvbnMuY2hlY2tib3gsXG4gICAgICAgICAgICBjb29raWVJZDogXCJmYW5jeVRyZWVMb2NhdGlvblR5cGVzXCIgKyBtYXBFbnRyeS5pZCxcbiAgICAgICAgICAgIHNlbGVjdE1vZGU6IG9wdGlvbnMuc2VsZWN0TW9kZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IG9wdGlvbnMuZXh0ZW5zaW9ucyxcbiAgICAgICAgICAgIGdseXBoOiBvcHRpb25zLmdseXBoLFxuICAgICAgICAgICAgZmlsdGVyOiBvcHRpb25zLmZpbHRlcixcbiAgICAgICAgICAgIHNvdXJjZTogbWFwRW50cnkubG9jYXRpb25UeXBlcyxcbiAgICAgICAgICAgIHNlbGVjdDogZnVuY3Rpb24oZmxhZywgbm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBOdW1iZXIgPSBnZXRNYXBOdW1iZXIobm9kZS50cmVlLm9wdGlvbnMuY29va2llSWQuc3BsaXQoJ2ZhbmN5VHJlZUxvY2F0aW9uVHlwZXMnKVsxXSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVQbGFjZXMobWFwTnVtYmVyLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbG9jYXRpb25UeXBlcy50cmVlU2VsZWN0b3IgKyBtYXBFbnRyeS5pZDtcbiAgICAgICAgJChzZWxlY3RvcikuZmFuY3l0cmVlKHNldHRpbmdzKTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZW5kZXJUcmVlO1xuIiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGQuZWdnZXJtYW5uIG9uIDMwLjEwLjE5LlxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgTWFya2VyQ2x1c3RlcmVyIGZyb20gJ0Bnb29nbGUvbWFya2VyY2x1c3RlcmVyJ1xuXG5jb25zdCBoZWxwZXJzID0ge1xuICAgICAgICBnZXRMb2NhdGlvblR5cGU6IChtYXBFbnRyeSwgdHlwZUlkKSA9PlxuICAgICAgICAgICAgbWFwRW50cnkubG9jYXRpb25UeXBlcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgKGl0ZW0pID0+aXRlbS5rZXkgPT09IHR5cGVJZFxuICAgICAgICAgICAgKVxuICAgICAgICAsXG4gICAgICAgIGdldFNlbGVjdGVkS2V5czogKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmVlID0gJChzZWxlY3RvcikuZmFuY3l0cmVlKCdnZXRUcmVlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdHJlZS5nZXRTZWxlY3RlZE5vZGVzID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICB0cmVlLmdldFNlbGVjdGVkTm9kZXMoKS5tYXAoKG5vZGUpID0+IHBhcnNlSW50KG5vZGUua2V5KSkgOlxuICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICB9LFxuICAgICAgICBzZXREaW1lbnNpb246ICgkbWFwRWwsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAkbWFwRWwuaGVpZ2h0KHJlc3BvbnNlLmhlaWdodCkud2lkdGgocmVzcG9uc2Uud2lkdGgpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRMYXRMb25nOiAoY29vcmRzU3RyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvb3Jkc1N0cikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbWFwIFtsYXQsbG9uZ10nKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb29yZHMgPSBjb29yZHNTdHIuc3BsaXQoJywnKS5tYXAoKHBhcnQpID0+IHBhcnNlRmxvYXQocGFydCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE1hcFR5cGU6ICh0eXBlKSA9PiB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ29vZ2xlLm1hcHMuTWFwVHlwZUlkLlNBVEVMTElURTtcbiAgICAgICAgICAgICAgICBjYXNlICczJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLk1hcFR5cGVJZC5IWUJSSUQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnb29nbGUubWFwcy5NYXBUeXBlSWQuVEVSUkFJTjtcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIDAgLSAnU3R5bGVkIE1hcCcgYW5kIDEgLSAnUm9hZCBNYXAnIHdpbGwgYmVjb21lIFJPQURNQVBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdvb2dsZS5tYXBzLk1hcFR5cGVJZC5ST0FETUFQO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICxcbiAgICAgICAgZ2V0TWFwU3R5bGU6IChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT09ICcwJyAmJiByZXNwb25zZS5tYXBTdHlsZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICQucGFyc2VKU09OKCdbJyArIHJlc3BvbnNlLm1hcFN0eWxlICsgJ10nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBnZXRJbmZvV2luZG93OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coe1xuICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogMzcwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TWFya2VyQ2x1c3RlcmVyOiAobWFwLCBtYXJrZXJDbHVzdGVyZXIpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXJrZXJDbHVzdGVyZXIobWFwLCBbXSwgbWFya2VyQ2x1c3RlcmVyKVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVHb29nbE1hcDogKHJlc3BvbnNlLCAkZWwpID0+IHtcblxuICAgICAgICAgICAgaGVscGVycy5zZXREaW1lbnNpb24oJGVsLCByZXNwb25zZSk7XG4gICAgICAgICAgICBjb25zdCBtYXBUeXBlID0gaGVscGVycy5nZXRNYXBUeXBlKHJlc3BvbnNlLnR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbWFwU3R5bGUgPSBoZWxwZXJzLmdldE1hcFN0eWxlKHJlc3BvbnNlLnR5cGUpO1xuXG4gICAgICAgICAgICBsZXQgbWFwQ2VudGVyID0gaGVscGVycy5nZXRMYXRMb25nKHJlc3BvbnNlLm1hcENlbnRlcik7XG5cbiAgICAgICAgICAgIC8vYnVpbGQgbWFwXG4gICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLk1hcChcbiAgICAgICAgICAgICAgICAkZWxbMF0sIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbTogcmVzcG9uc2UuaW5pdGlhbFpvb20sXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcjogbWFwQ2VudGVyLFxuICAgICAgICAgICAgICAgICAgICBtYXBUeXBlSWQ6IG1hcFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlczogbWFwU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHJlc3BvbnNlLmRpc2FibGVEZWZhdWx0VUlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG5cbmV4cG9ydCBjb25zdCBnZXRMb2NhdGlvblR5cGUgPSBoZWxwZXJzLmdldExvY2F0aW9uVHlwZTtcbmV4cG9ydCBjb25zdCBnZXRTZWxlY3RlZEtleXMgPSBoZWxwZXJzLmdldFNlbGVjdGVkS2V5cztcbmV4cG9ydCBkZWZhdWx0IGhlbHBlcnM7XG4iLCJjb25zdCBfPXtcbiAgICBnZXRCYXNlUGF0aDogKCkgPT4ge1xuICAgICAgICBpZihfLmJhc2VQYXRoKXtcbiAgICAgICAgICAgIHJldHVybiBfLmJhc2VQYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFzZVBhdGggPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIFwiL1wiO1xuICAgICAgICBjb25zdCB3ZWJraXRQYXRoID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIFwiL1wiO1xuXG4gICAgICAgIF8uYmFzZVBhdGggPSAhd2luZG93LmxvY2F0aW9uLm9yaWdpbiA/IGJhc2VQYXRoIDogd2Via2l0UGF0aDtcblxuICAgICAgICByZXR1cm4gXy5iYXNlUGF0aDtcbiAgICB9LFxufVxuXG5jb25zdCBsYXllcnMgPSB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbihtYXBFbnRyeSwgbGF5ZXJJZHMpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nTGF5ZXJzID0gbWFwRW50cnkubGF5ZXJzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgKGV4aXN0aW5nTGF5ZXJzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ0tleXMgPSBPYmplY3Qua2V5cyhleGlzdGluZ0xheWVycyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4aXN0aW5nS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBleGlzdGluZ0tleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVySWRzLmluZGV4T2YocGFyc2VJbnQoa2V5KSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5sYXllcnNba2V5XS5zZXRNYXAobWFwRW50cnkubWFwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5sYXllcnNba2V5XS5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKG5ld0xheWVyRGF0YSwgbWFwRW50cnkpIHtcbiAgICAgICAgLy8gICAgICAgIDg4XG4gICAgICAgIGlmICghbWFwRW50cnkubGF5ZXJzW25ld0xheWVyRGF0YS5rZXldKSB7XG5cbiAgICAgICAgICAgIHZhciBsYXllclVybCA9IF8uZ2V0QmFzZVBhdGgoKSArIG5ld0xheWVyRGF0YS5maWxlLFxuXG4gICAgICAgICAgICAgICAgbGF5ZXJPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBjbGlja2FibGU6IG5ld0xheWVyRGF0YS5jbGlja2FibGUsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlVmlld3BvcnQ6IG5ld0xheWVyRGF0YS5wcmVzZXJ2ZVZpZXdwb3J0LFxuICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc0luZm9XaW5kb3dzOiBuZXdMYXllckRhdGEuc3VwcHJlc3NJbmZvV2luZG93c1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBuZXdMYXllciA9IG5ldyBnb29nbGUubWFwcy5LbWxMYXllcihsYXllclVybCwgbGF5ZXJPcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmV3TGF5ZXIpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG1hcEVudHJ5LmxheWVyc1tuZXdMYXllckRhdGEua2V5XSA9IG5ld0xheWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTdGF0aWM6IGZ1bmN0aW9uKGxheWVyRGF0YSwgbWFwRW50cnkpIHtcbiAgICAgICAgY29uc3QgbGF5ZXJVcmwgPSBfLmdldEJhc2VQYXRoKCkgKyBsYXllckRhdGEuZmlsZTtcblxuICAgICAgICBjb25zdCBsYXllck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjbGlja2FibGU6IGxheWVyRGF0YS5jbGlja2FibGUsXG4gICAgICAgICAgICBwcmVzZXJ2ZVZpZXdwb3J0OiBsYXllckRhdGEucHJlc2VydmVWaWV3cG9ydCxcbiAgICAgICAgICAgIHN1cHByZXNzSW5mb1dpbmRvd3M6IGxheWVyRGF0YS5zdXBwcmVzc0luZm9XaW5kb3dzXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbmV3TGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuS21sTGF5ZXIobGF5ZXJVcmwsIGxheWVyT3B0aW9ucyk7XG4gICAgICAgIG5ld0xheWVyLnNldE1hcChtYXBFbnRyeS5tYXApO1xuICAgIH0sXG5cbiAgICBidWlsZFN0YXRpYzogZnVuY3Rpb24obWFwRW50cnkpIHtcbiAgICAgICAgY29uc3Qgc3RhdGljTGF5ZXJzID0gbWFwRW50cnkuc2V0dGluZ3Muc3RhdGljTGF5ZXJzXG5cbiAgICAgICAgaWYgKHN0YXRpY0xheWVycykge1xuICAgICAgICAgICAgc3RhdGljTGF5ZXJzLmZvckVhY2goZnVuY3Rpb24oc3RhdGljTGF5ZXIpIHtcblxuICAgICAgICAgICAgICAgIGxheWVycy5hZGRTdGF0aWMoc3RhdGljTGF5ZXIsIG1hcEVudHJ5KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0aWNMYXllci5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljTGF5ZXIuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZFJlZ2lvbikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcnMuYWRkU3RhdGljKGNoaWxkUmVnaW9uLCBtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgbGF5ZXJzO1xuIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuaW1wb3J0IGRldGFpbFZpZXcgZnJvbSAnLi9hamF4TWFwLXBsYWNlcy1kZXRhaWwtdmlldyc7XG5pbXBvcnQge2dldEFkZHJlc3N9IGZyb20gJy4vdXRpbGl0eXMnXG5cbmltcG9ydCBtYXJrZXJJbmZvV2luZG93IGZyb20gJy4vbWFwLW1hcmtlci1pbmZvLXdpbmRvdydcbmNvbnN0IF8gPSB7XG4gICAgY2FjaGU6IHt9LFxuICAgIG1hcmt1cDoge1xuICAgICAgICBhZGRyZXNzOiAoYWRkcmVzc0pzb24pID0+IHtcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID1cbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImluZm9XaW5kb3dBZGRyZXNzXCI+PGRpdiBjbGFzcz1cImluZm9XaW5kb3dTdHJlZXRcIj4nICsgYWRkcmVzc0pzb24uYWRkcmVzcyArICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImluZm9XaW5kb3daaXBcIj4nICsgYWRkcmVzc0pzb24uemlwICsgJzwvZGl2PjxkaXYgY2xhc3M9XCJpbmZvV2luZG93Q2l0eVwiPicgKyBhZGRyZXNzSnNvbi5jaXR5ICsgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuXG4gICAgICAgIH0sXG4gICAgICAgIGNhdGVnb3J5TGlzdDogKGNhdGVnb3JpZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBsaXN0O1xuXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgICAgIGxpc3QgPSAnPGRpdj48dWwgY2xhc3M9XCJwbGFjZUNhdGVnb3JpZXNcIj4nO1xuICAgICAgICAgICAgICAgICQuZWFjaChjYXRlZ29yaWVzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdCArPSAnPGxpPicgKyB0aGlzLnRpdGxlICsgJzwvbGk+JztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaXN0ICs9ICc8L3VsPjwvZGl2Pic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50OiAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGxhY2UgPSBkYXRhLnBsYWNlLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5TGlzdCA9IGRhdGEuY2F0ZWdvcnlMaXN0LFxuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBkYXRhLmFkZHJlc3M7XG5cbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gJyc7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgKz0gKHBsYWNlLnRpdGxlKSA/ICc8aDQgY2xhc3M9XCJpbmZvV2luZG93VGl0bGVcIj4nICsgcGxhY2UudGl0bGUgKyAnPC9oND4nIDogXCJcIjtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gKHBsYWNlLmljb24pID9cbiAgICAgICAgICAgICAgICAnPGltZyB3aWR0aD1cIjEyMHB4XCIgY2xhc3M9XCJpbmZvV2luZG93SW1hZ2VcIiBzcmM9XCInICsgcGxhY2UuaWNvbiArICdcIi8+JyA6IFwiXCI7XG5cbiAgICAgICAgICAgIC8vJzxwIGNsYXNzPVwiaW5mb1dpbmRvd0Rlc2NyaXB0aW9uXCI+JyArIHBsYWNlLmRlc2NyaXB0aW9uICsgJzwvcD4nO1xuICAgICAgICAgICAgY29udGVudCArPSBjYXRlZ29yeUxpc3QgPyBjYXRlZ29yeUxpc3QgOiAnJztcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gYWRkcmVzcyA/IGFkZHJlc3MgOiAnJztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiAgc3BlY2lhbCBmb3IgZXh0LiBicm93c2VyIHNlZSBiZWxvdyAtIHNob3VsZCBiZSBjaGFuZ2VkIHRvIHVzZSBvd24gY29udGVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250ZW50ICs9ICc8ZGl2IGNsYXNzPVwiYnJvd3NlckhlbHBlclwiPjxhIGNsYXNzPVwibW9yZSBkZXRhaWwtdmlld1wiIGhyZWY9XCIjXCI+bWVocjwvYT48L2Rpdj4nO1xuXG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QWRkcmVzczogKHBsYWNlKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcmt1cCA9IF8ubWFya3VwLmFkZHJlc3M7XG5cbiAgICAgICAgICAgIGlmIChwbGFjZS5hZGRyZXNzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtYXJrdXAocGxhY2UuYWRkcmVzcykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHBsYWNlLnVpZCkudGhlbihmdW5jdGlvbihhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcGxhY2UuYWRkcmVzcyA9IGFkZHJlc3M7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtYXJrdXAoYWRkcmVzcykpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH0sXG5cblxuICAgIGluaXRDYWNoZTogKCkgPT4ge1xuICAgICAgICBfLmNhY2hlLiRib2R5ID0gJCgnYm9keScpO1xuICAgICAgICBfLmNhY2hlLiRtb3JlRGV0YWlsVmlldyA9ICQoJy5tb3JlLmRldGFpbC12aWV3Jyk7XG5cbiAgICB9LFxuICAgIGNoZWNrQ2FjaGU6ICgpID0+IHtcbiAgICAgICAgaWYgKF8uY2FjaGUuJGJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uaW5pdENhY2hlKCk7XG4gICAgfVxuXG59XG5cbmNvbnN0IGluZm9XaW5kb3cgPSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgaW5mbyB3aW5kb3cgY29udGVudCBmb3IgYSBwbGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHBsYWNlXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfVxuICAgICAqL1xuICAgIGdldEluZm9XaW5kb3dDb250ZW50OiBmdW5jdGlvbihwbGFjZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIF8uZ2V0QWRkcmVzcyhwbGFjZSkudGhlbigoYWRkcmVzc01hcmt1cCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHRvZG8gbWFrZSBjb250ZW50IHJlbmRlcmluZyBjb25maWd1cmFibGUsIGFkZCBsaW5rIGZvciBvdmVybGF5IHdpdGggYWRkaXRpb25hbCBpbmZvXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1aWxkIGEgbGlzdCBvZiBwbGFjZSdzIGNhdGVnb3JpZXNcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0TWFya3VwID0gXy5tYXJrdXAuY2F0ZWdvcnlMaXN0KHBsYWNlLmNhdGVnb3JpZXMpXG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzTWFya3VwLFxuICAgICAgICAgICAgICAgICAgICBsaXN0TWFya3VwLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKF8ubWFya3VwLmNvbnRlbnQoZGF0YSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGNyZWF0ZU9uQ2xpY2s6IChtYXBFbnRyeSwgcGxhY2UpID0+IGZ1bmN0aW9uKCkge1xuICAgICAgICBfLmNoZWNrQ2FjaGUoKTtcblxuICAgICAgICBjb25zdCBtYXAgPSBtYXBFbnRyeS5nb29nbGVNYXAsXG4gICAgICAgICAgICBpbmZvV2luZG93ID0gbWFwRW50cnkuaW5mb1dpbmRvdztcblxuICAgICAgICBtYXJrZXJJbmZvV2luZG93LmdldEluZm9XaW5kb3dDb250ZW50KHBsYWNlKS50aGVuKGZ1bmN0aW9uKGNvbnRlbnQpIHtcblxuICAgICAgICAgICAgaW5mb1dpbmRvdy5zZXRDb250ZW50KGNvbnRlbnQpO1xuXG5cbiAgICAgICAgICAgIC8vODg4IHNob3VsZCBiZSBtdWx0aXBsZT9cbiAgICAgICAgICAgIF8uY2FjaGUuJGJvZHkuYXBwZW5kKCc8ZGl2IGlkPVwiZGV0YWlsVmlld1wiPjxhIGlkPVwib3ZlcmxheS1jbG9zZVwiIHN0eWxlPVwiZGlzcGxheTogaW5saW5lO1wiPjwvYT48ZGl2IGNsYXNzPVwiaW5uZXJcIj48L2Rpdj48L2Rpdj4nKTtcblxuICAgICAgICAgICAgJCgnI2RldGFpbFZpZXcnKS5kYXRhKCdwbGFjZUlkJywgcGxhY2Uua2V5KTtcblxuICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcCwgdGhpcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9XaW5kb3csICdkb21yZWFkeScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBfLmNhY2hlLiRtb3JlRGV0YWlsVmlld1xuICAgICAgICAgICAgLnVuYmluZChcImNsaWNrXCIpXG4gICAgICAgICAgICAuYmluZCgnY2xpY2snLCAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgLy9UT0RPOiByZWZhY3RvciB3aXRob3V0IGRhdGEtYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgZGV0YWlsVmlldy5vcGVuKFwiaW5mb1dpbmRvd1wiLCAtMSlcblxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbmZvV2luZG93O1xuIiwiaW1wb3J0IHtnZXRMb2NhdGlvblR5cGV9IGZyb20gJy4vbWFwLWhlbHBlcnMnXG5pbXBvcnQgbWFwSGVscGVycyBmcm9tICcuL21hcC1oZWxwZXJzJ1xuaW1wb3J0IGluZm9XaW5kb3cgZnJvbSAnLi9tYXAtbWFya2VyLWluZm8td2luZG93J1xuXG5mdW5jdGlvbiBhZGRNYXJrZXJDbGlja0Z1bmN0aW9uKG1hcEVudHJ5LCBwbGFjZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5hamF4TWFwQ29uZmlnICYmIGFqYXhNYXBDb25maWcub25NYXJrZXJDbGljaykge1xuICAgICAgICAgICAgYWpheE1hcENvbmZpZy5vbk1hcmtlckNsaWNrKG1hcEVudHJ5LCBwbGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvV2luZG93LmNyZWF0ZU9uQ2xpY2soKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKG1hcEVudHJ5LCBwbGFjZSkge1xuICAgIHZhciBtYXAgPSBtYXBFbnRyeS5nb29nbGVNYXAsXG4gICAgICAgIGN1cnJUeXBlID0gcGxhY2UubG9jYXRpb25UeXBlICYmIHBsYWNlLmxvY2F0aW9uVHlwZS5rZXksXG4gICAgICAgIGN1cnJMYXRsbmcgPSBtYXBIZWxwZXJzLmdldExhdExvbmcocGxhY2UuZ2VvQ29vcmRpbmF0ZXMpO1xuXG4gICAgdmFyIG1hcE1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICBwb3NpdGlvbjogY3VyckxhdGxuZyxcbiAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgIHRpdGxlOiBwbGFjZS50aXRsZVxuICAgIH0pO1xuXG4gICAgaWYgKGN1cnJUeXBlKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uVHlwID0gZ2V0TG9jYXRpb25UeXBlKG1hcEVudHJ5LCBjdXJyVHlwZSlcbiAgICAgICAgbWFwTWFya2VyLnNldEljb24obG9jYXRpb25UeXAuaWNvbik7XG4gICAgfVxuXG4gICAgbWFwTWFya2VyLm1hcE51bWJlciA9IG1hcEVudHJ5LmlkO1xuICAgIG1hcE1hcmtlci5wbGFjZSA9IHBsYWNlO1xuXG4gICAgLy8gYWRkIGNsaWNrIGZ1bmN0aW9uXG4gICAgY29uc3QgY2xpY2tGdW5jdGlvbiA9IGFkZE1hcmtlckNsaWNrRnVuY3Rpb24obWFwRW50cnksIHBsYWNlKTtcblxuICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcE1hcmtlciwgJ2NsaWNrJywgY2xpY2tGdW5jdGlvbilcblxuICAgIHJldHVybiBtYXBNYXJrZXI7XG59XG5cbmNvbnN0IG1hcmtlciA9IHtcbiAgICBjcmVhdGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hcmtlcjtcbiIsIi8qKlxuICogQ3JlYXRlZCBieSBkLmVnZ2VybWFubiBvbiAzMC4xMC4xOS5cbiAqL1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuaW1wb3J0IGFqYXhNYXAgZnJvbSAnLi9hamF4TWFwJ1xuXG5leHBvcnQgY29uc3Qgc29ydCA9IHtcbiAgICBhcGxoYWJldGljOiB7XG4gICAgICAgIGFzYzogKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGEgPSBhLnRpdGxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBiID0gYi50aXRsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBudW1tZXJpYzp7XG4gICAgICAgIGFzYzogKGEsIGIpID0+IHtcbiAgICAgICAgICAgIC8vVG9kbyBQb3N0bGVpdHphaGxcbiAgICAgICAgICAgIGEgPSBhLnRpdGxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBiID0gYi50aXRsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgaW5zZXJTY3JpcHRUYWcgPSAoc3JjKSA9PiB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHNyYztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gcmVqZWN0O1xuXG4gICAgICAgIHZhciBlbnRyeSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgZW50cnkucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBlbnRyeSk7XG4gICAgfSlcbn1cbi8qKlxuICogZ2V0IGFkZHJlc3MgZm9yIGEgc2luZ2xlIHBsYWNlXG4gKiBAcGFyYW0gcGxhY2VJZFxuICogQHJldHVybiBqc29uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBZGRyZXNzID0gKHBsYWNlSWQpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICB1cmw6IGFqYXhNYXAuYWpheFNlcnZlclBhdGgsXG4gICAgICAgICAgICB0eXBlOiBHRVQsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgJ2lkJzogYWpheE1hcC5jb25maWdEYXRhLm1hcFNldHRpbmdzLnBhZ2VJZCxcbiAgICAgICAgICAgICAgICAnYXBpJzogJ21hcCcsXG4gICAgICAgICAgICAgICAgJ2FjdGlvbic6IFwiZ2V0QWRkcmVzc1wiLFxuICAgICAgICAgICAgICAgICdwbGFjZUlkJzogcGxhY2VJZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgZXJyb3I6IHJlamVjdFxuICAgICAgICB9KTtcbiAgICB9KVxufVxuXG4iLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IGFqYXhNYXAgZnJvbSAnLi9saWIvYWpheE1hcCc7XG5cbmltcG9ydCAnLi4vLi4vLi4vZGlzdC9jc3MvbWFpbi5jc3MnXG5pbXBvcnQge2Nzc30gZnJvbSAnanF1ZXJ5LmZhbmN5dHJlZS9kaXN0L3NraW4tYXdlc29tZS91aS5mYW5jeXRyZWUubWluLmNzcyc7XG5cbiQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKCFtYXBTdG9yZSB8fCAhKG1hcFN0b3JlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCcgbm8gbWFwc3RvcmUnLCBtYXBTdG9yZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZ0RhdGEgPSB7XG4gICAgICAgIG1hcFNldHRpbmdzOiB3aW5kb3cubWFwU2V0dGluZ3MsXG4gICAgICAgIG1hcFN0b3JlOiB3aW5kb3cubWFwU3RvcmVcbiAgICB9XG5cbiAgICBhamF4TWFwLmluaXQoY29uZmlnRGF0YSk7Ly9pbml0aWFsaXplIGFsbCBtYXBzXG59KVxuXG5cblxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==